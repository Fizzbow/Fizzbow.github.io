<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vuex</title>
      <link href="/2021/10/09/paper-vuex/"/>
      <url>/2021/10/09/paper-vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><ul><li>当多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态无能为力</li><li>来自不同组件的行为需要变更同一状态，以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码</li><li>综上，<strong>当项目遇到多个组件依赖于同一状态时；或者来自不同组件的行为需要变更同一状态时</strong>可以使用Vuex</li></ul><blockquote><p>Vuex是一个专为Vue.js应用程序开发的状态管理插件，它采用集中式存储管理应用的所有继承状态，而改变状态的唯一方法是提交mutation,例如<code>this.$store.commit('SET_video_pause',video_pause,SET_video_pause)</code>为mutations属性中定义的方法</p></blockquote><h2 id="引入Vuex"><a href="#引入Vuex" class="headerlink" title="引入Vuex"></a>引入Vuex</h2><ul><li>安装依赖npm install vuex –save</li><li>项目目录src中建立store文件夹</li><li>在store文件夹下新建index.js文件，写入<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from 'vue';</span><br><span class="line">import Vuex from 'vuex';</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line">//不是在生产环境debug为true</span><br><span class="line">const debug = process.env.NODE_ENV !== 'production';</span><br><span class="line">//创建Vuex实例对象</span><br><span class="line">const store = new Vuex.Store({</span><br><span class="line">    strict:debug,//在不是生产环境下都开启严格模式</span><br><span class="line">    state:{</span><br><span class="line">    },</span><br><span class="line">    getters:{</span><br><span class="line">    },</span><br><span class="line">    mutations:{</span><br><span class="line">    },</span><br><span class="line">    actions:{</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">export default store;</span><br></pre></td></tr></tbody></table></figure></li><li>main.js中引入Vuex<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import Vue from 'vue';</span><br><span class="line">import App from './App.vue';</span><br><span class="line">import store from './store';</span><br><span class="line">const vm = new Vue({</span><br><span class="line">    store:store,</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">}).$mount('#app')</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="Vuex核心属性"><a href="#Vuex核心属性" class="headerlink" title="Vuex核心属性"></a>Vuex核心属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex的state相当于一个全局的state，你可以在component的任何地方获取和修改它。如果有些状态严格属于单个组件，最好还是作为组件的局部状态</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取state</span><br><span class="line">this.$store.state.count</span><br></pre></td></tr></tbody></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>Vuex里的getters类似于computed，可以认为是store的计算属性，getter的返回值会根据它的依赖被缓存起来，且只有当它的以来至发生了改变才会被重新计算</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//直接使用</span><br><span class="line">this.$store.getters.doneTodoCount</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">import {mapGetters} from 'vuex'</span><br><span class="line">computed:mapGetters({</span><br><span class="line">    doneCount:'doneTodoCount'</span><br><span class="line">})</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>更改Vuex的store状态的唯一方法时提交mutaion，mutation必须是同步函数</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//直接触发mutations</span><br><span class="line">this.$store.commit('xxx')</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">import { mapMutations } from 'vuex'</span><br><span class="line">methods：mapMutations(['increment' ])</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>Action类似mutation，不同在于</p><ul><li>Action提交的是mutation，而不是直接变更状态</li><li>Action可以包含任何异步操作<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//触发action</span><br><span class="line">store.dispatch('increment')</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">import {mapActions} from 'vuex'</span><br><span class="line">methods:mapActions(['increment'])</span><br></pre></td></tr></tbody></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store对象就有可能变得臃肿，为了解决以上问题，Vuex允许我们将store分割成模块(moudule)。每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块–从上至下进行相同方式的分割<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = {</span><br><span class="line">  state: { ... },</span><br><span class="line">  mutations: { ... },</span><br><span class="line">  actions: { ... },</span><br><span class="line">  getters: { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const moduleB = {</span><br><span class="line">  state: { ... },</span><br><span class="line">  mutations: { ... },</span><br><span class="line">  actions: { ... }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store({</span><br><span class="line">  modules: {</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目，仿写去哪儿app</title>
      <link href="/2021/10/05/paper-project-VueWhere/"/>
      <url>/2021/10/05/paper-project-VueWhere/</url>
      
        <content type="html"><![CDATA[<h1 id="首页数据前台接口部分"><a href="#首页数据前台接口部分" class="headerlink" title="首页数据前台接口部分"></a>首页数据前台接口部分</h1><h2 id="优化冗余路径"><a href="#优化冗余路径" class="headerlink" title="优化冗余路径"></a>优化冗余路径</h2><blockquote><p>把<a href="http://localhost:8080/static/mock">http://localhost:8080/static/mock</a>   冗余的路径替换成api</p></blockquote><p><img src="api1.jpg" alt="alt"><br><img src="api3.jpg" alt="alt"></p><blockquote><p>修改系统文件，在webpack下设置代理项，重置路径</p></blockquote><p><img src="api2.jpg" alt="alt"></p><h1 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h1><h2 id="项目中使用到的路由跳转的方法"><a href="#项目中使用到的路由跳转的方法" class="headerlink" title="项目中使用到的路由跳转的方法"></a>项目中使用到的路由跳转的方法</h2><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>实现hot页面上点击的城市渲染到header上<br><img src="router1.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>&lt;router-link :to = "{name:'home'}"&gt;</code> 建议使用name<br><code>&lt;router-link :to = "{path:'/home'}"&gt;</code></p><blockquote><p>router-link中链接如果是’/‘开始就是从根路由开始,如果开始不带’/‘,则从当前路由开始</p></blockquote></li><li><p>带参数</p></li></ul><p><code>&lt;router-link :to="{name:'home',params:{id:1}}"&gt;</code></p><blockquote><p>params传参(类似post) 配置path:”/home:id”或path:”/home/:id”,刷新页面id会保留，不配置path；第一次可请求，刷新页面id会消失</p></blockquote><p><code>&lt;router-link :to = "{name:'home',query:{id:1}}"&gt;</code></p><blockquote><p>query传参(类似get，url后面会显示参数)路由不可配置</p></blockquote><h3 id="this-router-push-函数里调用"><a href="#this-router-push-函数里调用" class="headerlink" title="this.$router.push()(函数里调用)"></a>this.$router.push()(函数里调用)</h3><p><img src="router2.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>this.$router.push('/home')</code><br><code>this.$router.push({name:'home'})</code><br><code>this.$router.push({path:'/home'})</code></p></li><li><p>query传参<br><code>this.$router.push({name:'home',query:{id:'1'})</code><br><code>this.$router.push({path:'/home',query:{id:'1'}})</code></p></li><li><p>params传参<br><code>this.$router.push(name:'home',params:{id:'1'})</code> 只能用name</p></li></ul><h2 id="keep-alive减少相同请求优化"><a href="#keep-alive减少相同请求优化" class="headerlink" title="keep-alive减少相同请求优化"></a>keep-alive减少相同请求优化</h2><ul><li>不切换城市的时候不需要重新发送dataHome请求<br><img src="route.jpg" alt="alt"></li><li>设置keep-alive<br><img src="route1.jpg" alt="alt"></li><li>需要重新设置Home里的请求数据的方法getHttp（）<br><img src="route2.jpg" alt="alt"></li></ul><h1 id="vuex实现子组件到子组件的通信"><a href="#vuex实现子组件到子组件的通信" class="headerlink" title="vuex实现子组件到子组件的通信"></a>vuex实现子组件到子组件的通信</h1><ul><li>点击hot页面的城市跳转到首页并且header右边的城市变为相对应的城市<br>项目相关配置<br><img src="vuex.jpg" alt="alt"><br>List文件下配置<br><img src="vuex1.jpg" alt="alt"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原型</title>
      <link href="/2021/09/25/paper-prototype/"/>
      <url>/2021/09/25/paper-prototype/</url>
      
        <content type="html"><![CDATA[<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><h2 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h2><blockquote><p>在js中，创建对象有好几种方式，比如对象字面量，或者是直接通过构造函数new一个对象出来，虽然都是对象，却存在着差异性，js中，我们将对象分为函数对象和普通对象。函数对象就是用函数来模拟类的实现</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function func1(){}</span><br><span class="line">const func2 = function(){};</span><br><span class="line">const func3 = new Function('name','console.log(name)');</span><br><span class="line"></span><br><span class="line">const obj1 = {};</span><br><span class="line">const obj2 = new Object();</span><br><span class="line">const obj3 = new func1();</span><br><span class="line">const obj4 = new new Function();</span><br><span class="line"></span><br><span class="line">console.log(typeof Object);//function</span><br><span class="line">console.log(typeof Function);//function</span><br></pre></td></tr></tbody></table></figure><ul><li>上述代码中，obj1,obj2,obj3,obj4都是普通对象</li><li>func1，func2，func3都是Function的实例，也就是函数对象</li><li>可以看出<strong>所有Function的实例都是函数对象其他都为普通对象包括Function实例的实例</strong></li><li>Function和new Function的关系为<code>Function.__proto__=== Function.prototype</code><blockquote><p>__proto__和constructor是对象独有的，prototype属性是函数独有的，但是在js中函数也是对象，所以函数也拥有__proto__和constructor属性</p></blockquote></li></ul><p><img src="1.jpg" alt="alt"></p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><blockquote><p>es规范里描述prototype是一个隐式引用，但是之前的一些浏览器已经私自实现了__proto__这个属性，使得可以通过obj.__proto__这个显示的属性访问访问到被定义为隐式属性的prototype</p></blockquote><ul><li>__proto__属性既不能被for…in遍历出来，也不能被Object.keys(obj)查找出来</li><li>访问对象的obj.<strong>proto</strong>,默认走的是object.prototype对象上__proto__属性的get/set方法</li><li>__proto__是函数指向对象</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>__proto__是对象所独有的，并且__proto__是一个对象指向父类对象，它的作用是当你在访问一个对象属性的时候，如果对象内部没有这个属性，那他就在他的__proto__属性所指的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那他就在他父类的__proto__所指的对象上查找，以此类推，直到找到null，这个查找的过程也构成了原型链</p></blockquote><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><blockquote><p>在规范里，prototype被定义为<strong>给其他对象提供共享属性的对象</strong></p></blockquote><ul><li>prototype自己也是对象，只是被用以承担某个职能</li><li>所有对象都可以作为另一个对象的prototype使用</li><li>prototype是<strong>函数</strong>独有的，它的作用是可以给特定类型的所有实例提供共享的属性和方法，<strong>任何函数在创建的时候，都会给该函数添加prototype属性</strong><br><img src="2.jpg" alt="alt"></li></ul><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><blockquote><p>constructor属性也是对象所独有的，它是<strong>一个对象指向一个函数</strong>，这个函数就是该对象的构造函数</p></blockquote><ul><li>每个对象都有对应本身或者继承而来的构造函数</li><li>只有prototype对象有constructor这个属性</li><li>在每个函数创建的时候js会同时创建一个prototype对象，且<code>该对象创建的函数.__proto__ === 该函数.prototype</code>，<code>该函数.prototype.constructor === 该函数</code></li><li>所以通过函数创建的对象即使已经没有constructor属性，也能通过__proto__找到对应的constructor<br><img src="3.jpg" alt="alt"><blockquote><p>上图虚线表示继承来的constructor</p></blockquote></li></ul><h1 id="typeof-amp-amp-instanceof"><a href="#typeof-amp-amp-instanceof" class="headerlink" title="typeof &amp;&amp; instanceof"></a>typeof &amp;&amp; instanceof</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><blockquote><p>typeof一般被用来判断一个变量的类型</p></blockquote><ul><li>我们可以使用typeof来判断number、undefined、symbol、string、function、boolean、object 这七种数据类型，</li><li>但是判断Object的时候并不能明确的告诉你object属于哪一种object<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s = new String('abc');</span><br><span class="line">typeof s === 'object'//true</span><br><span class="line">typeof null;//'object'</span><br></pre></td></tr></tbody></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3>js在底层存储变量的时候会在变量的机器码的低位1-3位存储其类型信息</li><li>1：整数</li><li>110：布尔</li><li>100：字符串</li><li>010：浮点数</li><li>000：对象<br>对于undefined和null、，这两个值的信息存储是特殊的</li><li>null：所有机器码均为0</li><li>undefined：用 −2^30 整数来表示<blockquote><p>在使用typeof来判断变量类型的时候，最好用typeof来判断基本数据类型，避免对null的判断</p></blockquote></li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>instanceof运算符用来检测constructor.prototype是否存在于object的原型链上，与typeof方法不同的是，instanceof方法要求开发者明确地确认对象为某特定类型</p></blockquote><ul><li>如下，是instanceof的基本用法，它可以判断一个实例是否是其父类型或者祖先类型的实例<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 定义构造函数</span><br><span class="line">function C(){} </span><br><span class="line">function D(){} </span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o instanceof D; // false，因为 D.prototype 不在 o 的原型链上</span><br><span class="line"></span><br><span class="line">o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true</span><br><span class="line">C.prototype instanceof Object // true，同上</span><br><span class="line"></span><br><span class="line">C.prototype = {};</span><br><span class="line">var o2 = new C();</span><br><span class="line"></span><br><span class="line">o2 instanceof C; // true</span><br><span class="line"></span><br><span class="line">o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.</span><br><span class="line"></span><br><span class="line">D.prototype = new C(); // 继承</span><br><span class="line">var o3 = new D();</span><br><span class="line">o3 instanceof D; // true</span><br><span class="line">o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h1><blockquote><p>大多数浏览器中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时拥有prototype属性和__proto__属性，因此同时存在两条继承链</p></blockquote><ul><li>子类的__proto__属性，表示<strong>构造函数</strong>的继承，总是指向父类</li><li>子类prototype属性的__proto__属性，表示<strong>方法</strong>的继承，总是指向父类的prototype属性<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class Father{ </span><br><span class="line">}</span><br><span class="line">Class Child extends Father{</span><br><span class="line">}</span><br><span class="line">Child.__proto__ === Father;//true</span><br><span class="line">Child.prototype.__proto__ === Father.prototype;//true</span><br></pre></td></tr></tbody></table></figure>上面代码中，子类的__proto__属性指向父类，子类的prototype属性的__proto__属性指向父类的prototype属性<br>这样是因为类的继承是按照下面的模式实现的<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Class Father{</span><br><span class="line">}</span><br><span class="line">Class Child{</span><br><span class="line">}</span><br><span class="line">//Child的实例继承Father的实例</span><br><span class="line">Object.setPrototypeOf(Child.prototype,Father.prototype);</span><br><span class="line">//Child继承Father的静态属性</span><br><span class="line">Object.setPrototype(Child,Father)</span><br><span class="line"></span><br><span class="line">const c = new Child();</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>Object.setPrototypeOf</code>方法的实现如下：<br>Object.setPrototypeOf = function(obj,proto){<br>    obj.<strong>proto</strong> = proto;<br>    return obj;<br>}<br>因此就得到了上面的结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(Child.prototype,Father.prototype);</span><br><span class="line">//等同于</span><br><span class="line">Child.prototype.__proto__ = Father.prototype;</span><br><span class="line">Object.setPrototypeOf(Child,Father);</span><br><span class="line">//等同于</span><br><span class="line">Child.__proto__ = Father;</span><br></pre></td></tr></tbody></table></figure><p>这两条继承链可以这样理解：作为一个对象，子类(Child)的原型(__proto__属性)是父类(Father)；作为一个构造函数，子类(Child)的原型对象(prototype属性)是父类原型对象(prototype属性)的实例</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = Object.create(Father.prototype);</span><br><span class="line">Child.prototype.__proto__ = Father.prototype;</span><br></pre></td></tr></tbody></table></figure><p>extends关键字后面可以跟很多种类型的值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Father{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中的Father只要有一个有prototype属性的函数就能被Child继承，由于函数都有prototype属性(处理Function.prototype函数)，因此Father可以是任何函数<br>下面讨论两种情况，第一种，子类继承Object类</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Object{</span><br><span class="line">}</span><br><span class="line">Child.__proto__ === Object//ture</span><br><span class="line">Child.prototype.__proto__ = Object.prototype //true</span><br></pre></td></tr></tbody></table></figure><p>这种情况下，Child其实就是构造函数Object的复制，Child的实例就是Object的实例<br>第二种情况，不存在任何继承</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C{</span><br><span class="line">}</span><br><span class="line">C.__proto__ === Function.prototype; //true</span><br><span class="line">C.prototype.__proto__ === Object.prototype; //true</span><br></pre></td></tr></tbody></table></figure><p>这种情况下，C作为一个基类(即不存在任何继承)就是一个普通函数，所以直接继承Function.prototype，但是C调用后返回一个空对象(即Object实例)，所以C.prototype.__proto__指向构造函数(Object)的prototype属性</p><h1 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的__proto__属性"></a>实例的__proto__属性</h1><p>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性，也就是说，子类原型的原型，是父类的原型</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Father(2,3);</span><br><span class="line">var p2 = nw Child(2,3,'neo');</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ //false</span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ //true</span><br></pre></td></tr></tbody></table></figure><ul><li>上面代码中Child继承了Father，导致前者原型的原型是后者的原型</li><li>通过子类实例的__proto__.__proto__属性可以修改父类实例的行为<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p2.__proto__.__proto__.personName = function(){</span><br><span class="line">    console.log('one')</span><br><span class="line">}</span><br><span class="line">p1.personName()//'one'</span><br></pre></td></tr></tbody></table></figure></li><li>上面代码在Child的实例p2上向Father类添加方法，结果影响到了Father类的实例p1<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="ES5继承实现方式"><a href="#ES5继承实现方式" class="headerlink" title="ES5继承实现方式"></a>ES5继承实现方式</h2>es5规范中新增了Object.create()方法，该方法会传入一个对象，返回一个对象，返回的对象的原型指向传入的对象。比如执行代码var output = Object.create(input)，相当于执行代码output.<strong>proto</strong> = input,output的原型是input<br>Object.keys()方法用以获取对象自身的属性数组，我们可以用该方法简化继承父类静态属性和方法的过程<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function extendsClass(child,Father){</span><br><span class="line">    Child.prototype = Object.create(Father.prototype);</span><br><span class="line">    Child.prototype.constructor = child;</span><br><span class="line"></span><br><span class="line">    Object.keys(Father).forEach(function(key){</span><br><span class="line">        Child[key] = Father[key]</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="ES6继承-class继承"><a href="#ES6继承-class继承" class="headerlink" title="ES6继承(class继承)"></a>ES6继承(class继承)</h2><blockquote><p>Class可以通过extends关键字实现继承，这比ES5通过原型链实现继承要清晰和方便的多</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Father{</span><br><span class="line">}</span><br><span class="line">class Child extends Father{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码定义了一个Father类，该类通过extends关键字继承了Child类的所有属性和方法，由于内部没有添加代码，所有这两个类完全一样，等于复制了一个Child类</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Father{</span><br><span class="line">    constructor(x,y,color){</span><br><span class="line">        super(x,y);//调用父类的constructor(x,y)</span><br><span class="line">        this.color = color</span><br><span class="line">    }</span><br><span class="line">    toString(){</span><br><span class="line">        return this.color + ''+super.toString();//调用父类的toString </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码中，constructor方法和toString方法之中都出现了super’关键字，它在这里表示父级的构造函数，用来新建父级的this对象</p><blockquote><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例和方法后在对其进行加工，加上子类自己的实例属性和方法，如果不调研super方法，子类就得不到this对象</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Father{}</span><br><span class="line"></span><br><span class="line">class Child extends Father{</span><br><span class="line">    constructor(){</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let Ch = new Child()//ReferenceError</span><br><span class="line">//构造函数中没有调用super方法</span><br></pre></td></tr></tbody></table></figure><ul><li>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))。</li><li>ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法加到this上面，然后再用子类的构造函数修改this</li><li>如果子类没有定义constructor方法，这个方法会被默认添加</li><li>在子类的构造函数中，只有调用super之后才可用this关键字。这是因为子类实例的构建基于父类实例，只有super方法才能调用父类实例，下列代码中子类的constructor方法没有调用super直线使用this关键字会报错，放在super方法后就是对的<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Father{</span><br><span class="line">    constructor(x,y){</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    }</span><br><span class="line">    class Child extends Father{</span><br><span class="line">        constructor(x,y,age){</span><br><span class="line">            this.age = age;//ReferenceError</span><br><span class="line">            super(x,y);</span><br><span class="line">            this.age = age; //true</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let ch = new Child(25,8,18);</span><br><span class="line"></span><br><span class="line">ch instanceof Child;//true</span><br><span class="line">ch instanceof Father;//true</span><br><span class="line">//实例对象ch同时是Child和Father两个类的实例，与es5的行为完全一致</span><br></pre></td></tr></tbody></table></figure><blockquote><p>父类的静态方法也会被子类继承</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Father{</span><br><span class="line">    static hello(){</span><br><span class="line">        console.log('hello world')</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">class Child extends Father{</span><br><span class="line">}</span><br><span class="line">Child.hello()//hello world</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this/apply/call/bind</title>
      <link href="/2021/09/25/paper-this/"/>
      <url>/2021/09/25/paper-this/</url>
      
        <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><blockquote><p>es5中，<strong>this永远指向最后调用它的对象</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = 'windowsName';</span><br><span class="line">var a = {</span><br><span class="line">    name:null,</span><br><span class="line"></span><br><span class="line">    fn:function(){</span><br><span class="line">        console.log(this.name); //windowsName</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">var f = a.fn;</span><br><span class="line">f();</span><br></pre></td></tr></tbody></table></figure><p>虽然将a对象的fn方法赋值给变量f了，但是没有调用所以fn()，最后仍然是被window调用的</p><h1 id="怎么改变this指向"><a href="#怎么改变this指向" class="headerlink" title="怎么改变this指向"></a>怎么改变this指向</h1><h2 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var name = windowsName;</span><br><span class="line">var a ={</span><br><span class="line">    name:'csl',</span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        //匿名函数没有自己的this</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            this.func1()</span><br><span class="line">        },100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //this.func1 is not a function</span><br></pre></td></tr></tbody></table></figure><p>不使用箭头函数的情况下是会报错的，因为最后调用setTimeout的对象是window，window中没有func<br>函数</p><p>使用箭头函数后</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var name = windowsName;</span><br><span class="line">var a ={</span><br><span class="line">    name:'csl',</span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        setTimeout(()=&gt;{</span><br><span class="line">            this.func1()</span><br><span class="line">        },100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //csl</span><br></pre></td></tr></tbody></table></figure><p>箭头函数的this始终指向<strong>函数定义时</strong>的this，而非执行时。    </p><blockquote><p>箭头函数中没有this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this为undefined</p></blockquote><h2 id="2-在函数内部使用-this-this"><a href="#2-在函数内部使用-this-this" class="headerlink" title="2.在函数内部使用_this = this"></a>2.在函数内部使用_this = this</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name = windowsName;</span><br><span class="line">var a ={</span><br><span class="line">    name:'csl',</span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        var _this = this;</span><br><span class="line">        //匿名函数没有自己的this</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            _this.func1()</span><br><span class="line">        },100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //csl</span><br></pre></td></tr></tbody></table></figure><p>设置var _this = this，这里的this是调用func2的对象a，防止在func2中的setTimeout被window调用，这样在func2中我们使用_this就是指向对象a了</p><h2 id="3-new实例化一个对象"><a href="#3-new实例化一个对象" class="headerlink" title="3.new实例化一个对象"></a>3.new实例化一个对象</h2><h2 id="4-使用apply，call，bind"><a href="#4-使用apply，call，bind" class="headerlink" title="4.使用apply，call，bind"></a>4.使用apply，call，bind</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line"></span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            this.func1()</span><br><span class="line">        }.apply(a),100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //csl</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line"></span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            this.func1()</span><br><span class="line">        }.call(a),100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //csl</span><br></pre></td></tr></tbody></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line"></span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line">    func2:function(){</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            this.func1()</span><br><span class="line">        }.bind(a)(),100);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //csl</span><br></pre></td></tr></tbody></table></figure><h1 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h1><h2 id="apply定义"><a href="#apply定义" class="headerlink" title="apply定义"></a>apply定义</h2><blockquote><p>apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组或类数组提供的参数<br>语法：<code>func.apply(thisArg,[argsArray])</code></p></blockquote><ul><li>this.Arg:在func函数运行时指定的this值。<blockquote><p>需要注意的是指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动之乡全局对象，同时值为原始值的this会指向该原始值的自动包装对象</p></blockquote></li><li>argsArray:一个数组或者类数组对象，其中数组元素将作为单的的参数传给func函数<blockquote><p>如果该参数的值为null或undefined，则表示不需要传入任何参数，从es5中开始可以使用类数组对象</p></blockquote></li></ul><h2 id="apply-call的区别"><a href="#apply-call的区别" class="headerlink" title="apply/call的区别"></a>apply/call的区别</h2><p>apply和call基本类似，它们的区别只是传入的参数不同</p><ul><li>call的语法为:<code>func.call(thisArg[,arg1[,arg2[,...]]])</code></li><li>call方法接受的是若干个参数列表，而apply接受的是一个包含多个参数的数组</li></ul><p>apply():</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line">    fn:function(a,b){</span><br><span class="line">        console.log(a+b)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.apply(a,[1,2]); //3</span><br></pre></td></tr></tbody></table></figure><p>call():</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line">    fn:function(a,b){</span><br><span class="line">        console.log(a+b)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.call(a,1,2); //3</span><br></pre></td></tr></tbody></table></figure><h2 id="apply-call-bind区别-1"><a href="#apply-call-bind区别-1" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h2><blockquote><p>bind方法创建一个新的函数，当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列<br>bind是创建一个新函数，我们必须手动调用</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a ={</span><br><span class="line">    name:'csl',</span><br><span class="line">    fn:function(a,b){</span><br><span class="line">        console.log(a+b)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">var b = a.fn;</span><br><span class="line">b.bind(a,1,2)() //3</span><br></pre></td></tr></tbody></table></figure><h1 id="js的函数调用"><a href="#js的函数调用" class="headerlink" title="js的函数调用"></a>js的函数调用</h1><h2 id="1-作为一个函数调用"><a href="#1-作为一个函数调用" class="headerlink" title="1.作为一个函数调用"></a>1.作为一个函数调用</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = 'windowsName';</span><br><span class="line">function a(){</span><br><span class="line">    var name = 'csl';</span><br><span class="line">    </span><br><span class="line">    console.log(this.name); //windowsName</span><br><span class="line"></span><br><span class="line">    console.log('inner'+this);  //inner:window</span><br><span class="line">}</span><br><span class="line">a();</span><br><span class="line">console.log('outer'+this)   //outer:window</span><br></pre></td></tr></tbody></table></figure><p>这是一个最简单的函数，不属于任何一个对象，它在js的非严格模式属于window，严格模式就是undefined</p><h2 id="2-函数作为方法调用"><a href="#2-函数作为方法调用" class="headerlink" title="2.函数作为方法调用"></a>2.函数作为方法调用</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var name = 'windowsName';</span><br><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line">    fn:function(){</span><br><span class="line">        console.log(this.name); //csl</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">a.fn()</span><br></pre></td></tr></tbody></table></figure><p>定义一个对象a，对象a有属性name和一个方法fn，对象a调用了fn方法，所以this指向a的</p><h2 id="3-使用构造函数调用函数"><a href="#3-使用构造函数调用函数" class="headerlink" title="3.使用构造函数调用函数"></a>3.使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了new,看起来就像是创建了新的函数，但实际上是新创建的对象，所以this会指向新创建的对象</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(arg1,arg2){</span><br><span class="line">    this.firstName = arg1;</span><br><span class="line">    this.lastName = args2;</span><br><span class="line">}</span><br><span class="line">var a = new myFunction('cheng','sl');</span><br><span class="line">a.lastName; //'sl'</span><br></pre></td></tr></tbody></table></figure><p>扩展：<br>new的过程:</p><ul><li>创建一个空对象obj</li><li>将新建的空对象的隐式原型指向其构造函数的显示原型</li><li>使用call改变this指向</li><li>如果无返回值或返回一个非对象值，则将obj返回作为新对象；如果返回值是一个新对象的话直接返回该对象<br>伪代码表述如下：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = new myFunction('cheng','sl');</span><br><span class="line"></span><br><span class="line">new myFunction{</span><br><span class="line">    var obj = {};</span><br><span class="line">    obj.__proto__ = myFunction.prototype;</span><br><span class="line">    var result = myFunction.call(obj,'cheng','sl');</span><br><span class="line">    return typeof result === 'obj'?result:obj;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="4-作为函数方法调用函数-call-apply"><a href="#4-作为函数方法调用函数-call-apply" class="headerlink" title="4.作为函数方法调用函数(call,apply)"></a>4.作为函数方法调用函数(call,apply)</h2><blockquote><p>js中，函数是对象，对象有自己的属性和方法，则函数也有它的属性和方法，call，apply是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身</p></blockquote><ul><li>js严格模式下，调用函数时第一个参数会成为this的值，即使这个参数不是一个对象</li><li>js非严格模式下，如果第一个参数的值是null或undefined，它将使用全局对象替代<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = 'windowsName';</span><br><span class="line">function fn(){</span><br><span class="line">    var name = 'csl';</span><br><span class="line">    innerFunction()；</span><br><span class="line">    function innerFunction(){</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">fn()</span><br></pre></td></tr></tbody></table></figure>这里的innerFunction()的调用属于第一种作为函数调用的方式，它没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下this就是指向window的</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name = 'windowsName';</span><br><span class="line">var a = {</span><br><span class="line">    name:'csl',</span><br><span class="line"></span><br><span class="line">    func1:function(){</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    },</span><br><span class="line"></span><br><span class="line">    func2:function(){</span><br><span class="line">        setTimeout(function(){</span><br><span class="line">            this.func1()</span><br><span class="line">        },100)</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">a.func2() //this.func1 is not a function</span><br></pre></td></tr></tbody></table></figure><p>上面的例子可以简单理解为<strong>匿名函数的this永远只需window</strong>。<br>匿名函数都是自执行的，就是在匿名函数后面加()让其自执行，虽然匿名函数不能被其他对象调用，但是可以被函数调用，比如例子中的setTimeout</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量作用域、闭包</title>
      <link href="/2021/09/24/paper-closure/"/>
      <url>/2021/09/24/paper-closure/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><blockquote><p>当一个函数是在另一个函数中创建的时，该函数就称为嵌套的</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sayHiBye(firstName,lastName){</span><br><span class="line">    function getFullName(){</span><br><span class="line">        return firstName + '' + lastName;</span><br><span class="line">    }</span><br><span class="line">    alert('Hello,' + getFullName());</span><br><span class="line">    alert('Bye' + getFullName())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里创建的嵌套函数getFullName()是为了更加方便访问到外部变量，因此可以返回全名，<br>也可以作为一个新对象的属性或结果返回一个嵌套函数（如下代码），之后可以在其他地方调用，不论在哪调用，它仍然可以访问相同的外部变量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter(){</span><br><span class="line">    let count = 0;</span><br><span class="line">    return function(){</span><br><span class="line">        return count++;</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line">let counter = makeCounter();</span><br><span class="line">alert(counter());//0</span><br><span class="line">alert(counter());//1 可以累加</span><br></pre></td></tr></tbody></table></figure><h2 id="词法环境-Lexical-Environment"><a href="#词法环境-Lexical-Environment" class="headerlink" title="词法环境(Lexical Environment)"></a>词法环境(Lexical Environment)</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><p>js中，每个运行的函数，代码块以及整个脚本都有一个被称为词法环境的内部关联对象  </p></blockquote><p>词法环境对象由两部分组成    </p><ul><li>环境记录(Environment Record) 一个存储所有局部变量作为其属性(例如this的值)的对象</li><li>对外部词法环境的引用，与外部代码相关联    </li></ul><blockquote><p>一个变量只是环境记录这个特殊对象的一个属性，获取或修改变量相当于获取或修改词法环境的一个属性</p></blockquote><p>下面的图片中，矩形表示环境记录(变量存储)箭头表示外部引用，全局词法环境没有外部引用，所以箭头指向了null<br><img src="1.jpg" alt="alt"></p><p>下图演示了执行过程中<strong>全局词法环境</strong>的变化</p><ul><li>最初它们处于未初始化(Uninitalized)状态，在let声明前，不能引用它</li><li>let声明，但没赋值</li><li>phrase被赋值</li><li>phrase的值被修改<br><img src="2.jpg" alt="alt"></li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote><p>一个函数也是一个值，与变量不同的是<strong>函数声明的初始化会被立即完成</strong></p></blockquote><p>当创建了一个词法环境时，函数立即变得可用，这就是我们为什么可以在函数声明的定义之前调用函数声明</p><p>下图是添加一个函数时全局词法状态的初始状态<br><img src="3.jpg" alt="alt"></p><h3 id="内部和外部的词法环境"><a href="#内部和外部的词法环境" class="headerlink" title="内部和外部的词法环境"></a>内部和外部的词法环境</h3><blockquote><p>当函数被调用时，会自动创建一个新的词法环境来存储这个调用的局部变量和参数</p></blockquote><p>如下图，我们有两个词法环境：内部(函数)和外部(全局)，当调用say函数时，它会<strong>先搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，直到全局词法环境</strong><br><img src="4.jpg" alt="alt"></p><p>搜索过程如下：</p><ul><li>对于name变量，当say中的alert试图访问name时，会立即在内部词法环境中找到它</li><li>当它试图访问phrase时，内部无phrase，使用它顺着<strong>对外部词法环境的引用</strong>找到了它<br><img src="5.jpg" alt="alt"></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>闭包是指内部函数总是可以访问其所在的外部函数中的变量和参数，除了构造函数，其他的js函数都是天生闭包的，也就是说js函数会通过隐藏的[[Evironmrnt]]属性记住它们创建的位置，所以它们可以访问外部变量<br>返回文初的<code>makeCounter</code>这个例子</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function makeCounter(){</span><br><span class="line">    let count = 0;</span><br><span class="line">    return function(){</span><br><span class="line">        return count++</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line">let counter = makeCounter()</span><br></pre></td></tr></tbody></table></figure><p>在每次调用makeCount之前都会创建一个新的词法环境对象，以存储该makeCounter运行时的变量<br>因此，我们有两层的词法环境，还有一个未被使用的嵌套函数return count++，它依旧有一个名为[[Environment]]的隐藏属性，该属性保存了对创建该函数的词法环境的引用，因此，counter.[[Environment]]有对{content:0}词法环境的引用<br>当调用counter()时，会为该引用创建一个新的词法环境<br><img src="6.jpg" alt="alt"><br>当counter()中的代码查找count变量时，它会先搜索自己的词法环境(空),然后是外部makeCounter()的词法环境在哪里找到就在哪里修改(下图中是在count那里修改的变量)<br>如果我们调用多次counter()，count变量将会增加到2，3<br><img src="7.jpg" alt="alt"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul><li>函数<strong>调用完之后</strong>会将词法环境中的所有变量从内存中删除</li><li>如果有一个乔涛的函数在函数结束后仍可达，则它具有引用词法环境的[[Environment]]属性，例子如下<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function f(){</span><br><span class="line">    let value = 123;</span><br><span class="line"></span><br><span class="line">    return function(){</span><br><span class="line">        alert(++value);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let g = f();//g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用</span><br><span class="line">g();</span><br><span class="line">g();</span><br><span class="line">g(); //多次调用并且返回的函数被保存，所以相应的词法环境也会保留在内存中</span><br></pre></td></tr></tbody></table></figure>当词法环境对象变得不可达时，他就会死去，它仅在至少有一个乔涛韩束引用它时才会存在</li></ul><h2 id="一些闭包的例子"><a href="#一些闭包的例子" class="headerlink" title="一些闭包的例子"></a>一些闭包的例子</h2><h3 id="函数会选择最新的内容吗"><a href="#函数会选择最新的内容吗" class="headerlink" title="函数会选择最新的内容吗"></a>函数会选择最新的内容吗</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name = 'John';</span><br><span class="line">function sayHi(){</span><br><span class="line">    alert('Hi' + name);</span><br><span class="line">}</span><br><span class="line">name = 'Pete';</span><br><span class="line">sayHi();</span><br></pre></td></tr></tbody></table></figure><ul><li>函数将从内向外依次寻找目标变量，变量在全局中</li><li>name = ‘Pete’相当于给name重新赋值，这个函数使用最新的值</li></ul><h3 id="哪些变量可用"><a href="#哪些变量可用" class="headerlink" title="哪些变量可用"></a>哪些变量可用</h3><p><code>makeWorker</code>函数是否可以从它被创建的位置或者调用位置访问外部变量</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function makeWorker(){</span><br><span class="line">    let name = 'Pete';</span><br><span class="line"></span><br><span class="line">    return function(){</span><br><span class="line">        alert(name);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line">let name = 'John';</span><br><span class="line"></span><br><span class="line">let work = makeWorker();</span><br><span class="line">work()//pete</span><br></pre></td></tr></tbody></table></figure><h3 id="反复调用counter实例的方法时"><a href="#反复调用counter实例的方法时" class="headerlink" title="反复调用counter实例的方法时"></a>反复调用counter实例的方法时</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Counter(){</span><br><span class="line">    let count = 0;</span><br><span class="line"></span><br><span class="line">    this.up = function(){</span><br><span class="line">        return ++count</span><br><span class="line">    }</span><br><span class="line">    this.down = function(){</span><br><span class="line">        return --count;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">let counter = new Counter();</span><br><span class="line">console.log(counter.up());</span><br><span class="line">console.log(counter.down());</span><br><span class="line">console.log(counter.up());</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>这两个嵌套函数都是在同一个词法环境中创建的，使用它们可以共享对同一个count变量的访问，</li><li>使用前置自增++x，操作数x 将在自增后返回，所以第一个是1第二个是2，第三个是1</li></ul><h3 id="if内的函数"><a href="#if内的函数" class="headerlink" title="if内的函数"></a>if内的函数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let phrase = 'Hello';</span><br><span class="line">if(ture){</span><br><span class="line">    let user = 'John';</span><br><span class="line"></span><br><span class="line">    function sayHi(){</span><br><span class="line">        alert(`${phrase},${user}`)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">sayHi();</span><br></pre></td></tr></tbody></table></figure><ul><li>sayHi是在if内声明的，所以它只存在于if中外部是没有sayHi的</li></ul><h3 id="不可见变量"><a href="#不可见变量" class="headerlink" title="不可见变量"></a>不可见变量</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">function func(){</span><br><span class="line">    console.log(x);</span><br><span class="line">    let x = 2;</span><br><span class="line">}</span><br><span class="line">func();</span><br></pre></td></tr></tbody></table></figure><ul><li>let只在块级作用域下起作用，获取不到全局的x</li><li>并且有暂时性死区，无法变量提升，所以在函数执行时无法获取到下面的x值</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/09/20/paper-4/"/>
      <url>/2021/09/20/paper-4/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>一种遵从先进后出（LIFO）原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底</li><li>一摞叠起来的数或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要先将上面的书移走才可以</li><li>栈也被用在编程语言的编译器和内存中保存变量，方法调用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//在js中使用类来实现一个栈</span><br><span class="line">class Stack {</span><br><span class="line"></span><br><span class="line">constructor() {</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">push(element) {</span><br><span class="line">this.items.push(element)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">pop() {</span><br><span class="line">return this.items.pop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 末位</span><br><span class="line">get peek() {</span><br><span class="line">return this.items[this.items.length - 1]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 是否为空栈</span><br><span class="line">get isEmpty() {</span><br><span class="line">return !this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 尺寸</span><br><span class="line">get size() {</span><br><span class="line">return this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 清空栈</span><br><span class="line">clear() {</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印栈数据</span><br><span class="line">print() {</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">// 实例化一个栈</span><br><span class="line">const stack = new Stack()</span><br><span class="line">console.log(stack.isEmpty) // true</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">stack.push(5)</span><br><span class="line">stack.push(8)</span><br><span class="line"></span><br><span class="line">// 读取属性再添加</span><br><span class="line">console.log(stack.peek) // 8</span><br><span class="line">stack.push(11)</span><br><span class="line">console.log(stack.size) // 3</span><br><span class="line">console.log(stack.isEmpty) // false</span><br></pre></td></tr></tbody></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2></li><li>与栈相反，队列是一种遵循先进先出(FIFO)原则的一组有序的项，队列在尾部添加新元素，并从头移除元素。最新添加的元素必须排在队列的末尾</li><li>在现实中，最常见的例子就是排队，前面的人优先完成自己的事务，完成之后，下一个人才能继续<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Queue {</span><br><span class="line"></span><br><span class="line">constructor(items) {</span><br><span class="line">this.items = items || []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">enqueue(element){</span><br><span class="line">this.items.push(element)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dequeue(){</span><br><span class="line">return this.items.shift()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">front(){</span><br><span class="line">return this.items[0]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">clear(){</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get size(){</span><br><span class="line">return this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get isEmpty(){</span><br><span class="line">return !this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">print() {</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">const queue = new Queue()</span><br><span class="line">console.log(queue.isEmpty) // true</span><br><span class="line"></span><br><span class="line">queue.enqueue('John')</span><br><span class="line">queue.enqueue('Jack')</span><br><span class="line">queue.enqueue('Camila')</span><br><span class="line">console.log(queue.size) // 3</span><br><span class="line">console.log(queue.isEmpty) // false</span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.print() // 'Camila'</span><br></pre></td></tr></tbody></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3></li><li>优先队列是默认队列的修改版。现实生活中的例子就是机场登机的顺序，头等舱和商务舱乘客的优先级要高于经济舱乘客</li><li>优先队列元素的添加和移除是基于优先级的</li><li>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，按照优先级移除它们<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3></li><li>为充分利用向量空间，客服假溢出现象的方法是：将向量想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列。这种循环队列可以以单链表，队列的方式来实际编程应用中来实现<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="JS的数据类型和数据结构"><a href="#JS的数据类型和数据结构" class="headerlink" title="JS的数据类型和数据结构"></a>JS的数据类型和数据结构</h2><h3 id="基本类型（栈stack）"><a href="#基本类型（栈stack）" class="headerlink" title="基本类型（栈stack）"></a>基本类型（栈stack）</h3><pre><code>Number，String，Boolean，Null，Undefind，null（不可用typeof检测），Symbol（ES6中新增）：代表创建后独一无二且不可变的数据类型，它的出现我认为是为了解决可能出现的全局变量冲突的问题</code></pre><h3 id="引用数据类型（堆head）"><a href="#引用数据类型（堆head）" class="headerlink" title="引用数据类型（堆head）"></a>引用数据类型（堆head）</h3><pre><code>Object（包括Array，Function，Data）   </code></pre><h3 id="每个数据都需要一个内存空间"><a href="#每个数据都需要一个内存空间" class="headerlink" title="每个数据都需要一个内存空间"></a>每个数据都需要一个内存空间</h3><table><thead><tr><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>可直接操作保存在栈内存空间的值</td><td>不允许直接访问，不能直接操作</td></tr><tr><td>变量名，值       —&gt;引用</td><td>值</td></tr><tr><td>c，0X0012</td><td>[1,2,3]</td></tr></tbody></table><h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>基本数据类型的值是不可变的</li><li>基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回基本数据类型，不会保存结果</li><li>基本数据类型的赋值是简单赋值，基本数据类型的比较是值的比较</li><li>基本数据类型是存放在栈区的<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li><li>引用类型的值是可以改变的，例如对象就可以通过修改对象属性更改对象</li><li>引用类型可以添加属性方法</li><li>引用类型的赋值是对象引用，声明的变量标识符，存储的只是对象的指针地址</li><li>引用类型的比较是引用（指针地址）的比较</li><li>引用类型是同时保存在栈区和堆区中的，栈区保存变量标识符和指向堆内存的地址</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS四种遍历方法</title>
      <link href="/2021/09/12/post-name/"/>
      <url>/2021/09/12/post-name/</url>
      
        <content type="html"><![CDATA[<h1 id="JS的四种数组遍历方法：for-forEach-for-in-for…of的区别"><a href="#JS的四种数组遍历方法：for-forEach-for-in-for…of的区别" class="headerlink" title="JS的四种数组遍历方法：for/forEach()/for..in/for…of的区别"></a>JS的四种数组遍历方法：for/forEach()/for..in/for…of的区别</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;arr.length;++i)</span><br><span class="line">arr.forEach((v,i) =&gt;{})</span><br><span class="line">for(let i in arr)</span><br><span class="line">for(const i of arr)</span><br></pre></td></tr></tbody></table></figure><h2 id="语法上"><a href="#语法上" class="headerlink" title="语法上"></a>语法上</h2><p>使用for和for in，我们可以访问数组的下标，而不是元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i&lt;arr.length;++i){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用for/of,则可以直接访问数组的元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const v of arr){</span><br><span class="line">    console.log(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用forEach()，则可以同时访问数组的下标与元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach((v,i)=&gt;console.log(v));</span><br></pre></td></tr></tbody></table></figure><h2 id="非数字属性"><a href="#非数字属性" class="headerlink" title="非数字属性"></a>非数字属性</h2><p>JS的数组就是Object，这意味着我们可以给数组添加字符串属性<br>4种循环语法只有<em><strong>for…in</strong></em>不会忽略数字属性：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a','b','c'];</span><br><span class="line">arr.test = 'bad';</span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i]); //打印‘a，b，bad’</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他3种循环语法，都会忽略非数字属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a','b','c'];</span><br><span class="line">arr.test = 'abc';</span><br><span class="line"></span><br><span class="line">for(let i = 0;i &lt; arr.length ; ++i){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr.forEach((el,i) =&gt; console.log(i,el));</span><br><span class="line"></span><br><span class="line">for(const el of arr){</span><br><span class="line">    console.log(el)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><strong>提醒</strong></em>避免使用for..in来遍历数组</p><h2 id="数组的空元素"><a href="#数组的空元素" class="headerlink" title="数组的空元素"></a>数组的空元素</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a',,'c'];</span><br><span class="line">arr.length;//3</span><br></pre></td></tr></tbody></table></figure><p>循环语句处理[‘a’,,’c’]与[‘a’,undefined,’c’]的方式并不相同，对于前者<br>for…in和forEach会跳过空元素，而for与for…of则不会跳过</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i &lt;arr.length;++i){</span><br><span class="line">    console.log(arr[i]);  //打印'a,undefined,c'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for(const v of arr){</span><br><span class="line">    console.log(v); // 'a,undefined,c'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr.forEach(v =&gt; console.log(v)); //打印'a,c'</span><br><span class="line"></span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>for…in与forEach会跳过空元素<h2 id="remove-empty-elements"><a href="#remove-empty-elements" class="headerlink" title="remove empty elements"></a>remove empty elements</h2></li></ul><h2 id="函数的this"><a href="#函数的this" class="headerlink" title="函数的this"></a>函数的this</h2><p>for，for…in与for…of会保留外部作用域的this<br>对于forEach，如果不使用箭头函数，它的回调函数的this会发生变化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">'user strict'</span><br><span class="line">const arr = ['a'];</span><br><span class="line">arr.forEach(function(){</span><br><span class="line">console.log(this); //undefined</span><br><span class="line">})</span><br><span class="line">arr.forEach(() =&gt;{</span><br><span class="line">console.log(this);//{}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="Async-Await与Generators"><a href="#Async-Await与Generators" class="headerlink" title="Async/Await与Generators"></a>Async/Await与Generators</h2><p>不能在forEach回调函数里使用await和yield，会报错，对于for…of来说，则没有这个问题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFn(){</span><br><span class="line">    const arr = ['a','b','c'];</span><br><span class="line">    for(const el of arr){</span><br><span class="line">    await new Promise(resolve =&gt; setTimeout(resolve,1000));</span><br><span class="line">    console.log(el)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">function generatorFn(){</span><br><span class="line">    const arr = ['a','b','c'];</span><br><span class="line">    for(const el of arr){</span><br><span class="line">    yield new Promise(resolve =&gt; setTimeout(resolve,1000))</span><br><span class="line">    console.log(el)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>尽量不要在forEach中使用aysnc/await以及generators</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>for…of是遍历数组最常用的方式,它比for循环简洁，并且没有for/in和forEach()那么多奇怪的案例</li><li>for…of的缺点是我们取索引值不方便，但是如果使用for…of获取数组索引，可以这样写<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const [i,v] of arr.entries()){</span><br><span class="line">    console.log(i,v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo报错总结</title>
      <link href="/2021/09/12/paper-3/"/>
      <url>/2021/09/12/paper-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从零开始搭建hexo到安装theme主题这段比较顺利，到安装主题之后开始出现错误</p></blockquote><h2 id="1-Error-no-such-file-or-directory-scandir-‘…-’"><a href="#1-Error-no-such-file-or-directory-scandir-‘…-’" class="headerlink" title="1. Error:no such file or directory,scandir ‘….’"></a>1. Error:no such file or directory,scandir ‘….’</h2><p>加入主题之后运行所有hexo命令都会报如下错误<br><img src="image2.png" alt="alt"><br>排查之后，blog主题这一栏填成了别人主题的theme地址，直接写上theme主题名字就行了<br><img src="img3.png" alt="alt"><br>接着除了hexo-d其他命令都能运行</p><h2 id="2-spawn-failed"><a href="#2-spawn-failed" class="headerlink" title="2.spawn failed"></a>2.spawn failed</h2><p>用hexo-d更新的时候报错 <code>spawn failed</code><br>检查了自己的github ssh地址 显示：but Github does not provide shell access<br>更改myblog目录下的config.yml的repo<br><img src="img4.png" alt="图片无法加载sorry"></p><h2 id="3-not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#3-not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="3.not a git repository (or any of the parent directories): .git"></a>3.not a git repository (or any of the parent directories): .git</h2><blockquote><p>暂时不太清楚这个的报错原因，可能是当时服务器的问题，第二天登了之后就好了</p></blockquote><p><img src="img7.png" alt="图片alt"></p><h2 id="4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…"><a href="#4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…" class="headerlink" title="4.can not read a block mapping entry ;a multiline key may not be an implicit key ….."></a>4.can not read a block mapping entry ;a multiline key may not be an implicit key …..</h2><p>上传paper.md的时候报错<br><img src="img10.png" alt="图片alt"><br>因为paper.md标题中的语法不是很规范，冒号后面没有加空格，及config.yml中的语法也该如此<br>正确书写应该是tags： js<br><img src="img11.png" alt="图片alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout与setInterval</title>
      <link href="/2021/08/29/paper-1/"/>
      <url>/2021/08/29/paper-1/</url>
      
        <content type="html"><![CDATA[<h1 id="setTimeout与setInterval"><a href="#setTimeout与setInterval" class="headerlink" title="setTimeout与setInterval"></a>setTimeout与setInterval</h1><blockquote><p>有时我们并不想立即执行一个函数而是等待特定一段时间后再执行。这就是所谓的’计划调用(scheduling a call)’<br>目前有两种方法可以实现：</p></blockquote><ul><li>setTimeout：允许我们将函数推迟到一段时间间隔之后再执行</li><li>setInterval：允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数</li></ul><h1 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h1><p>语法：<code>let timerId= setTimeout(func|code,[delay],[arg1],[arg2],...)</code></p><ul><li><code>func|code</code>:想要执行的函数或代码字符串，一般传入的都是函数</li><li><code>delay</code>:执行前的延时，毫秒为单位1ms = 1s；</li><li><code>arg1,arg2...</code>:要传入被执行函数的参数列表<br>例如下面这个示例中sayHi()方法会在1s后执行：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(phrase,who){</span><br><span class="line">    alert(phrase + ',' + who);</span><br><span class="line">}</span><br><span class="line">setTimeout(sayHi,1000,'hello','neo');//hello,neo</span><br></pre></td></tr></tbody></table></figure>如果第一个参数传入的是字符串，js会自动为其创建一函数<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout('alert('hello')',1000);</span><br><span class="line">//建议使用箭头函数代替它们</span><br><span class="line">setTimeout(()=&gt; alert('hello'),1000);</span><br></pre></td></tr></tbody></table></figure></li><li>setTimeout传入的函数参数一般不需要加上括号<code>setTimeout(sayHi(),1000)//false</code>;</li><li>setTimeout期望得到一个对函数的<strong>引用</strong>，加上括号明显是在执行函数，实际上传入setTimeout的是函数的执行结果</li></ul><h2 id="clearTimeout取消调度"><a href="#clearTimeout取消调度" class="headerlink" title="clearTimeout取消调度"></a>clearTimeout取消调度</h2><p>语法：<code>let timerId = setTimeout(...); clearTimeout(timerId)</code></p><h1 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h1><ul><li>语法和setTimeout相同:<code>let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</code></li><li>参数的意义也相同，不过与setTimeout只执行一次不同，setInterval是每间隔给定的时间周期性执行。</li><li>想要阻止后续调用，我们需要调用<code>clearInerval(timerId)</code></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//每2s重复一次</span><br><span class="line">let timerId = setInterval(() =&gt; alert('t'),2000);</span><br><span class="line">//5s后停止</span><br><span class="line">setTimeout(()=&gt; {clearInterval(timerId);alert('stop');},5000);</span><br></pre></td></tr></tbody></table></figure><ul><li>在大多数浏览器中，在显示<code>alert/confirm/prompt</code>弹窗时，内部的定时器仍然会继续进行</li><li>如果在一定时间内没有关掉alert弹窗下一个alert会立即显示且两次alert的时间间隔小于2s</li></ul><h1 id="嵌套的setTimeout"><a href="#嵌套的setTimeout" class="headerlink" title="嵌套的setTimeout"></a>嵌套的setTimeout</h1><p>setInterval</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setInterval(() =&gt; alert('tick'),2000);</span><br></pre></td></tr></tbody></table></figure><p>相当于setTimeout在当前这一次函数执行完时立即调度下一次调用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let timerId = setTimeout(function tick(){</span><br><span class="line">    alert('tick');</span><br><span class="line">    timerId = setTimeout(tick,2000);</span><br><span class="line">},2000);</span><br></pre></td></tr></tbody></table></figure><ul><li>嵌套的setTimeout比setInterval灵活得多，采用这种方式可以根据当前执行结果来调度下一次调用</li><li>例如我们要实现一个每间隔5s向服务器发送一个数据请求服务器过载，要降低请求频率将间隔增加到10、20s等<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let dekay = 5000;</span><br><span class="line">let timerId = setTimeout(function request(){</span><br><span class="line">    if(request failed due to server overload){</span><br><span class="line">        delay *= 2;</span><br><span class="line">    }</span><br><span class="line">    timerId = setTimeout(request,delay);</span><br><span class="line">},delay);</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>嵌套的setTimeout能够精准地设置两次执行之间的间隔时间而setInterval却不能</strong></p><ul><li><p>setInterval</p><blockquote><p>使用setInterval时，func函数实际调用间隔要比代码中设定的时间间隔要短(&lt;100ms)</p></blockquote>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let i = 1;</span><br><span class="line">setTimeout(function run(){</span><br><span class="line">    func()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li><p>setTimeout</p><blockquote><p>嵌套的setTimeout就能保证延时的固定(100ms)</p></blockquote>  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let i = 1;</span><br><span class="line">setTimout(function run(){</span><br><span class="line">    func(i++);</span><br><span class="line">    setTimeout(run,100);</span><br><span class="line">},100)</span><br></pre></td></tr></tbody></table></figure><h2 id="垃圾回收和setInterval-setTimeout回调"><a href="#垃圾回收和setInterval-setTimeout回调" class="headerlink" title="垃圾回收和setInterval/setTimeout回调"></a>垃圾回收和setInterval/setTimeout回调</h2></li><li><p>当一个函数中传入setInterval/setTimeout时，将为其创建一个内部引用，并保存在内存中，<strong>技师证函数没有被引用，也会保存在内存中不会被销毁</strong></p></li><li><p>对于setInterval传入的函数也是一直存在于内存中直到被clearInternal被调用<br>缺点：</p></li><li><p>如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。</p></li></ul><h1 id="setTimeout-func-0"><a href="#setTimeout-func-0" class="headerlink" title="setTimeout(func, 0)"></a>setTimeout(func, 0)</h1><ul><li>这样调用可以让func尽快执行，但是只有在当前执行的脚本执行完成后，调度程序才会调用它</li><li>该函数被当前脚本执行完之后立即执行,比如下面代码会先输出hello再输出world<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(()=&gt;alert('world'));</span><br><span class="line">alert('hello')</span><br></pre></td></tr></tbody></table></figure><h2 id="零延时实际上不为0"><a href="#零延时实际上不为0" class="headerlink" title="零延时实际上不为0"></a>零延时实际上不为0</h2><blockquote><p>在<strong>浏览器环境</strong>下，嵌套定时器的运行频率是受限制的。根据html5标准所讲：经过5重嵌套定时器之后，事件间隔被强制设置为至少4ms</p></blockquote></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let start = Date.now();</span><br><span class="line">let times = [];</span><br><span class="line"></span><br><span class="line">setTimeout(function run(){</span><br><span class="line">    times.push(Date.now() - start);//保存前一个调用的延时</span><br><span class="line"></span><br><span class="line">    if(start + 100 &lt; Date.now()) alert(times);//100ms后显示延时信息</span><br><span class="line">    else setTimeout(run);//否则重新调度</span><br><span class="line">    // 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>第一次定时器是立即执行的，接下来就可以看待9,15,20,24两次调用间隔为4ms</li><li>如果我们使用setInterval也会发生类似的情况</li><li>对于服务器端的js就没有这个限制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo用法</title>
      <link href="/2021/08/29/paper/"/>
      <url>/2021/08/29/paper/</url>
      
        <content type="html"><![CDATA[<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><blockquote><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用，插入图片的常用方式，你也可以理解为在 Markdown 中插入图片。</p></blockquote><h2 id="本地绝对路径"><a href="#本地绝对路径" class="headerlink" title="本地绝对路径"></a>本地绝对路径</h2><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 Markdown 语法访问它们。<br><code>![alt](/images/test.jpg)</code></p><h2 id="本地相对路径-本博使用"><a href="#本地相对路径-本博使用" class="headerlink" title="本地相对路径 (本博使用)"></a>本地相对路径 (本博使用)</h2><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中，文章的目录可以通过配置 _config.yml 来生成。配置如下：</p><p><code>post_asset_folder: true</code></p><p>将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。</p><p><code>![alt](test.jpg)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/08/29/hello-world/"/>
      <url>/2021/08/29/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
