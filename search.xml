<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS四种遍历方法</title>
      <link href="/2021/09/12/post-name/"/>
      <url>/2021/09/12/post-name/</url>
      
        <content type="html"><![CDATA[<h1 id="JS的四种数组遍历方法：for-forEach-for-in-for…of的区别"><a href="#JS的四种数组遍历方法：for-forEach-for-in-for…of的区别" class="headerlink" title="JS的四种数组遍历方法：for/forEach()/for..in/for…of的区别"></a>JS的四种数组遍历方法：for/forEach()/for..in/for…of的区别</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;arr.length;++i)</span><br><span class="line">arr.forEach((v,i) =&gt;{})</span><br><span class="line">for(let i in arr)</span><br><span class="line">for(const i of arr)</span><br></pre></td></tr></tbody></table></figure><h2 id="语法上"><a href="#语法上" class="headerlink" title="语法上"></a>语法上</h2><p>使用for和for in，我们可以访问数组的下标，而不是元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i&lt;arr.length;++i){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用for/of,则可以直接访问数组的元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const v of arr){</span><br><span class="line">    console.log(v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用forEach()，则可以同时访问数组的下标与元素值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach((v,i)=&gt;console.log(v));</span><br></pre></td></tr></tbody></table></figure><h2 id="非数字属性"><a href="#非数字属性" class="headerlink" title="非数字属性"></a>非数字属性</h2><p>JS的数组就是Object，这意味着我们可以给数组添加字符串属性<br>4种循环语法只有<em><strong>for…in</strong></em>不会忽略数字属性：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a','b','c'];</span><br><span class="line">arr.test = 'bad';</span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i]); //打印‘a，b，bad’</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其他3种循环语法，都会忽略非数字属性</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a','b','c'];</span><br><span class="line">arr.test = 'abc';</span><br><span class="line"></span><br><span class="line">for(let i = 0;i &lt; arr.length ; ++i){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr.forEach((el,i) =&gt; console.log(i,el));</span><br><span class="line"></span><br><span class="line">for(const el of arr){</span><br><span class="line">    console.log(el)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><em><strong>提醒</strong></em>避免使用for..in来遍历数组</p><h2 id="数组的空元素"><a href="#数组的空元素" class="headerlink" title="数组的空元素"></a>数组的空元素</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = ['a',,'c'];</span><br><span class="line">arr.length;//3</span><br></pre></td></tr></tbody></table></figure><p>循环语句处理[‘a’,,’c’]与[‘a’,undefined,’c’]的方式并不相同，对于前者<br>for…in和forEach会跳过空元素，而for与for…of则不会跳过</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0;i &lt;arr.length;++i){</span><br><span class="line">    console.log(arr[i]);  //打印'a,undefined,c'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">for(const v of arr){</span><br><span class="line">    console.log(v); // 'a,undefined,c'</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">arr.forEach(v =&gt; console.log(v)); //打印'a,c'</span><br><span class="line"></span><br><span class="line">for(let i in arr){</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>for…in与forEach会跳过空元素<h2 id="remove-empty-elements"><a href="#remove-empty-elements" class="headerlink" title="remove empty elements"></a>remove empty elements</h2></li></ul><h2 id="函数的this"><a href="#函数的this" class="headerlink" title="函数的this"></a>函数的this</h2><p>for，for…in与for…of会保留外部作用域的this<br>对于forEach，如果不使用箭头函数，它的回调函数的this会发生变化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">'user strict'</span><br><span class="line">const arr = ['a'];</span><br><span class="line">arr.forEach(function(){</span><br><span class="line">console.log(this); //undefined</span><br><span class="line">})</span><br><span class="line">arr.forEach(() =&gt;{</span><br><span class="line">console.log(this);//{}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="Async-Await与Generators"><a href="#Async-Await与Generators" class="headerlink" title="Async/Await与Generators"></a>Async/Await与Generators</h2><p>不能在forEach回调函数里使用await和yield，会报错，对于for…of来说，则没有这个问题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFn(){</span><br><span class="line">    const arr = ['a','b','c'];</span><br><span class="line">    for(const el of arr){</span><br><span class="line">    await new Promise(resolve =&gt; setTimeout(resolve,1000));</span><br><span class="line">    console.log(el)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">function generatorFn(){</span><br><span class="line">    const arr = ['a','b','c'];</span><br><span class="line">    for(const el of arr){</span><br><span class="line">    yield new Promise(resolve =&gt; setTimeout(resolve,1000))</span><br><span class="line">    console.log(el)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>尽量不要在forEach中使用aysnc/await以及generators</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>for…of是遍历数组最常用的方式,它比for循环简洁，并且没有for/in和forEach()那么多奇怪的案例</li><li>for…of的缺点是我们取索引值不方便，但是如果使用for…of获取数组索引，可以这样写<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(const [i,v] of arr.entries()){</span><br><span class="line">    console.log(i,v)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo报错总结</title>
      <link href="/2021/09/12/paper-3/"/>
      <url>/2021/09/12/paper-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从零开始搭建hexo到安装theme主题这段比较顺利，到安装主题之后开始出现错误</p></blockquote><h2 id="1-Error-no-such-file-or-directory-scandir-‘…-’"><a href="#1-Error-no-such-file-or-directory-scandir-‘…-’" class="headerlink" title="1. Error:no such file or directory,scandir ‘….’"></a>1. Error:no such file or directory,scandir ‘….’</h2><p>加入主题之后运行所有hexo命令都会报如下错误<br><img src="image2.png" alt="alt"><br>排查之后，blog主题这一栏填成了别人主题的theme地址，直接写上theme主题名字就行了<br><img src="img3.png" alt="alt"><br>接着除了hexo-d其他命令都能运行</p><h2 id="2-spawn-failed"><a href="#2-spawn-failed" class="headerlink" title="2.spawn failed"></a>2.spawn failed</h2><p>用hexo-d更新的时候报错 <code>spawn failed</code><br>检查了自己的github ssh地址 显示：but Github does not provide shell access<br>更改myblog目录下的config.yml的repo<br><img src="img4.png" alt="图片无法加载sorry"></p><h2 id="3-not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#3-not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="3.not a git repository (or any of the parent directories): .git"></a>3.not a git repository (or any of the parent directories): .git</h2><blockquote><p>暂时不太清楚这个的报错原因，可能是当时服务器的问题，第二天登了之后就好了</p></blockquote><p><img src="img7.png" alt="图片alt"></p><h2 id="4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…"><a href="#4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…" class="headerlink" title="4.can not read a block mapping entry ;a multiline key may not be an implicit key ….."></a>4.can not read a block mapping entry ;a multiline key may not be an implicit key …..</h2><p>上传paper.md的时候报错<br><img src="img10.png" alt="图片alt"><br>因为paper.md标题中的语法不是很规范，冒号后面没有加空格，及config.yml中的语法也该如此<br>正确书写应该是tags： js<br><img src="img11.png" alt="图片alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型和数据结构</title>
      <link href="/2021/08/29/paper-1/"/>
      <url>/2021/08/29/paper-1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>一种遵从先进后出（LIFO）原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底</li><li>一摞叠起来的数或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要先将上面的书移走才可以</li><li>栈也被用在编程语言的编译器和内存中保存变量，方法调用<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//在js中使用类来实现一个栈</span><br><span class="line">class Stack {</span><br><span class="line"></span><br><span class="line">constructor() {</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 入栈</span><br><span class="line">push(element) {</span><br><span class="line">this.items.push(element)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 出栈</span><br><span class="line">pop() {</span><br><span class="line">return this.items.pop()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 末位</span><br><span class="line">get peek() {</span><br><span class="line">return this.items[this.items.length - 1]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 是否为空栈</span><br><span class="line">get isEmpty() {</span><br><span class="line">return !this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 尺寸</span><br><span class="line">get size() {</span><br><span class="line">return this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 清空栈</span><br><span class="line">clear() {</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 打印栈数据</span><br><span class="line">print() {</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">// 实例化一个栈</span><br><span class="line">const stack = new Stack()</span><br><span class="line">console.log(stack.isEmpty) // true</span><br><span class="line"></span><br><span class="line">// 添加元素</span><br><span class="line">stack.push(5)</span><br><span class="line">stack.push(8)</span><br><span class="line"></span><br><span class="line">// 读取属性再添加</span><br><span class="line">console.log(stack.peek) // 8</span><br><span class="line">stack.push(11)</span><br><span class="line">console.log(stack.size) // 3</span><br><span class="line">console.log(stack.isEmpty) // false</span><br></pre></td></tr></tbody></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2></li><li>与栈相反，队列是一种遵循先进先出(FIFO)原则的一组有序的项，队列在尾部添加新元素，并从头移除元素。最新添加的元素必须排在队列的末尾</li><li>在现实中，最常见的例子就是排队，前面的人优先完成自己的事务，完成之后，下一个人才能继续<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Queue {</span><br><span class="line"></span><br><span class="line">constructor(items) {</span><br><span class="line">this.items = items || []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">enqueue(element){</span><br><span class="line">this.items.push(element)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dequeue(){</span><br><span class="line">return this.items.shift()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">front(){</span><br><span class="line">return this.items[0]</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">clear(){</span><br><span class="line">this.items = []</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get size(){</span><br><span class="line">return this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get isEmpty(){</span><br><span class="line">return !this.items.length</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">print() {</span><br><span class="line">console.log(this.items.toString())</span><br><span class="line">}</span><br><span class="line">        }</span><br><span class="line">const queue = new Queue()</span><br><span class="line">console.log(queue.isEmpty) // true</span><br><span class="line"></span><br><span class="line">queue.enqueue('John')</span><br><span class="line">queue.enqueue('Jack')</span><br><span class="line">queue.enqueue('Camila')</span><br><span class="line">console.log(queue.size) // 3</span><br><span class="line">console.log(queue.isEmpty) // false</span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.print() // 'Camila'</span><br></pre></td></tr></tbody></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3></li><li>优先队列是默认队列的修改版。现实生活中的例子就是机场登机的顺序，头等舱和商务舱乘客的优先级要高于经济舱乘客</li><li>优先队列元素的添加和移除是基于优先级的</li><li>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，按照优先级移除它们<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3></li><li>为充分利用向量空间，客服假溢出现象的方法是：将向量想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列。这种循环队列可以以单链表，队列的方式来实际编程应用中来实现<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="JS的数据类型和数据结构"><a href="#JS的数据类型和数据结构" class="headerlink" title="JS的数据类型和数据结构"></a>JS的数据类型和数据结构</h2><h3 id="基本类型（栈stack）"><a href="#基本类型（栈stack）" class="headerlink" title="基本类型（栈stack）"></a>基本类型（栈stack）</h3><pre><code>Number，String，Boolean，Null，Undefind，Symbol，null（不可用typeof检测）</code></pre><h3 id="引用数据类型（堆head）"><a href="#引用数据类型（堆head）" class="headerlink" title="引用数据类型（堆head）"></a>引用数据类型（堆head）</h3><pre><code>堆：堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定Object（包括Array，Function，Data）   </code></pre><h3 id="每个数据都需要一个内存空间"><a href="#每个数据都需要一个内存空间" class="headerlink" title="每个数据都需要一个内存空间"></a>每个数据都需要一个内存空间</h3><table><thead><tr><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>可直接操作保存在栈内存空间的值</td><td>不允许直接访问，不能直接操作</td></tr><tr><td>变量名，值       —&gt;引用</td><td>值</td></tr><tr><td>c，0X0012</td><td>[1,2,3]</td></tr></tbody></table><h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo用法</title>
      <link href="/2021/08/29/paper/"/>
      <url>/2021/08/29/paper/</url>
      
        <content type="html"><![CDATA[<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><blockquote><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用，插入图片的常用方式，你也可以理解为在 Markdown 中插入图片。</p></blockquote><h2 id="本地绝对路径"><a href="#本地绝对路径" class="headerlink" title="本地绝对路径"></a>本地绝对路径</h2><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 Markdown 语法访问它们。<br><code>![alt](/images/test.jpg)</code></p><h2 id="本地相对路径-本博使用"><a href="#本地相对路径-本博使用" class="headerlink" title="本地相对路径 (本博使用)"></a>本地相对路径 (本博使用)</h2><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中，文章的目录可以通过配置 _config.yml 来生成。配置如下：</p><p><code>post_asset_folder: true</code></p><p>将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。</p><p><code>![alt](test.jpg)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/08/29/hello-world/"/>
      <url>/2021/08/29/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
