<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>review box</title>
      <link href="/2021/12/07/eng/"/>
      <url>/2021/12/07/eng/</url>
      
        <content type="html"><![CDATA[<h1 id="word-phrase"><a href="#word-phrase" class="headerlink" title="word/phrase"></a>word/phrase</h1><h2 id="December-2021"><a href="#December-2021" class="headerlink" title="December 2021"></a>December 2021</h2><ul><li><p><strong>word</strong></p><ul><li><em>exploring</em>.[n &amp; adj]</li><li><em>variable</em>.[n &amp; adj] ： variable notion of moon</li><li><em>incentive</em>.[n &amp; adj] ：this holiday incentive is no longer necessary</li><li><em>postgraduate</em>.[n &amp; adj] ：Pursue postgraduate studies </li><li><em>colonial</em>.[n &amp; adj] ：Destroy their colonies close by</li><li><em>deputy</em>.[n &amp; adj]</li><li><em>liquid</em>.[n &amp; adj]</li><li><em>intimate</em>.[n &amp; adj]</li><li><em>exterior</em>.[n &amp; adj]</li><li><em>treasure</em>.[n &amp; vt] ： treasure trove</li><li><em>sponsor</em>.[n &amp; vt]</li><li><em>structure</em>.[n &amp; vt]</li><li><em>witness</em>.[n &amp; vt]</li><li><em>dive</em>.[n &amp; vi]</li><li><em>rebel</em>.[n &amp; vi]</li><li><em>conducted</em>.[n &amp; v]</li><li><em>gather</em>.[vt &amp; vi]</li><li><em>resist</em>.[vt &amp; vi] : people can’t resist the temptation of them</li><li><em>enquire</em>.[vt &amp; vi]</li><li><em>calculate</em>.[vt &amp; vi]</li><li><em>conceive</em>.[vt &amp; vi]</li><li><em>strengthen</em>.[vt &amp; vi] ：Strengthening people’s immunity to <strong>infection</strong></li><li><em>migrate</em>.[vt &amp; vi]</li><li><em>transmit</em>.[vt &amp; vi]</li><li><em>explore</em>.[vt &amp; vi]</li><li><em>negotiate</em>.[vt &amp; vi]</li><li><em>revolve</em>.[vt &amp; vi]</li><li><em>speculate</em>.[vt &amp; vi]</li><li><em>miserable</em>.[adj]</li><li><em>intolerable</em>.[adj] : life become intolerable</li><li><em>credible</em>.[adj]</li><li><em>flourishing</em>.[adj] ：that it developed in this incredible flourishing of this sophisticated technology</li><li><em>sophisticated</em>.[adj]</li><li><em>divers</em>.[adj]</li><li><em>outstanding</em>.[adj]</li><li><em>significant</em>.[adj]</li><li><em>authentic</em>.[adj]</li><li><em>fruitful</em>.[adj]</li><li><em>contented</em>.[adj]</li><li><em>adequate</em>.[adj]</li><li><em>urgent</em>.[adj]</li><li><em>seal</em>.[adj]</li><li><em>instant</em>.[adj]</li><li><em>refined</em>.[adj]</li><li><em>brutal</em>.[adj]</li><li><em>slim</em>.[adj]</li><li><em>modified</em>.[adj &amp; v]</li><li><em>stripped</em>.[adj &amp; v]</li><li><em>constantly</em>.[adv]</li><li><em>extraordinarily</em>.[adv]</li><li><em>modestly</em>.[adv]</li><li><em>ethically</em>.[adv]</li><li><em>literally</em>.[adv]</li><li><em>deliberately</em>.[adv]</li><li><em>backward</em>.[adj &amp; adv]</li><li><em>astonishing</em>.[adj &amp; adv]</li><li><em>restrictive</em>.[adj &amp; adv &amp; n]</li><li><em>further</em>.[adj &amp; adv &amp; vt] ： Further reducing old patients’medical expenses</li><li><em>reveal</em>.[vt]</li><li><em>eliminate</em>.[vt]</li><li><em>put off</em>.[vt]</li><li><em>represent</em>.[vt]</li><li><em>thrive</em>.[vi]</li><li><em>evaluate</em>.[vi]</li><li><em>underestimate</em>.[vt &amp; n]：I guess you underestimated how difficult it would be the first time，didn’t you？</li><li><em>digest</em>.[vt &amp; vi &amp; n]</li><li><em>format</em>.[vt &amp; vi &amp; n] ： test format</li><li><em>breed</em>.[vt &amp; vi &amp; n] : It’s breeding ground are now better <strong>preserved</strong></li><li><em>load</em>.[vt &amp; vi &amp; n]</li><li><em>stack</em>.[vt &amp; vi &amp; n]</li><li><em>track</em>.[vt &amp; vi &amp; n]</li><li><em>fragment</em>.[vt &amp; vi &amp; n]</li><li><em>contrast</em>.[vt &amp; vi &amp; n]</li><li><em>knot</em>.[vt &amp; vi &amp; n]</li><li><em>trace</em>.[vt &amp; vi &amp; n]</li><li><em>gain</em>.[vt &amp; vi &amp; n]</li><li><em>ladder</em>.[vt &amp; vi &amp; n]</li><li><em>survey</em>.[vt &amp; vi &amp; n]</li><li><em>tracked</em>.[adj &amp; v]</li><li><em>relieved</em>.[adj &amp; v]</li><li><em>correct</em>.[adj &amp; vt &amp; vi]</li><li><em>humble</em>.[adj &amp; vt]</li><li><em>properly</em>.[adv]</li><li><em>petrol</em>.[n]</li><li><em>relief</em>.[n] ：It’s such a relief to pass</li><li><em>maintenance</em>.[n]</li><li><em>authority</em>.[n]</li><li><em>corner</em>.[n]</li><li><em>breakthrough</em>.[n] ：make a breakthrough technology </li><li><em>prediction</em>.[n] weather prediction</li><li><em>precision</em>.[n] precision machining</li><li><em>registration</em>.[n] ： marriage registration office</li><li><em>procedure</em>.[n]</li><li><em>tuition</em>.[n]</li><li><em>chess</em>.[n] : national chess</li><li><em>dominance</em>.[n]</li><li><em>nostalgia</em>.[n]</li><li><em>legislation</em>.[n] ：Michigan lawmakers have introduced legislation that could make their state the best place in the country</li><li><em>interaction</em>.[n] </li><li><em>outcome</em>.[n]</li><li><em>substance</em>.[n] </li><li><em>submission</em>.[n] </li><li><em>adaptation</em>.[n]</li><li><em>habitat</em>.[n]</li><li><em>principle</em>.[n] ： In principle</li><li><em>summit</em>.[n]</li><li><em>volumes</em>.[vt &amp; vi &amp; n &amp; adj] : companies keep <strong>large volumes of</strong> records</li><li><em>fleet</em>.[vt &amp; vi &amp; n &amp; adj] ： even set on-demand fleets of self-driving cars</li></ul></li><li><p><strong>phrase</strong></p><ul><li><em>spending time doing sth</em></li><li><em>valueless work <strong>could be + adj/Ved</strong></em></li><li><em>attempt to do</em>  : They abandoned the attempt to roast coffee beans in space.</li><li><em>addiction to</em></li><li><em>ranging from</em></li><li><em>check up on</em>  :  checking up on you all the time</li><li><em>dispose of</em>  :  Dispose of their trash properly</li><li><em>to some extent</em></li><li><em>broaden one’s horizon</em></li><li><em>split into</em></li><li><em>until this point</em> ：previous experts had been able to model the back of the mechanism up until this point</li><li><em>donzens of</em></li><li><em>rushing to</em> ： So people who are rushing to register for marriage can relax</li><li><em>struggling to</em> : His students were struggling to follow his lessons</li><li><em>in a bid to</em> </li><li><em>separate into/divide into</em> </li><li><em>look back on sth</em>  : look back on their good old days</li><li><em>present with</em> ： they presented the elderly with fresh fruits before diving themselves into two groups</li><li><em>pure water</em> </li></ul></li></ul><h1 id="Theme-n"><a href="#Theme-n" class="headerlink" title="Theme(n)"></a>Theme(n)</h1><h2 id="科技-未来-Technology"><a href="#科技-未来-Technology" class="headerlink" title="科技/未来(Technology)"></a>科技/未来(Technology)</h2><ul><li><em>solar panel</em></li><li><em>Auto-pilot</em></li><li><em>x-ray</em></li><li><em>automobile innovation</em></li></ul><h2 id="自然-环境"><a href="#自然-环境" class="headerlink" title="自然/环境"></a>自然/环境</h2><ul><li><em>Commercial hunting</em></li><li><em>Decreasing birthrates</em></li></ul><h2 id="文化-社会"><a href="#文化-社会" class="headerlink" title="文化/社会"></a>文化/社会</h2><ul><li><em>sharing economy</em></li><li><em>immediate effect</em></li><li><em>annual leave bonus</em></li><li><em>senior center</em></li><li><em>Hope elementary school</em> || <em>junior high school</em> || <em>senior high school</em></li></ul><h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><h2 id="sentence"><a href="#sentence" class="headerlink" title="sentence"></a>sentence</h2><ul><li><em>The benefits of … are innumerable and mainfold</em></li><li><em>As is known to all</em></li><li><em>Technology has <strong>penetrated into</strong> every corner of modem society</em></li><li><em>This is a massive step forward in the history of technology and science</em></li><li><em>something we take for granted now</em></li><li><em>It is completely astonishing that sb firstly …secondly…</em> || It is completely astonishing that the ancient Greeks Firstly had the conception of making this technology and secondly the ability to actually physically make it</li><li> <em>out of that data has come nearly all the breakthroughs in recent decades ， came the discovery that it predicted eclipses ，that it followed the variable notion of the moon</em></li><li><em>The history of technological development doesn’t go in a straight line</em></li><li><em>in the meanwhile</em></li><li><em>Pursue your true passion don’t compromise</em></li><li><em>for starters，moverover/in addition/in the next place，last but not least</em></li><li>never can people ignore the indispensability of the wealth of mind to themselves</li><li>without the aforementioned belief</li></ul><h2 id="vocabulary-replacement"><a href="#vocabulary-replacement" class="headerlink" title="vocabulary replacement"></a>vocabulary replacement</h2><ul><li>V<ul><li>explain -&gt; Shed light on</li><li>get -&gt; acquire</li><li>reduce -&gt; lighten</li><li>show -&gt; mirror</li><li>believe -&gt; admit</li><li>cause -&gt; trigger / contribute to</li><li>replace -&gt; substitute </li><li>develop -&gt; cultivate</li><li>improve -&gt; enhance</li><li>impede -&gt; hinder || hinder the development of… one’s progress iin</li><li>stop -&gt; cease || ceaseless efforts</li><li>encourage -&gt; motivate/inspire</li><li>finish -&gt; fulfill || fulfill your dream/ambition/potential</li><li>support -&gt; be in favor of</li><li>object to -&gt; oppose + sth/doing sth</li><li>give -&gt; offer/provide || offer sb sth/offersth to sb  | provide sb with sth/provide sth for sb</li><li>develop -&gt; cultivate</li><li>-&gt;</li><li>-&gt;</li></ul></li><li>adj<ul><li>good -&gt; outstanding/advantageous</li><li>bad -&gt; undesirable</li><li>difficult -&gt; demanding</li><li>important -&gt; crucial/significant</li><li>common -&gt; universal || The desire to look attractive is universal</li><li>big -&gt; considerable/tremendous</li><li>most -&gt; the vast majority of</li><li>popular -&gt; well-regarded</li><li>only -&gt; unique</li><li>poor -&gt; needy</li><li>rich -&gt; wealthy/prosperous || prosperous parents = rich and successful</li><li>interesting -&gt; engaging</li><li>boring -&gt; tedious</li><li>helpful -&gt; rewarding/beneficial</li></ul></li><li>adv<ul><li>very -&gt; extremely </li><li>so -&gt; hence </li><li>moreover -&gt; in the meanwhile </li><li>nowadays -&gt; current society</li><li>clearly -&gt; obviously/apparently</li></ul></li><li>n<ul><li>side -&gt; respect</li><li>lack -&gt; shortage</li><li>opinion -&gt; viewpoint</li><li>influence -&gt; effect + on || That will have a salutary effect on their behavior</li><li>-&gt;</li><li>-&gt;</li><li>-&gt;</li><li>-&gt;</li></ul></li><li>other<ul><li>about -&gt; with respect to</li><li>because of -&gt; due to</li><li>a series of -&gt; a range of</li><li>a lot -&gt; a great deal || the wealth of the mind contributes a great deal to the society</li><li>all kind of -&gt; a wide range of</li><li>more and more -&gt; enjoy an increasing popularity</li><li>I think -&gt; as far as I concerned/form my perspective</li><li>more and more -&gt; the number of …increases exponentially</li><li>with the development of -&gt; due to the proliferation of …</li><li>try one’s best -&gt; aspire to do</li><li>want sth -&gt; have a strong desire for sth</li><li>sb be interested in sth -&gt; sth generate interest</li><li>in conclusion -&gt; in brief</li><li>there is no doubt that… -&gt; there is no denying that…</li><li>It’s kown to all that -&gt; As is known to all</li><li>consider…as… -&gt; regard…as..</li><li>take care of sb -&gt; attend to sb</li><li>-&gt;</li><li>-&gt;</li><li>-&gt;</li></ul></li></ul><p>参考文献</p><a href="https://dict.eudic.net/webting/videoplay/b6ce89f9-565f-11ec-8804-00505686c5e6" title="default The ancient ‘computer’ that simply shouldn't exist - BBC REEL" target="">The ancient mystery of the world's oldest computer</a>]]></content>
      
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据劫持</title>
      <link href="/2021/12/06/Data-hijacking/"/>
      <url>/2021/12/06/Data-hijacking/</url>
      
        <content type="html"><![CDATA[<ul><li>思考:实现以下条件成立可行的方法<pre><code>var a = ? //a要如何赋值，才能使下面的if语句成立if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){  console.log(1)}</code></pre></li></ul><ol><li>==进行比较，两边数据类型不同时，有不一样的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality" title="default 转换规则" target="">转换规则</a><blockquote><p>如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。</p></blockquote></li><li>当然我们会想到使用toString方法，并且把a赋值为一个对象，但a只有在它的原型链上能够寻找到toSting方法，它本身是没有toString方法的，所以我们可以手动地给它定义一个toString方法<pre><code>var a = {    toString(){    }}</code></pre></li><li>okay，现在我们可以着手来实现它了,值得注意的一点是：是<code>a.toString()</code>的返回值跟a==1进行比较<pre><code>var a = {    i : 0,    toString(){        return ++this.i; //++i运算后返回     }}if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){console.log('条件成立')}</code></pre><blockquote><p>当然除了上述办法还有其他方法比如：把上述toSting方法改成valueOf，或者<code>var a = [1,2,3]</code> <code>a.toString = a.shift</code>shift方法(删除第一项并返回首位)赋值给toString等等，就不再一一赘述<br>最值得关注的还是：使用<strong>数据劫持</strong>的方法来实现这道奇怪的问题</p></blockquote></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="default Object.defineProperty()" target="">Object.defineProperty()</a></h1><blockquote><p>当我们获取一个值的时候希望它做些什么事情，当这种情况出现我们可以使用数据劫持(defineProperty/Proxy)，<code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p></blockquote><ul><li>defineProperty：会监听一个属性值</li><li>get():获取属性值</li><li>set()：设置属性值<br>来看一下如何使用数据劫持实现第一道例题<pre><code>var i = 0;Object.defineProperty(window,'a',{  get() {      return ++i;  }});if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){  console.log('条件成立')  }</code></pre></li><li>首先，我们先监听了window对象下的a属性，并且获取到了a的属性值i，i做的事情就是自增1</li><li>你可能会问，为什么return的是i而不是a，这是因为如果return的是a会触发GETTER拦截器从而导致形成死循环栈内存溢出</li></ul><h2 id="Object-defineProperty-实际应用"><a href="#Object-defineProperty-实际应用" class="headerlink" title="Object.defineProperty()实际应用"></a>Object.defineProperty()实际应用</h2><blockquote><p>在vue2.0中我们就使用到了<code>Object.defineProperty()</code>方法来实现双向数据绑定的原理，以便我们来实现MVVM，下面先写一个简单的实现源码</p></blockquote><pre><code>&lt;body&gt;    姓名：&lt;span id = "spanName"&gt;&lt;/span&gt;    &lt;br&gt;    &lt;input type = "text" id = "inpName"&gt;    &lt;script&gt;        let obj = {        name:''    };    let newObj = JSON.parse(JSON.stringify(obj));//深拷贝对象    Object.defineProperty(obj,'name',{            get() {                return newObj.name;            },            set(val) {                if(val === newObj.name) return;                newObj.name = val;                observer();            }    })    function observer(){            //数据更改影响视图            spanName.innerHTML = obj.name;            inpName.value = obj.name;    }    setTimeout(() =&gt; {            obj.name = "修改了数据"    },1000)    inpName.oninput = function() {            //视图更改影响数据；v-model的操作              obj.name = this.value;    }    &lt;/script&gt;&lt;/body&gt;</code></pre><ul><li>get()获取到newObj.name的属性值，设置获得的属性值到set(val)里,每次设置完执行observer()</li><li>当在setTimeout里修改了obj.name的数据时，会触发set()拿到最新值赋值给val，再执行observer，拿到最新的值更新视图</li><li>oninput是改变的事件，当视图改变的时候把当前视图的值赋给name属性，再触发set属性如上</li></ul><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" title="default Proxy" target="">Proxy</a></h1><blockquote><p>从性能上来说<code>Object.defineProperty()</code>会有一些缺点：<br>1.它需要对原始数据进行克隆。2. 需要分别给对象中的每一个属性设置监听。<br>所以我们拥有了一个更优解<strong>Proxy</strong>，可以完美解决 <code>Object.defineProperty()</code>带来的缺点<br>Proxy用于vue3.0的双向数据绑定</p></blockquote><ul><li>Proxy监听的是整个对象，不需要单独监听一个属性</li><li>prop是当前对象的属性值<pre><code>  let obj = {};  obj = new Proxy(obj,{      get(target,prop) {          return target[prop]      },      set(target,prop,value) {          target[prop] = value;          observer();      }  })</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS的深浅克隆及数组扁平化</title>
      <link href="/2021/12/03/deepClone/"/>
      <url>/2021/12/03/deepClone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浅克隆：只克隆多维数组的第一层，当改变对象的某个属性时另一个对象的对应属性也会发生改变，因为没有克隆它的引用地址，所以它们本质上指向的还是同一个引用地址<br>深克隆：开辟新的堆内存存储数据，两者指向不同的引用地址，修改对象的属性对克隆后的对象没有影响。</p></blockquote><h1 id="一、JSON-stringify-方法实现深克隆"><a href="#一、JSON-stringify-方法实现深克隆" class="headerlink" title="一、JSON.stringify()方法实现深克隆"></a>一、JSON.stringify()方法实现深克隆</h1><ul><li>先把一个对象变为字符串<br>  <code>JSON.Stringify(obj)</code>但是这个方法会把正则、日期都变为空对象</li><li>再把字符串变为对象<br>  <code>JSON.Parse()</code></li></ul><h1 id="二、实现轻量lodash深克隆"><a href="#二、实现轻量lodash深克隆" class="headerlink" title="二、实现轻量lodash深克隆"></a>二、实现轻量lodash深克隆</h1><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>先看看如何实现浅克隆，在浅克隆的基础上实现深克隆，思路如下</p><ul><li>我们只遍历它的私有属性<code>obj.hasOwnProperty(key)</code>(不会上升到原型链)</li><li>私有属性<code>obj[key]</code>赋值给<code>obj2[key]</code></li></ul><pre><code>let obj = {    a:100,    b:[10,20,30],    c:{        x:10    },    d:/^\d+$/};let arr = [10,[100,200],{    x:10,    y:20}]let obj2 = {}for(let key in obj){    if(!obj.hasOwnProperty(key)) break;    obj2[key] = obj[key];}console.log(obj,obj2)</code></pre><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><ul><li>创建一个空对象(new) <code>new obj.constructor</code>(即创建了一个对象，又克隆了它的实例，目的是克隆的结果和之前保持相同的所属类)</li><li>过滤特殊情况(obj进入for in循环前)<ul><li>分情况判断:<code>obj=null</code></li><li>obj=正则</li><li>obj=Data的情况</li></ul></li></ul><pre><code>function deepClone(obj){    if(obj === null) return null;    if(typeof obj !== "object") return obj;    if(obj instanceof RegExp){        return new RegExp(obj);    }    if(obj instanceof Date){        return new Date(obj)    }    let newObj = new obj.constructor;    for(let key in obj){        if(obj.hasOwnProperty(key)){            newObj[key] = deepClon(obj[key])        }    }}</code></pre><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><blockquote><p>数组</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/2021/11/24/Garbage-collection/"/>
      <url>/2021/11/24/Garbage-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>《JavaScript高级程序设计》提到两种垃圾回收机制</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中最常用的垃圾收集方式是标记清除( mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量〉时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进人环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。<br>这种方法引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</p><pre><code>function fun() {    let obj1 = {};    let obj2 = {};    obj1.a = obj2; // obj1 引用 obj2    obj2.a = obj1; // obj2 引用 obj1}</code></pre><p>这种情况下，就要手动释放变量占用的内存：</p><pre><code>obj1.a =  nullobj2.a =  null</code></pre><h2 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h2><ul><li>意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop</title>
      <link href="/2021/11/24/Event-Loop/"/>
      <url>/2021/11/24/Event-Loop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浏览器是多线程浏览器，js是单线程，浏览器只给了js一个线程来渲染</p></blockquote><ul><li><p>先看一些例子</p><pre><code>async function async1() {  console.log('async1 start');  await async2();  console.log('async1 end')}async function async2() {  console.log('async2')}console.log('script start');setTimeout(function (){  console.log('setTimeout')},0)async1();new Promise(function (resolve){  console.log('Promise1');  resolve();}).then(function() {  console.log('promise2')});console.log('script end')</code></pre><p>以上代码知识点</p><ul><li>进栈=执行（压缩到栈里是执行，执行完之后销毁的移除栈内存，不销毁的移除到栈底）</li><li>主栈是第一个执行，之后执行Event Quque事件队列，事件队列包括宏任务和微任务，微任务先执行，宏任务后执行</li><li>主栈查找事件队列，事件队列执行主栈的过程叫Even Loop</li><li>new Promise时，会立即执行EC函数，new的时候是同步的，但是执行resolve()/reject()时时异步的，当它们执行时会执行then()/catch()中的方法</li><li>所以js栈的执行顺序为 主栈-&gt;微任务队列 -&gt;宏任务队列<blockquote><p>但是微任务队列里函数的执行顺序可就不一定了，在chrome浏览器中是按照顺序执行的</p></blockquote></li><li>微任务的函数有：Promise、async、await</li><li>宏任务的函数有：定时器、事件绑定、ajax</li></ul><p><img src="/2021/11/24/Event-Loop/1.jpg" alt="alt"></p></li></ul><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><ul><li>在JavaScript运行时，实际上维护了一组用于执行 JavaScript 代码的代理。每个代理由一组执行上下文的集合、执行上下文栈、主线程、一组可能创建用于执行 worker 的额外的线程集合、一个任务队列以及一个微任务队列构成。除了主线程（某些浏览器在多个代理之间共享的主线程）之外，其它组成部分对该代理都是唯一的。</li><li>每个代理都是由事件循环驱动的，事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</li><li>一个任务就是指计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。 除了使用事件，你还可以使用 setTimeout() 或者 setInterval() 来添加任务</li><li>在 JavaScript 中，任务被分为两种，一种宏任务（MacroTask）也叫 Task，一种叫微任务（MicroTask）。</li></ul><h2 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h2><p>script 全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN）、I/O、UI Rendering。</p><h2 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h2><p>Process.nextTick（Node 独有）、Promise、Object.observe(废弃)、MutationObserver</p><h2 id="宏任务vs微任务"><a href="#宏任务vs微任务" class="headerlink" title="宏任务vs微任务"></a>宏任务vs微任务</h2><p>任务队列和微任务队列的区别</p><ul><li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行.</li><li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li></ul><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。<br>事件循环中的异步队列有两种：宏任务队列可以有多个，微任务队列只有一个。</p><p>一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。<br>node 中的事件循环的顺序</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调<blockquote><p>总结：浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。</p></blockquote></li></ul><pre><code>setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function () {    console.log('promise1')  })}, 0)setTimeout(() =&gt; {  console.log('timer2')  Promise.resolve().then(function () {    console.log('promise2')  })}, 0)</code></pre><p>浏览器端运行结果：timer1=&gt;promise1=&gt;timer2=&gt;promise2<br>Node 端运行结果：timer1=&gt;timer2=&gt;promise1=&gt;promise2<br>微任务和宏任务的区别<br>宏任务：DOM 渲染后触发， 如 setTimeout; 是由浏览器规定的<br>微任务：DOM 渲染前触发，如 Promise；是 ES6 规定的</p>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>element-ui</title>
      <link href="/2021/11/07/element-ui/"/>
      <url>/2021/11/07/element-ui/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><blockquote><p>slot：调取组件时，给组件传一些额外的值<code>&lt;template slot-scope="scope"&gt; &lt;/template&gt;</code>:element-ui作用域插槽，定义在通过Scoped slot可以获取到row，column，$index和store(table内部的状态管理)的数据，scope是table内部基于onlyTableData生成出来的(一个类似于excel的表格数据)，我们可以通过scope.row获取当前行的数据</p></blockquote><ul><li>通过scope.$index可以直接取到该单元格值</li><li>scope.row直接取到该单元格对象,即:onlyTableData[scope.$index]</li></ul><pre><code> &lt;!-- 静态属性表格 --&gt;          &lt;el-table :data="onlyTableData" border stripe&gt;            &lt;!-- 展开行 --&gt;            &lt;el-table-column type="expand"&gt;              &lt;template slot-scope="scope"&gt;                &lt;!-- 循环渲染Tag标签 --&gt;                &lt;el-tag v-for="(item, i) in scope.row.attr_vals" :key="i" closable                             @close="handleClose(i, scope.row)"&gt;{{item}}&lt;/el-tag&gt;                &lt;!-- 输入的文本框 --&gt;                &lt;el-input class="input-new-tag"                          v-if="scope.row.inputVisible"                          v-model="scope.row.inputValue"&gt;                &lt;/el-input&gt;                &lt;!-- 添加按钮 --&gt;                &lt;el-button v-else class="button-new-tag" size="small" @click="showInput(scope.row)"&gt;+ New Tag&lt;/el-button&gt;              &lt;/template&gt;            &lt;/el-table-column&gt;          &lt;/el-table&gt;</code></pre><ul><li>table表格中：data = “onlyTableData”为源数据，数据结构如下</li></ul><pre><code>onlyTableData :[    {        attr_id: 3068        attr_name: "主体商品"        attr_sel: "only"        attr_vals: [                     "三室"                     "这是个电视"                     "电视机"]    },    {                attr_id: 3070        attr_name: "系统-智能电视"        attr_sel: "only"        attr_vals:        ["智能电视,透明电视"]    },    {        attr_id: 3071        attr_name: "外观-壁挂安装"        attr_sel: "only"        attr_vals: ["支持,挂壁,挂壁"]    }]</code></pre><ul><li>为数据调用函数时，| 调用</li></ul><pre><code>&lt;el-table-column label="创建时间" prop="add_time" width="140px"&gt;            &lt;template slot-scope="scope"&gt;              {{scope.row.add_time | dataFormate}}            &lt;/template&gt;          &lt;/el-table-column&gt;</code></pre><pre><code>//main.js目录下的全局过滤时间函数Vue.filter('dataFormate',function (originVal){  const dt = new Date(originVal)  const y = dt.getFullYear()  const m =( dt.getMonth()+1+'').padStart(2,'0') //padStart(2,'0'):不足两位补字符串0  const d = (dt.getDate()+'').padStart(2,'0')  const hh = (dt.getHours() + '').padStart(2,'0')  const mm = (dt.getMinutes() + '').padStart(2,'0')  const ss = (dt.getSeconds() + '').padStart(2,'0')  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`})</code></pre><h2 id="作用域插槽解耦数据"><a href="#作用域插槽解耦数据" class="headerlink" title="作用域插槽解耦数据"></a>作用域插槽解耦数据</h2><p>项目中遇到：input会共享数据，当改变一个文本框的值时，其他的文本框的值也会随之改变，可用通过作用域插槽对这两个数据进行解耦，实现数据单独控制对应值，在getParamData里控制文本框的显示与隐藏，在v-if里定义作用域插槽实现单个数据上传</p><pre><code>  &lt;el-table-column type="expand"&gt;  &lt;template slot-scope="scope"&gt;    &lt;!-- + New Tag的文本框 --&gt;    &lt;el-input class="input-new-tag"               v-if="scope.row.inputVisible"               v-model="scope.row.inputValue"            @blur="handleInputConfirm(scope.row)"&gt;    &lt;/el-input&gt;    &lt;!-- 添加按钮 --&gt;    &lt;el-button v-else class="button-new-tag" size="small" @click="showInput(scope.row)"&gt;+ New Tag&lt;/el-button&gt;  &lt;/template&gt;&lt;/el-table-column&gt;showInput(row) {  row.inputVisible = true},</code></pre><p><img src="/2021/11/07/element-ui/tagData.gif" alt="alt"></p><h1 id="级联选择器"><a href="#级联选择器" class="headerlink" title="级联选择器"></a>级联选择器</h1><p>el-cascader</p>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2021/11/03/gitInstruct/"/>
      <url>/2021/11/03/gitInstruct/</url>
      
        <content type="html"><![CDATA[<h1 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h1><p><code>git checkout</code>（切换分支） -b xx 创建新分支xx</p><p><code>git branch</code>：查看当前分支</p><p><code>git status</code> ：检查当前分支的文件状态</p><p><code>git add .</code>：添加到暂存区</p><p><code>git push -u origin xx</code> 第一次推送新分支xx（当github仓库没有xx分支时，要加上-u）</p><h1 id="合并分支（合并xx到主分支）"><a href="#合并分支（合并xx到主分支）" class="headerlink" title="合并分支（合并xx到主分支）"></a>合并分支（合并xx到主分支）</h1><p><code>git checkout main</code></p><p><code>git merge xx</code></p><p><code>git push</code> 推送到云端</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2021/11/03/lifeVue/"/>
      <url>/2021/11/03/lifeVue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h1><blockquote><p>Vue生命周期的过程指在vue中实例创建到销毁的过程，即从创建，初始化数据，编译模板，挂载Dom-&gt;渲染，更新-&gt;渲染，卸载等一系列过程，我们可以把组件比喻成流水线，工人是生命周期，当任务流转到工人身边的时候，工人就开始工作，在Vue生命周期钩子会自动绑定this上下文到实例中，因此你可以访问数据，对prototype方法进行运算，这说明你<strong>不能使用箭头函数</strong>定义生命周期方法</p></blockquote><h1 id="生命周期的阶段"><a href="#生命周期的阶段" class="headerlink" title="生命周期的阶段"></a>生命周期的阶段</h1><blockquote><p>vue生命周期总共可以分为8个阶段，创建前后，载入前后，更新前后，销毁前后，以及一些特殊场景上的生命周期</p></blockquote><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初</td></tr><tr><td>created</td><td>组件实例已经完全创建</td></tr><tr><td>beforeMount</td><td>组件挂载之前</td></tr><tr><td>mounted</td><td>组件挂载到实例上之后</td></tr><tr><td>beforeUpdate</td><td>组件数据发生变化，更新之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>beforeDestroy</td><td>组件实例销毁之前</td></tr><tr><td>destoryed</td><td>组件实例销毁之后</td></tr><tr><td>activated</td><td>kee-alive缓存的组件激活时</td></tr><tr><td>deactivated</td><td>keep-alive缓存的组件激活时</td></tr><tr><td>errorCaptured</td><td>捕获一个来自子孙组建的错误时被调用</td></tr></tbody></table><h1 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h1><p><img src="/2021/11/03/lifeVue/lifecycle.png" alt="alt"></p><h2 id="beforeCreate-gt-created"><a href="#beforeCreate-gt-created" class="headerlink" title="beforeCreate -> created"></a>beforeCreate -&gt; created</h2><ul><li>初始化vue实例，进行数据观测</li></ul><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><ul><li>完成数据观测，属性与方法的运算，watch，event事件毁掉的配置</li><li>可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算</li><li>此时vm.el并没有被创建<blockquote><p>在实例挂载之后，元素可以用 vm.$el 访问。</p></blockquote></li></ul><h2 id="created-gt-beforeMount"><a href="#created-gt-beforeMount" class="headerlink" title="created -> beforeMount"></a>created -&gt; beforeMount</h2><ul><li>判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译</li><li>优先级：render &gt; template &gt; outerHTML</li><li>vm.el获取到的是挂载DOM的</li></ul><h2 id="beforeMount-gt-mounted"><a href="#beforeMount-gt-mounted" class="headerlink" title="beforeMount -> mounted"></a>beforeMount -&gt; mounted</h2><ul><li>在此阶段可以获取到vm.el</li><li>此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上</li></ul><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><ul><li>vm.el已完成DOM的挂载与渲染，刺客打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM</li></ul><h2 id="beforeUpdata"><a href="#beforeUpdata" class="headerlink" title="beforeUpdata"></a>beforeUpdata</h2><ul><li>更新的数据必须是被渲染在模板上的(el、template、rander之一)</li><li>此时view层还未更新</li><li>若在beforeUpdate中再次修改数据，不会再次触发更新方法</li></ul><h2 id="updata"><a href="#updata" class="headerlink" title="updata"></a>updata</h2><ul><li>完成值view视图的更新</li><li>若在updated中再次修改数据，会再次触发更新方法(beforeUpdate、updated)</li></ul><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><ul><li>实例被销毁前调用，此时实例属性与方法仍可访问</li></ul><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><ul><li>完全销毁一个实例，可清理它与其他实例的链接，解绑它的全部指令及事件监听器</li><li>并不能清除DOM仅仅销毁实例</li></ul><h1 id="数据请求在created和mounted的区别"><a href="#数据请求在created和mounted的区别" class="headerlink" title="数据请求在created和mounted的区别"></a>数据请求在created和mounted的区别</h1><ul><li>created是在组件实例一旦创建完成时立即调用，这时候页面dom节点并未生成</li><li>mounted是在页面dom节点渲染完毕之后就立即执行的触发时机上，created势必mounted更早</li><li>两者的相同点：都能拿到实例对象的属性和方法，两者最大的不同就是触发时机的不同</li><li>数据请求放在mounted可能导致页面闪动(页面dom结构已经生成)，但如果在页面加载完成则不会出现此情况</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await-Promise</title>
      <link href="/2021/10/28/async-await-Promise/"/>
      <url>/2021/10/28/async-await-Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise概念"><a href="#Promise概念" class="headerlink" title="Promise概念"></a>Promise概念</h2><p>在开发过程中我们会遇到这样的问题</p><pre><code>let fs = require('fs')fs.readFile('./a.txt','utf8',function(err,data){  fs.readFile(data,'utf8',function(err,data){    fs.readFile(data,'utf8',function(err,data){      console.log(data)    })  })})</code></pre><p>以上代码的缺点有：</p><ul><li>后一个请求需要依赖于前一个请求成功后才将数据往下传递，会导致多个ajax请求嵌套的情况代码不够直观</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作</li></ul><p>使用Promise方法对代码改进后：后一个请求不需要依赖于前一个请求的数据，提高了代码的可维护性</p><pre><code>let fs = require('fs')function read(url){  return new Promise((resolve,reject)=&gt;{    fs.readFile(url,'utf8',function(error,data){      error &amp;&amp; reject(error)      resolve(data)    })  })}read('./a.txt').then(data=&gt;{  return read(data) }).then(data=&gt;{  return read(data)  }).then(data=&gt;{  console.log(data)})</code></pre><blockquote><p>Promise是一个对象，它代表了一个异步操作的最终完成或者失败，是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，它的出现大大改善了异步编程的困境并且避免了回调地狱。简单来说Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，Promise是一个对象，可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理</p></blockquote><h2 id="Promise的实例有三个状态和两个过程"><a href="#Promise的实例有三个状态和两个过程" class="headerlink" title="Promise的实例有三个状态和两个过程"></a>Promise的实例有三个状态和两个过程</h2><p>三个状态：</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）<br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</li></ul><p>两个过程：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><h2 id="Promise的特点："><a href="#Promise的特点：" class="headerlink" title="Promise的特点："></a>Promise的特点：</h2><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，即在本轮事件循环运行完成之前，回调函数是不会被调用的。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><h2 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h2><pre><code>function successCallback(result) {    console.log('文件创建成功'+result)}function failureCallback(result) {    console.log('文件创建失败'+result)}createAudioFileAsync(audioSettings,successCallback,failureCallback)</code></pre><p>如果函数createAudioFileAsync()被重写为返回Promise的形式</p><pre><code>const promise = createAudioFileAsync(audioSettings)promise.then(successCallback,failureCallback)</code></pre><h3 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h3><ul><li>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。</li><li>then方法返回的是一个新的Promise实例（不是原来那个Promise实例）,即使异步操作已经完成，在这之后会通过then()添加的回调函数也会被调用。因此可以采用链式写法，即then方法后面再调用另一个then方法。</li><li>多次调用then()可以添加多个回调函数，它们会按照插入顺序进行执行</li></ul><pre><code>let promise = new Promise((resolve,reject)=&gt;{    ajax('first').success(function(res){        resolve(res);    })})promise.then(res=&gt;{    return new Promise((resovle,reject)=&gt;{        ajax('second').success(function(res){            resolve(res)        })    })}).then(res=&gt;{    return new Promise((resovle,reject)=&gt;{        ajax('second').success(function(res){            resolve(res)        })    })}).then(res=&gt;{})</code></pre><h3 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h3><blockquote><p>该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。</p></blockquote><pre><code>p.then((data) =&gt; {     console.log('resolved',data);},(err) =&gt; {     console.log('rejected',err);     }); p.then((data) =&gt; {    console.log('resolved',data);}).catch((err) =&gt; {    console.log('rejected',err);});</code></pre><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><blockquote><p>返回一个新的 promise, 只有所有的 promise 都成功才成功。</p></blockquote><pre><code>javascriptlet promise1 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(1);    },2000)});let promise2 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(2);    },1000)});let promise3 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(3);    },3000)});Promise.all([promise1,promise2,promise3]).then(res=&gt;{    console.log(res);    //结果为：[1,2,3] })</code></pre><h3 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h3><blockquote><p>返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态(并非是数组中的第一个，而是第一个完成的 promise)</p></blockquote><pre><code>let promise1 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       reject(1);    },2000)});let promise2 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(2);    },1000)});let promise3 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(3);    },3000)});Promise.race([promise1,promise2,promise3]).then(res=&gt;{    console.log(res);    //结果：2},rej=&gt;{    console.log(rej)};)</code></pre><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><blockquote><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p></blockquote><pre><code>promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···});</code></pre><ul><li>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</li></ul><h1 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h1><blockquote><p>Async与Await实际开发中应用：</p></blockquote><p>axios获取数据，返回一个promise对象，不会返回具体的数值<br><img src="/2021/10/28/async-await-Promise/promise.jpg" alt="alt"><br>当使用Async/Await来封装的时候会返回具体的数值<br><img src="/2021/10/28/async-await-Promise/await.jpg" alt="alt"></p><blockquote><p>Async/await是promise的一种语法糖，它也是为了解决回调地狱的问题，从本质上来讲，await函数仍然是promise，其原理跟Promise相似，不过比起Promise之后用then方法来执行相关一步操作，async/await 则把异步操作变得更像传统函数操作。</p></blockquote><pre><code>async function f() {    return 1;}</code></pre><p>在函数前面async这个关键字总是可以返回一个promise，其它的值将自动被包装在一个resolved的promise中<br>下列代码相当于上述代码</p><pre><code>async function f() {    return 1;}f().then(alert);//1//或者是显式地返回一个Promise，结果相同async function f() {    return Promise.resolve(1)}f().then(alert);//1</code></pre><blockquote><p>async 确保了函数返回一个promise，也会将非promise的值包装进去</p></blockquote><h1 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h1><blockquote><p>await关键字的作用是等到promise完成(settle)并返回结果，下面例子就是1s后resolve的promise</p></blockquote><pre><code>async function f(){    let promise = new Promise((resolve,reject) =&gt; {        setTimeout(() =&gt; resolve('done'),1000)    });    let result = await promise //等到promise resolve(*)    alert(result);//'done'}f();</code></pre><blockquote><p>这个函数在执行的时候，暂停在了（*）那一行，并在promise settle是，拿到reslut作为结果继续往下执行，<strong>await实际上会暂停函数的执行，直到promise状态变为settled</strong>，然后以promise的结果继续执行。这个行为不会耗费任何CPU资源，js引擎可以同时处理其他任务，相对于promise.then，它只是获取promise结果的一个更优雅的语法，同时也更易于读写</p></blockquote><h1 id="async-await对比Promise的优势"><a href="#async-await对比Promise的优势" class="headerlink" title="async/await对比Promise的优势"></a>async/await对比Promise的优势</h1><p>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担<br>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅<br>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余<br>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> 异步 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI</title>
      <link href="/2021/10/23/OSI/"/>
      <url>/2021/10/23/OSI/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qishui/p/5428938.html">https://www.cnblogs.com/qishui/p/5428938.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetCode1</title>
      <link href="/2021/10/22/leetCode1/"/>
      <url>/2021/10/22/leetCode1/</url>
      
        <content type="html"><![CDATA[<h1 id="去重，排序"><a href="#去重，排序" class="headerlink" title="去重，排序"></a>去重，排序</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目优化过程</title>
      <link href="/2021/10/22/vue-shop/"/>
      <url>/2021/10/22/vue-shop/</url>
      
        <content type="html"><![CDATA[<h1 id="分离开发模式与发布模式"><a href="#分离开发模式与发布模式" class="headerlink" title="分离开发模式与发布模式"></a>分离开发模式与发布模式</h1><blockquote><p>通过vue-cli3.0工具生成的项目，默认隐藏了所有的webpack配置项，如果要修改webpack默认配置的需求，可以在跟目录中按需创建vue.config.js这个配置文件，从而对项目的打包发布过程做自定义的配置<br>默认情况下vue的开发模式与发布模式共用一个打包的入口文件，为了将项目的开发过程与发布过程分离，我们可以分为两种模式各自指定打包的入口文件<br>开发模式入口：src/main-dev.js<br>发布模式入口：src/main-prod.js</p></blockquote><p>修改webpack配置方式</p><ol><li>configureWebpack：链式编程的形式</li><li>chainWebpack(项目采用)：操作对象的形式<blockquote><p>NODE_ENV是一个用户自定义的变量，在webpack中它的用途是判断生产环境或开发环境<br>vue.config.js配置如下</p></blockquote><pre><code> module.exports = { chainWebpack:config=&gt;{         //发布模式         config.when(process.env.NODE_ENV === 'production',config=&gt;{             config.entry('app').clear().add('./src/main-prod.js')         })         //开发模式         config.when(process.env.NODE_ENV === 'development',config=&gt;{             config.entry('app').clear().add('./src/main-dev.js')         })     } }</code></pre></li></ol><h1 id="项目文件体积过大"><a href="#项目文件体积过大" class="headerlink" title="项目文件体积过大"></a>项目文件体积过大</h1><h2 id="通过externals加载外部CDN资源"><a href="#通过externals加载外部CDN资源" class="headerlink" title="通过externals加载外部CDN资源"></a>通过externals加载外部CDN资源</h2><blockquote><p>默认情况下，通过import语法导入的第三方依赖包最终会被打包并合并到同一个文件中从而导致打包成功后，单文件体积过大的问题<br>为了解决以上问题，缩小依赖项的内存，可以通过webpack的externals节点，来配置并加载外部的CDN资源。它的作用就是不会打包依赖项合并到同一个文件里，当用到的某个包的时候直接去window的全局对象上寻找并且直接使用</p></blockquote><ul><li><p>优化流程</p><ol><li><p>vue.config.js中设置config.set()  用来配置externals节点</p><pre><code>//只在发布模式需要配置externalconfig.when(process.env.NODE_ENV === 'production', config =&gt; {     config         .entry('app')         .clear()         .add('./src/main-prod.js')     config.set('externals', {         vue: 'Vue',         'vue-router': 'VueRouter',         axios: 'axios',         lodash: '_',         echarts: 'echarts',         nprogress: 'NProgress',         'vue-quill-editor': 'VueQuillEditor'     })</code></pre></li><li><p>删除main-prod.js中import的包，在public/index.html中引入CDN资源文件替代</p><pre><code>&lt;!-- nprogress 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" /&gt;&lt;!-- 富文本编辑器 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css" /&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css" /&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css" /&gt;&lt;!-- element-ui 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.15.6/theme-chalk/index.css" /&gt;</code></pre></li></ol></li></ul><h2 id="首页内容的自定制（辨别项目是处于开发模式-发布模式）"><a href="#首页内容的自定制（辨别项目是处于开发模式-发布模式）" class="headerlink" title="首页内容的自定制（辨别项目是处于开发模式/发布模式）"></a>首页内容的自定制（辨别项目是处于开发模式/发布模式）</h2><p>当属于开发模式时，电商管理系统前自动会渲染上dev-，当属于发布模式时，渲染的title就只有电商管理系统这几个字</p><ul><li>优化步骤</li></ul><ol><li><p>vue.config.js编写业务逻辑，发布模式isProd为true，开发模式isProd为false</p><pre><code>module.exports = { chainWebpack: config =&gt; {     // 发布模式     config.when(process.env.NODE_ENV === 'production', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = true             return args         })     })     // 开发模式     config.when(process.env.NODE_ENV === 'development', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = false             return args         })     }) }}</code></pre></li><li><p>public/index.html中根据isProd的值来决定如何渲染页面结构</p></li></ol><blockquote><p>发布模式下需要加载CDN资源(import来引入)，不需要加上-dev；开发模式下需要加上-dev，并且需要加载CDN资源</p></blockquote><pre><code>    &lt;!--按需渲染页面的标题 htmlWebpackPlugin:插件名称 --&gt;      &lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %&gt;电商后台管理系统&lt;/title&gt;        &lt;!--按需加载外部的CDN资源--&gt;        &lt;% if(htmlWebpackPlugin.options.isProd){ %&gt;        CDN资源        &lt;% } %&gt;</code></pre><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><blockquote><p>当打包构建项目时，JavaScript包会变得非常大，如果我们能把不同路由对应的组件分割成不同的代码块，当路由被访问的时候才会加载对应组件会变得非常高效</p></blockquote><ul><li>优化步骤</li></ul><ol><li>安装@babel/plugin-syntax-dynamic-import包</li><li>在babel.config.js配置文件中声明该插件</li><li>将路由改为按需加载的形式<br>webpackChunkName:规定了分配多个组件打包到同一个js文件的Group</li></ol><pre><code>import Vue from 'vue'import VueRouter from 'vue-router'//import Login from '@/components/Login.vue'const Login = () =&gt;    import(/* webpackChunkName: "login_home_welcome" */ '@/components/Login.vue')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS设计模式</title>
      <link href="/2021/10/21/designModel/"/>
      <url>/2021/10/21/designModel/</url>
      
        <content type="html"><![CDATA[<h1 id="发布-订阅者模式"><a href="#发布-订阅者模式" class="headerlink" title="发布-订阅者模式"></a>发布-订阅者模式</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>其他遍历方法</title>
      <link href="/2021/10/21/ergodic3/"/>
      <url>/2021/10/21/ergodic3/</url>
      
        <content type="html"><![CDATA[<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><blockquote><p>在执行的时候，会先判断执行条件再执行，for循环可以用来遍历数组，字符串，类数组，DOM节点等，可以改变原数组</p></blockquote><h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><blockquote><p>while循环中的结束条件可以是各种类型，但是最终都会转化为布尔值</p></blockquote><ul><li>Boolean：true，false</li><li>String：空字符串为false，所有非空字符串为true</li><li>Number：0为false，非0数字为true</li><li>null/Undefinded/NaN:全为假</li><li>Object：全为真</li></ul><p>while和for一样，都是先判断再执行，只要指定条件为true，循环就可以一直执行代码</p><h1 id="do-while"><a href="#do-while" class="headerlink" title="do/while"></a>do/while</h1><blockquote><p>该方法会先执行再判断，即使初始条件不成立,do/while循环也会至少执行一次，不建议使用do/while来遍历数组</p></blockquote><pre><code>let num = 10;do {    console.log(num);    num--;}while(num &gt;= 0);console.log(num); //-1</code></pre><h1 id="for-await-of"><a href="#for-await-of" class="headerlink" title="for await of"></a>for await of</h1><blockquote><p><code>for await of</code>方法被称为异步迭代器，该方法是主要用来遍历异步对象<br><code>for await of</code>语句会在异步或者同步可迭代对象上创建一个迭代循环，包括String，Array，类数组，Map，Set和自定义的异步或者同步可迭代对象。<strong>这个语句只能在async function内使用</strong></p></blockquote><pre><code>function Gen(time) {    return new Promise((resolve,reject) =&gt; {        setTimeout(function(){            resolve(time)        },time)    })}async function test (){    let arr = [Gen(2000),Gen(100),Gen(3000)]    for await(let item of arr){        console.log(Promise,Date.now(),item)    }}test()</code></pre><p>输出结果：<br><img src="/2021/10/21/ergodic3/async.jpg" alt="alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象遍历方法</title>
      <link href="/2021/10/21/ergodic2/"/>
      <url>/2021/10/21/ergodic2/</url>
      
        <content type="html"><![CDATA[<h1 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h1><blockquote><p>for in主要用于循环对象属性，循环中的代码每执行一次，就会对对象的属性进行一次操作<br>语法：</p></blockquote><pre><code>for(var i in obj) {    /*dosomthing*/}</code></pre><ul><li>i：必须，指定的变量可以是数组元素，也可以是对象的属性</li><li>obj：必须，指定迭代的对象</li></ul><pre><code>var obj = {a:1,b:2,c:3}for(var i in obj){    console.log('键名',i);    console.log('键值',obj[i])}</code></pre><p>输出结果：</p><pre><code>键名：a键值：1键名：b键值：2键名：c键值：3</code></pre><h2 id="point"><a href="#point" class="headerlink" title="point"></a>point</h2><ul><li>for in放啊不仅会遍历当前对象的所有可枚举属性，还会遍历其原型链上的属性</li></ul><h1 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys()/Object.values()/Object.entries()"></a>Object.keys()/Object.values()/Object.entries()</h1><blockquote><p>遍历对象，它会返回一个有给定对象的自身可枚举属性(不含继承和Symbol属性)组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，返回值如下</p></blockquote><ul><li><code>Object.keys()</code> 返回包含对象<strong>键名</strong>的数组</li><li><code>Object.values()</code>返回包含对象<strong>键值</strong>的数组</li><li><code>Object.entries()</code>返回包含对象<strong>键名和键值</strong>的数组</li></ul><pre><code>let obj = {    id : 1,    name : 'hello',    age : 18};console.log(Object.keys(obj)); //['id','name','age']console.log(Object.values(obj)); //[1,'hello',18]console.log(Object.entries(obj)); //[['id',1],['name','hello'],['age',18]]</code></pre><h2 id="point-1"><a href="#point-1" class="headerlink" title="point"></a>point</h2><ul><li>Object.keys()方法但会数组中的值都是字符串，即不是字符串的key值会转化为字符串</li><li>结果数组中的属性值都是对象本身<strong>可枚举的属性</strong>，不包括继承来的属性</li></ul><h1 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h1><blockquote><p><code>Object.getOwnPropertyNames()</code>方法与<code>Object.keys()</code>类似，也是接受一个对象作为参数，返回一个数组，包含了改对象自身的所以属性名，但是它能返回<strong>不可枚举属性</strong></p></blockquote><pre><code>let a = ['hello','world'];Object.keys(a); //['0','1']Object.getOwnPropertyNames(a); //['0','1','length']</code></pre><p>这两个方法都可以用来计算对象中属性的个数：</p><pre><code>var obj = {0:'a',1:'b',2:'c'};Object.getOwnPropertyName(obj); //['0','1','2']Object.keys(obj).length;//3Object.getOwnPropertyNames(obj).length;//3</code></pre><h1 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h1><blockquote><p>Object.getOwnPropertySymbols()方法返回对象自身的Symbol属性组成的数组，不包括字符串属性</p></blockquote><pre><code>let obj = {a:1}//给对象添加一个不可枚举的Symbol属性Object.defineProperties(obj,{    [Symbol('baz')]:{        value:'Symbol baz',        enumerable:false    }})//不可枚举的Symbol属性obj[Symbol('foo')] = 'Symbol foo'Object.getOwnPropertySymbols(obj).forEach((key) =&gt;{    console.log(obj[key])})//输出结果：Symbol baz Symbol foo</code></pre><h1 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h1><blockquote><p>Reflect.ownKeys()返回一个数组，包含对象自身的所有属性，它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：</p></blockquote><pre><code>var obj = {    a:1,    b:2}Object.defineProperty(obj,'method',{    value:function() {        alert('No enumerable property')    },    enumerable:false})console.log(Object.keys(obj)); // ['a','b']console.log(Reflect.ownKeys(obj)); //['a','b','method']</code></pre><h2 id="point-2"><a href="#point-2" class="headerlink" title="point"></a>point</h2><ul><li>Object.keys():相当于返回对象属性数组</li><li>Reflect.ownKeys()：相当于 <code>Object.getOwnPropertyNames(obj.concat(Object.getOwnPropertySymbols(obj)))</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组遍历方法</title>
      <link href="/2021/10/17/jump/"/>
      <url>/2021/10/17/jump/</url>
      
        <content type="html"><![CDATA[<h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h1><blockquote><p>forEach方法用于调用数组中的每个元素，将元素传递给回调函数，数组中的每个值都会调用回调函数<br>语法：<code>arr.forEach(callback(currentValue,index,arr),isValue)</code></p></blockquote><p>callback<br>    - currentValue：（必须）当前元素<br>    - index：可选，当前元素的索引值<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>let arr = [1,2,3,4,5]arr.forEach((item,index,arr) =&gt;{    console.log(index + ':' + item)})</code></pre><blockquote><p>第二个参数用来绑定回调函数内的this变量(回调不能是箭头函数，因为箭头函数无this)</p></blockquote><pre><code>let arr = [1,2,3,4]let arr1 = [7,8,7,9]arr.forEach(function(item,index,arr){    console.log(this[index]);//[7,8,7.9]},arr1)</code></pre><ul><li>forEach方法不会改变原数组，也没有返回值</li><li>forEach无法使用break，continue跳出循环</li><li>forEach无法遍历对象，仅适用于数组的遍历</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><blockquote><p>map()方法会返回一个新数组，该方法按照原始数组元素顺序依次处理元素<br>语法：<code>arr.map(callback(currentValue,index,arr),thisValue)</code></p></blockquote><p>callback<br>    - currentValue：（必须）当前元素<br>    - index：可选，当前元素的索引值<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>let arr = [1,2,3];arr.map(item =&gt; {    return item +1 ; //[2,3,4]})</code></pre><blockquote><p>第二个参数用来绑定参数函数内部的this变量</p></blockquote><pre><code>let arr = ['a','b','c'];[1,2].map(function(e){    return this[e]; //['b','c']},arr)</code></pre><p>该方法还可以进行链式调用</p><pre><code>let arr = [1,2,3];arr.map(item =&gt; item + 1).map(item =&gt; item +1)//输出结果:[3,4,5]</code></pre><ul><li>map方法不会对空数组进行检测</li><li>map方法遍历数组时会返回一个新数组，不改变原始数组</li><li>map方法有返回值，可以return出来，map的回调函数函数中支持return返回值</li></ul><h1 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h1><blockquote><p>for…of语句创建一个循环来迭代可迭代的对象，在es6中引入的for…of替代for…in和forEach<br>语法：<code>for(variable of iterable){ statement }</code></p></blockquote><ul><li>variable:每个迭代的属性值被分配给该变量</li><li>iterable：一个具有可枚举属性并且可以迭代的对象</li></ul><pre><code>let arr =[    {id:1,value:'hello'},    {id:2,value:'world'},    {id:3,value:'Javascript'}]for(let item of arr){    console.log(item);    //{id:1,value:'hello'},    //{id:2,value:'world'},    //{id:3,value:'Javascript'}}</code></pre><ul><li>for of方法只会遍历当前对象的属性，不会遍历其原型链上的属性</li><li>for of方法适用遍历<strong>数组/类数组/字符串/map/set</strong>等拥有迭代对象的集合</li><li>for of方法不支持遍历普通对象，因为其没有迭代器对象，如果想要遍历一个对象的属性可以使用for in方法</li><li>可以使用break，continue，return来中断循环遍历</li></ul><h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><blockquote><p>filter()方法用于过滤数组，满足条件的元素会被返回，它的参数是一个回调函数，所有数组元素一次执行该函数，结果为true的元素被返回，如果没有符合条件的元素，则会返回空数组<br>语法：<code>arr.filter(callback(currentValue,index,arr),thisValue)</code></p></blockquote><p>callback<br>    - currentValue:必须，数组中正在处理的元素<br>    - index：可选，当前元素索引<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>const arr = [1,2,3,4,5]arr.filter(item =&gt; item &gt; 2)//[3,4,5]</code></pre><blockquote><p>第二个参数用来绑定函数内部的this变量<br> 可以使用filter方法来移除数组中的undefined，null，NAN等值</p></blockquote><pre><code>let arr = [1,undefined,2,null,3,false,'',4,0]arr.filter(Boolean);//[1,2,3,4]</code></pre><ul><li>filter方法会返回新数组，不会改变原数组</li><li>filter方法不会对空数组进行检测</li><li>filter方法仅仅用于检测数组</li></ul><h1 id="some-every"><a href="#some-every" class="headerlink" title="some()/every()"></a>some()/every()</h1><blockquote><p>some方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就会返回true，且剩余的元素不会再进行检测，否则就返回false<br>语法<code>arr.some(callback(currentValue,index,arr),thisValue)</code></p></blockquote><blockquote><p>every()方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才会返回true，如果数组中检测到有个元素不满足，则整个表达式返回false，且剩余的元素不会再进行检测<br>语法：<code>arr.every(callback(currentValue,index,arr),thisValue)</code></p></blockquote><pre><code>let arr = [1,2,3,4,5]arr.some(item =&gt; item &gt; 4) // truelet arr = [1,2,3,4]arr.every(item =&gt; item &gt;0) //true</code></pre><ul><li>两个方法都不会改变原数组，会返回一个布尔值</li><li>两个方法都不会对空数组进行检测</li><li>两个方法都适用于检测数组</li></ul><h1 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce()/reduceRight()"></a>reduce()/reduceRight()</h1><blockquote><p>reduce()方法接受一个函数作为累加器，数组中的每个值(从左到右)开始缩减，最终计算为一个值，reduce方法会为数组中的<strong>每一个元素依次执行回调函数</strong>，不包括数组中被删除或从未被赋值的元素<br>语法：<code>arr.reduce(callback(total,currentValue,currentIndex,arr)initialValue)</code></p></blockquote><p>callback<br>    - total：上一次调用回调返回的值，或者是提供的初始值(initialValue)<br>    - currentValue:当前被处理的元素；<br>    - currentIndex：当前元素的索引<br>    - arr：当前元素所属的数组对象<br>该方法的第二个参数是initialValue，表示传递给函数的初始值，作为第一次调用callback的第一个参数</p><pre><code>let arr = [1,2,3,4]let sum = arr.reduce((prev,cur,index,arr) =&gt; {    console.log(prev,cur,index);    return prev + cur;})console.log(arr,sum);//输出结果//1 2 1//3 3 2//6 4 3//[1,2,3,4]10</code></pre><p>加一个初始值之后</p><pre><code>let arr = [1,2,3,4]let sum = arr.reduce((prev,cur,index,arr) =&gt; {    console.log(prev,cur,index);    return prev + cur;},5)console.log(arr,sum);//输出结果//5 1 0//6 2 1//8 3 2//11 4 3//[1,2,3,4] 15</code></pre><blockquote><p>由此可以得出结论，如果没有提供初始值initialValue，reduce会从索引1的地方开始执行callback方法，跳过第一个索引，如果提供了initialValue，从索引0开始执行</p></blockquote><p>reduceRight方法和reduce的用法几乎一致，只是该方法是对数组进行倒序遍历的，而reduce方法是正序遍历</p><ul><li>两个方法在添加初始值的情况下才会改变原数组，否则不会改变原数组，会将这两个初始值放在数组的最后一位</li><li>两个方法对于空数组是不会执行回调函数的</li></ul><h1 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find()/findIndex()"></a>find()/findIndex()</h1><blockquote><p>find方法返回通过函数内判断符合条件的值,当数组中的元素在测试条件返回true时，find返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素则返回undefined<br>语法：<code>arr.find(callback(currentValue,index,arr),thisValue)</code></p></blockquote><blockquote><p>findIndex方法返回通过函数内判断符合条件的值的索引，之后的值不会再调用执行函数，如果没有符合条件的元素返回-1<br>语法：<code>arr.findIndex(callback(currentValue,index,arr),thisValue)</code></p></blockquote><pre><code>let arr = [1,2,3,4,5]arr.find(item =&gt; item &gt; 2); //3let arr = [1,2,3,4,5]arr.findIndex(item =&gt; item &gt; 2); //2</code></pre><ul><li>两个方法对于空数组，函数是不会执行的</li><li>两个方法不会改变原数组</li></ul><h1 id="keys-values-entries"><a href="#keys-values-entries" class="headerlink" title="keys()/values()/entries()"></a>keys()/values()/entries()</h1><blockquote><p>三个方法都返回一个数组的迭代对象，对象的内容不太相同</p></blockquote><ul><li>keys() 返回数组的<strong>索引</strong>值：<code>arr.keys()</code></li><li>values() 返回数组的<strong>元素</strong>:<code>arr.values()</code></li><li>entries() 返回数组的<strong>键值对</strong>:<code>arr.entries()</code></li></ul><pre><code>let arr = ['Banana','Orange','Apple','Mango'];//这三个方法都没有参数const iterator1 = arr.keys();const iterator2 = arr.values();const iterator3 = arr.entries();for(let item of iterator1){    console.log(item); //0 1 2 3}for(let item of iterator2){    console.log(item); //Banana Orage Apple Mango}for(let item of iterator3){    console.log(item);//[0, 'Banana'] [1, 'Orange'] [2, 'Apple'] [3, 'Mango']}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础一</title>
      <link href="/2021/10/14/baseVue/"/>
      <url>/2021/10/14/baseVue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结自官方文档</p></blockquote><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="创建应用实例"><a href="#创建应用实例" class="headerlink" title="创建应用实例"></a>创建应用实例</h2><ul><li>Vue应用都是通过createApp函数创建一个新的应用实例，由于createApp方法返回实例本身，因此可以在其后 链式调用其他方法</li><li>调用createApp返回一个应用实例。应用实例挂载的整个组件树共享的上下文。<pre><code>const app = Vue.createApp({  //根组件})//该实例用来在应用中注册“全局”组件const app = Vue.createApp({})app.component('searchInput',SearchComponent)app.directive('focus',FocusDirective)app.use(LocalePlugin)//应用实例暴露的大多数方法都会返回同一实例，允许链式Vue.createApp({})  .component('searchInput',searchInputComponent)  .directive('focus',FocusDirective)  .use(LocalePlugin)</code></pre></li></ul><h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h2><ul><li>传递给createApp的选项用于配置根组件,当我们挂载应用时，该组件被用作渲染的起点</li><li>一个应用需要被挂载到一个DOM元素中，例如你想吧一个Vue应用挂载到<div id="app"></div>,应该传入#app<br>```<br>const RootComponent ={<br>  //选项<br>}<br>const app = Vue.createApp(RootComponent)</li></ul><p>```</p><h1 id="组件实例property"><a href="#组件实例property" class="headerlink" title="组件实例property"></a>组件实例property</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2021/10/09/paper-vuex/"/>
      <url>/2021/10/09/paper-vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p><img src="/2021/10/09/paper-vuex/1.png" alt="alt"></p><ul><li>当多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态无能为力</li><li>来自不同组件的行为需要变更同一状态，以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码</li><li>综上，<strong>当项目遇到多个组件依赖于同一状态时；或者来自不同组件的行为需要变更同一状态时</strong>可以使用Vuex</li></ul><blockquote><p>Vuex实现了一个单向数据流，在全局中拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新，而当所以异步操作（常见于调用后端接口异步获取更新数据）或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过MutationlI修改State的数据。最后，根据State的变化，渲染到视图上</p></blockquote><h2 id="引入Vuex"><a href="#引入Vuex" class="headerlink" title="引入Vuex"></a>引入Vuex</h2><ul><li>安装依赖npm install vuex –save</li><li>项目目录src中建立store文件夹</li><li>在store文件夹下新建index.js文件，写入<pre><code>import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);//不是在生产环境debug为trueconst debug = process.env.NODE_ENV !== 'production';//创建Vuex实例对象const store = new Vuex.Store({  strict:debug,//在不是生产环境下都开启严格模式  state:{  },  getters:{  },  mutations:{  },  actions:{  }})export default store;</code></pre></li><li>main.js中引入Vuex<br>```<br>import Vue from ‘vue’;<br>import App from ‘./App.vue’;<br>import store from ‘./store’;<br>const vm = new Vue({<br>  store:store,<br>  render: h =&gt; h(App)<br>}).$mount(‘#app’)</li></ul><pre><code>## Vuex核心属性### stateVuex的state相当于一个全局的state，你可以在component的任何地方获取和修改它。如果有些状态严格属于单个组件，最好还是作为组件的局部状态</code></pre><p>//获取state<br>this.$store.state.count</p><pre><code>### gettersVuex里的getters类似于computed，可以认为是store的计算属性，getter的返回值会根据它的依赖被缓存起来，且只有当它的以来至发生了改变才会被重新计算</code></pre><p>//直接使用<br>this.$store.getters.doneTodoCount</p><p>//或者<br>import {mapGetters} from ‘vuex’<br>computed:mapGetters({<br>    doneCount:’doneTodoCount’<br>})</p><pre><code>### mutations更改Vuex的store状态的唯一方法时提交mutaion，mutation必须是同步函数</code></pre><p>//直接触发mutations<br>this.$store.commit(‘xxx’)</p><p>//或者<br>import { mapMutations } from ‘vuex’<br>methods：mapMutations([‘increment’ ])</p><pre><code>### actionsAction类似mutation，不同在于- Action提交的是mutation，而不是直接变更状态- Action可以包含任何异步操作</code></pre><p>//触发action<br>store.dispatch(‘increment’)</p><p>//或者<br>import {mapActions} from ‘vuex’<br>methods:mapActions([‘increment’])</p><pre><code>### Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store对象就有可能变得臃肿，为了解决以上问题，Vuex允许我们将store分割成模块(moudule)。每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块--从上至下进行相同方式的分割</code></pre><p>const moduleA = {<br>  state: { … },<br>  mutations: { … },<br>  actions: { … },<br>  getters: { … }<br>}</p><p>const moduleB = {<br>  state: { … },<br>  mutations: { … },<br>  actions: { … }<br>}</p><p>const store = new Vuex.Store({<br>  modules: {<br>    a: moduleA,<br>    b: moduleB<br>  }<br>})</p><p>store.state.a // -&gt; moduleA 的状态<br>store.state.b // -&gt; moduleB 的状态</p><p>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目，仿写去哪儿app</title>
      <link href="/2021/10/05/paper-project-VueWhere/"/>
      <url>/2021/10/05/paper-project-VueWhere/</url>
      
        <content type="html"><![CDATA[<iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="解决文字溢出的方法："><a href="#解决文字溢出的方法：" class="headerlink" title="解决文字溢出的方法："></a>解决文字溢出的方法：</h2><p>textOverflow()<br>  white-space:nowrap;<br>  text-overflow:ellipsis;<br>  overflow:hidden;</p><h2 id="表格边框写法"><a href="#表格边框写法" class="headerlink" title="表格边框写法"></a>表格边框写法</h2><h1 id="首页数据前台接口部分"><a href="#首页数据前台接口部分" class="headerlink" title="首页数据前台接口部分"></a>首页数据前台接口部分</h1><h2 id="优化冗余路径"><a href="#优化冗余路径" class="headerlink" title="优化冗余路径"></a>优化冗余路径</h2><blockquote><p>把<a href="http://localhost:8080/static/mock">http://localhost:8080/static/mock</a>   冗余的路径替换成api</p></blockquote><p><img src="/2021/10/05/paper-project-VueWhere/api1.jpg" alt="alt"><br><img src="/2021/10/05/paper-project-VueWhere/api3.jpg" alt="alt"></p><blockquote><p>修改系统文件，在webpack下设置代理项，重置路径</p></blockquote><p><img src="/2021/10/05/paper-project-VueWhere/api2.jpg" alt="alt"></p><h1 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h1><h2 id="项目中使用到的路由跳转的方法"><a href="#项目中使用到的路由跳转的方法" class="headerlink" title="项目中使用到的路由跳转的方法"></a>项目中使用到的路由跳转的方法</h2><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>实现hot页面上点击的城市渲染到header上<br><img src="/2021/10/05/paper-project-VueWhere/router1.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>&lt;router-link :to = "{name:'home'}"&gt;</code> 建议使用name<br><code>&lt;router-link :to = "{path:'/home'}"&gt;</code></p><blockquote><p>router-link中链接如果是’/‘开始就是从根路由开始,如果开始不带’/‘,则从当前路由开始</p></blockquote></li><li><p>带参数</p></li></ul><p><code>&lt;router-link :to="{name:'home',params:{id:1}}"&gt;</code></p><blockquote><p>params传参(类似post) 配置path:”/home:id”或path:”/home/:id”,刷新页面id会保留，不配置path；第一次可请求，刷新页面id会消失</p></blockquote><p><code>&lt;router-link :to = "{name:'home',query:{id:1}}"&gt;</code></p><blockquote><p>query传参(类似get，url后面会显示参数)路由不可配置</p></blockquote><h3 id="this-router-push-函数里调用"><a href="#this-router-push-函数里调用" class="headerlink" title="this.$router.push()(函数里调用)"></a>this.$router.push()(函数里调用)</h3><p><img src="/2021/10/05/paper-project-VueWhere/router2.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>this.$router.push('/home')</code><br><code>this.$router.push({name:'home'})</code><br><code>this.$router.push({path:'/home'})</code></p></li><li><p>query传参<br><code>this.$router.push({name:'home',query:{id:'1'})</code><br><code>this.$router.push({path:'/home',query:{id:'1'}})</code></p></li><li><p>params传参<br><code>this.$router.push(name:'home',params:{id:'1'})</code> 只能用name</p></li></ul><h2 id="keep-alive减少相同请求优化"><a href="#keep-alive减少相同请求优化" class="headerlink" title="keep-alive减少相同请求优化"></a>keep-alive减少相同请求优化</h2><blockquote><p>keep-alive本身是vue2.0的功能，为了让组件数据缓存，避免每次资源加载重复请求</p></blockquote><ul><li>不切换城市的时候不需要重新发送dataHome请求<br><img src="/2021/10/05/paper-project-VueWhere/route.jpg" alt="alt"></li><li>设置keep-alive<br><img src="/2021/10/05/paper-project-VueWhere/route1.jpg" alt="alt"></li><li>需要重新设置Home里的请求数据的方法getHttp（）<br><img src="/2021/10/05/paper-project-VueWhere/route2.jpg" alt="alt"></li></ul><h1 id="vuex实现子组件到子组件的通信"><a href="#vuex实现子组件到子组件的通信" class="headerlink" title="vuex实现子组件到子组件的通信"></a>vuex实现子组件到子组件的通信</h1><blockquote><p>项目中除了从City页面中的子页面到Home中的子页面用的是子组件的通信，其他的都是父组件到子组件通信</p></blockquote><ul><li>点击hot页面的城市跳转到首页并且header右边的城市变为相对应的城市<br>项目相关配置<br><img src="/2021/10/05/paper-project-VueWhere/vuex.jpg" alt="alt"><br>List文件下配置<br><img src="/2021/10/05/paper-project-VueWhere/vuex1.jpg" alt="alt"></li></ul><h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h2><p>在实战中发现多次通过路由切换组件页面滚动和点击事件都会失效</p><blockquote><p>解决方法：<br>初始化<br>首先要引入组件，需要dom结构加载完成时才执行初始化（$nextTick）。因此，需要用上钩子函数created()或者mounted()。</p></blockquote><pre><code>&lt;div class="wrapper" ref="wrapper"&gt;  &lt;div class="content"&gt;    &lt;ul&gt;      &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/div&gt;import BScroll from 'better-scroll'mounted() {      this.$nextTick(() =&gt; {        //$refs绑定元素        if(!this.scroll){            this.scroll = new BScroll(this.$refs.wrapper, {            //开启点击事件 默认为false            click:true        })        // console.log(this.scroll)        }else if(!this.$refs.wrapper){            return        }        else{            this.scroll.refresh()        }      })  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS原型</title>
      <link href="/2021/09/25/paper-prototype/"/>
      <url>/2021/09/25/paper-prototype/</url>
      
        <content type="html"><![CDATA[<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><h2 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h2><blockquote><p>在js中，创建对象有好几种方式，比如对象字面量，或者是直接通过构造函数new一个对象出来，虽然都是对象，却存在着差异性，js中，我们将对象分为函数对象和普通对象。函数对象就是用函数来模拟类的实现</p></blockquote><pre><code>function func1(){}const func2 = function(){};const func3 = new Function('name','console.log(name)');const obj1 = {};const obj2 = new Object();const obj3 = new func1();const obj4 = new new Function();console.log(typeof Object);//functionconsole.log(typeof Function);//function</code></pre><ul><li>上述代码中，obj1,obj2,obj3,obj4都是普通对象</li><li>func1，func2，func3都是Function的实例，也就是函数对象</li><li>可以看出<strong>所有Function的实例都是函数对象其他都为普通对象包括Function实例的实例</strong></li><li>Function和new Function的关系为<code>Function.__proto__=== Function.prototype</code><blockquote><p>__proto__和constructor是对象独有的，prototype属性是函数独有的，但是在js中函数也是对象，所以函数也拥有__proto__和constructor属性</p></blockquote></li></ul><p><img src="/2021/09/25/paper-prototype/1.jpg" alt="alt"></p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><blockquote><p>es规范里描述prototype是一个隐式引用，但是之前的一些浏览器已经私自实现了__proto__这个属性，使得可以通过obj.__proto__这个显示的属性访问访问到被定义为隐式属性的prototype</p></blockquote><ul><li>__proto__属性既不能被for…in遍历出来，也不能被Object.keys(obj)查找出来</li><li>访问对象的obj.<strong>proto</strong>,默认走的是object.prototype对象上__proto__属性的get/set方法</li><li>__proto__是函数指向对象</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>__proto__是对象所独有的，并且__proto__是一个对象指向父类对象，它的作用是当你在访问一个对象属性的时候，如果对象内部没有这个属性，那他就在他的__proto__属性所指的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那他就在他父类的__proto__所指的对象上查找，以此类推，直到找到null，这个查找的过程也构成了原型链</p></blockquote><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><blockquote><p>在规范里，prototype被定义为<strong>给其他对象提供共享属性的对象</strong></p></blockquote><ul><li>prototype自己也是对象，只是被用以承担某个职能</li><li>所有对象都可以作为另一个对象的prototype使用</li><li>prototype是<strong>函数</strong>独有的，它的作用是可以给特定类型的所有实例提供共享的属性和方法，<strong>任何函数在创建的时候，都会给该函数添加prototype属性</strong><br><img src="/2021/09/25/paper-prototype/2.jpg" alt="alt"></li></ul><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><blockquote><p>constructor属性也是对象所独有的，它是<strong>一个对象指向一个函数</strong>，这个函数就是该对象的构造函数</p></blockquote><ul><li>每个对象都有对应本身或者继承而来的构造函数</li><li>只有prototype对象有constructor这个属性</li><li>在每个函数创建的时候js会同时创建一个prototype对象，且<code>该对象创建的函数.__proto__ === 该函数.prototype</code>，<code>该函数.prototype.constructor === 该函数</code></li><li>所以通过函数创建的对象即使已经没有constructor属性，也能通过__proto__找到对应的constructor<br><img src="/2021/09/25/paper-prototype/3.jpg" alt="alt"><blockquote><p>上图虚线表示继承来的constructor</p></blockquote></li></ul><h1 id="typeof-amp-amp-instanceof"><a href="#typeof-amp-amp-instanceof" class="headerlink" title="typeof &amp;&amp; instanceof"></a>typeof &amp;&amp; instanceof</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><blockquote><p>typeof一般被用来判断一个变量的类型</p></blockquote><ul><li>我们可以使用typeof来判断number、undefined、symbol、string、function、boolean、object 这七种数据类型，</li><li>但是判断Object的时候并不能明确的告诉你object属于哪一种object<pre><code>let s = new String('abc');typeof s === 'object'//truetypeof null;//'object'</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3>js在底层存储变量的时候会在变量的机器码的低位1-3位存储其类型信息</li><li>1：整数</li><li>110：布尔</li><li>100：字符串</li><li>010：浮点数</li><li>000：对象<br>对于undefined和null、，这两个值的信息存储是特殊的</li><li>null：所有机器码均为0</li><li>undefined：用 −2^30 整数来表示<blockquote><p>在使用typeof来判断变量类型的时候，最好用typeof来判断基本数据类型，避免对null的判断</p></blockquote></li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>instanceof运算符用来检测constructor.prototype是否存在于object的原型链上，与typeof方法不同的是，instanceof方法要求开发者明确地确认对象为某特定类型</p></blockquote><ul><li>如下，是instanceof的基本用法，它可以判断一个实例是否是其父类型或者祖先类型的实例<br>```<br>// 定义构造函数<br>function C(){}<br>function D(){} </li></ul><p>var o = new C();</p><p>o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype</p><p>o instanceof D; // false，因为 D.prototype 不在 o 的原型链上</p><p>o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true<br>C.prototype instanceof Object // true，同上</p><p>C.prototype = {};<br>var o2 = new C();</p><p>o2 instanceof C; // true</p><p>o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.</p><p>D.prototype = new C(); // 继承<br>var o3 = new D();<br>o3 instanceof D; // true<br>o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上</p><pre><code># 类的prototype属性和__proto__属性&gt; 大多数浏览器中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时拥有prototype属性和__proto__属性，因此同时存在两条继承链- 子类的__proto__属性，表示**构造函数**的继承，总是指向父类- 子类prototype属性的__proto__属性，表示**方法**的继承，总是指向父类的prototype属性</code></pre><p>Class Father{<br>}<br>Class Child extends Father{<br>}<br>Child.<strong>proto</strong> === Father;//true<br>Child.prototype.<strong>proto</strong> === Father.prototype;//true</p><pre><code>上面代码中，子类的__proto__属性指向父类，子类的prototype属性的__proto__属性指向父类的prototype属性这样是因为类的继承是按照下面的模式实现的</code></pre><p>Class Father{<br>}<br>Class Child{<br>}<br>//Child的实例继承Father的实例<br>Object.setPrototypeOf(Child.prototype,Father.prototype);<br>//Child继承Father的静态属性<br>Object.setPrototype(Child,Father)</p><p>const c = new Child();</p><pre><code>`Object.setPrototypeOf`方法的实现如下：Object.setPrototypeOf = function(obj,proto){    obj.__proto__ = proto;    return obj;}因此就得到了上面的结果</code></pre><p>Object.setPrototypeOf(Child.prototype,Father.prototype);<br>//等同于<br>Child.prototype.<strong>proto</strong> = Father.prototype;<br>Object.setPrototypeOf(Child,Father);<br>//等同于<br>Child.<strong>proto</strong> = Father;</p><pre><code>这两条继承链可以这样理解：作为一个对象，子类(Child)的原型(__proto__属性)是父类(Father)；作为一个构造函数，子类(Child)的原型对象(prototype属性)是父类原型对象(prototype属性)的实例</code></pre><p>Child.prototype = Object.create(Father.prototype);<br>Child.prototype.<strong>proto</strong> = Father.prototype;</p><pre><code>extends关键字后面可以跟很多种类型的值</code></pre><p>class Child extends Father{<br>}</p><pre><code>上面代码中的Father只要有一个有prototype属性的函数就能被Child继承，由于函数都有prototype属性(处理Function.prototype函数)，因此Father可以是任何函数下面讨论两种情况，第一种，子类继承Object类</code></pre><p>class Child extends Object{<br>}<br>Child.<strong>proto</strong> === Object//ture<br>Child.prototype.<strong>proto</strong> = Object.prototype //true</p><pre><code>这种情况下，Child其实就是构造函数Object的复制，Child的实例就是Object的实例第二种情况，不存在任何继承</code></pre><p>class C{<br>}<br>C.<strong>proto</strong> === Function.prototype; //true<br>C.prototype.<strong>proto</strong> === Object.prototype; //true</p><pre><code>这种情况下，C作为一个基类(即不存在任何继承)就是一个普通函数，所以直接继承Function.prototype，但是C调用后返回一个空对象(即Object实例)，所以C.prototype.__proto__指向构造函数(Object)的prototype属性# 实例的__proto__属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性，也就是说，子类原型的原型，是父类的原型</code></pre><p>var p1 = new Father(2,3);<br>var p2 = nw Child(2,3,’neo’);</p><p>p2.<strong>proto</strong> === p1.<strong>proto</strong> //false<br>p2.<strong>proto</strong>.<strong>proto</strong> === p1.<strong>proto</strong> //true</p><pre><code>- 上面代码中Child继承了Father，导致前者原型的原型是后者的原型- 通过子类实例的__proto__.__proto__属性可以修改父类实例的行为</code></pre><p>p2.<strong>proto</strong>.<strong>proto</strong>.personName = function(){<br>    console.log(‘one’)<br>}<br>p1.personName()//‘one’</p><pre><code>- 上面代码在Child的实例p2上向Father类添加方法，结果影响到了Father类的实例p1# 继承## ES5继承实现方式es5规范中新增了Object.create()方法，该方法会传入一个对象，返回一个对象，返回的对象的原型指向传入的对象。比如执行代码var output = Object.create(input)，相当于执行代码output.__proto__ = input,output的原型是input   Object.keys()方法用以获取对象自身的属性数组，我们可以用该方法简化继承父类静态属性和方法的过程</code></pre><p>function extendsClass(child,Father){<br>    Child.prototype = Object.create(Father.prototype);<br>    Child.prototype.constructor = child;</p><pre><code>Object.keys(Father).forEach(function(key){    Child[key] = Father[key]})</code></pre><p>}</p><pre><code>## ES6继承(class继承)&gt; Class可以通过extends关键字实现继承，这比ES5通过原型链实现继承要清晰和方便的多</code></pre><p>class Father{<br>}<br>class Child extends Father{<br>}</p><pre><code>上面代码定义了一个Father类，该类通过extends关键字继承了Child类的所有属性和方法，由于内部没有添加代码，所有这两个类完全一样，等于复制了一个Child类</code></pre><p>class Child extends Father{<br>    constructor(x,y,color){<br>        super(x,y);//调用父类的constructor(x,y)<br>        this.color = color<br>    }<br>    toString(){<br>        return this.color + ‘’+super.toString();//调用父类的toString<br>    }<br>}</p><pre><code>上面代码中，constructor方法和toString方法之中都出现了super'关键字，它在这里表示父级的构造函数，用来新建父级的this对象&gt; 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例和方法后在对其进行加工，加上子类自己的实例属性和方法，如果不调研super方法，子类就得不到this对象</code></pre><p>class Father{}</p><p>class Child extends Father{<br>    constructor(){<br>    }<br>}<br>let Ch = new Child()//ReferenceError<br>//构造函数中没有调用super方法</p><pre><code>- ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))。- ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法加到this上面，然后再用子类的构造函数修改this- 如果子类没有定义constructor方法，这个方法会被默认添加- 在子类的构造函数中，只有调用super之后才可用this关键字。这是因为子类实例的构建基于父类实例，只有super方法才能调用父类实例，下列代码中子类的constructor方法没有调用super直线使用this关键字会报错，放在super方法后就是对的</code></pre><p>class Father{<br>    constructor(x,y){<br>        this.x = x;<br>        this.y = y;<br>    }<br>    class Child extends Father{<br>        constructor(x,y,age){<br>            this.age = age;//ReferenceError<br>            super(x,y);<br>            this.age = age; //true<br>        }<br>    }<br>}<br>let ch = new Child(25,8,18);</p><p>ch instanceof Child;//true<br>ch instanceof Father;//true<br>//实例对象ch同时是Child和Father两个类的实例，与es5的行为完全一致</p><pre><code>&gt; 父类的静态方法也会被子类继承</code></pre><p>class Father{<br>    static hello(){<br>        console.log(‘hello world’)<br>    }<br>}<br>class Child extends Father{<br>}<br>Child.hello()//hello world<br>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this/apply/call/bind</title>
      <link href="/2021/09/25/paper-this/"/>
      <url>/2021/09/25/paper-this/</url>
      
        <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><blockquote><p>es5中，<strong>this永远指向最后调用它的对象</strong></p></blockquote><pre><code>var name = 'windowsName';var a = {    name:null,    fn:function(){        console.log(this.name); //windowsName    }}var f = a.fn;f();</code></pre><p>虽然将a对象的fn方法赋值给变量f了，但是没有调用所以fn()，最后仍然是被window调用的</p><h1 id="怎么改变this指向"><a href="#怎么改变this指向" class="headerlink" title="怎么改变this指向"></a>怎么改变this指向</h1><h2 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h2><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        //匿名函数没有自己的this        setTimeout(function(){            this.func1()        },100);    }};a.func2() //this.func1 is not a function</code></pre><p>不使用箭头函数的情况下是会报错的，因为最后调用setTimeout的对象是window，window中没有func<br>函数</p><p>使用箭头函数后</p><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(()=&gt;{            this.func1()        },100);    }};a.func2() //csl</code></pre><p>箭头函数的this始终指向<strong>函数定义时</strong>的this，而非执行时。    </p><blockquote><p>箭头函数中没有this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this为undefined</p></blockquote><h2 id="2-在函数内部使用-this-this"><a href="#2-在函数内部使用-this-this" class="headerlink" title="2.在函数内部使用_this = this"></a>2.在函数内部使用_this = this</h2><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        var _this = this;        //匿名函数没有自己的this        setTimeout(function(){            _this.func1()        },100);    }};a.func2() //csl</code></pre><p>设置var _this = this，这里的this是调用func2的对象a，防止在func2中的setTimeout被window调用，这样在func2中我们使用_this就是指向对象a了</p><h2 id="3-new实例化一个对象"><a href="#3-new实例化一个对象" class="headerlink" title="3.new实例化一个对象"></a>3.new实例化一个对象</h2><h2 id="4-使用apply，call，bind"><a href="#4-使用apply，call，bind" class="headerlink" title="4.使用apply，call，bind"></a>4.使用apply，call，bind</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.apply(a),100);    }};a.func2() //csl</code></pre><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.call(a),100);    }};a.func2() //csl</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.bind(a)(),100);    }};a.func2() //csl</code></pre><h1 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h1><h2 id="apply定义"><a href="#apply定义" class="headerlink" title="apply定义"></a>apply定义</h2><blockquote><p>apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组或类数组提供的参数<br>语法：<code>func.apply(thisArg,[argsArray])</code></p></blockquote><ul><li>this.Arg:在func函数运行时指定的this值。<blockquote><p>需要注意的是指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动之乡全局对象，同时值为原始值的this会指向该原始值的自动包装对象</p></blockquote></li><li>argsArray:一个数组或者类数组对象，其中数组元素将作为单的的参数传给func函数<blockquote><p>如果该参数的值为null或undefined，则表示不需要传入任何参数，从es5中开始可以使用类数组对象</p></blockquote></li></ul><h2 id="apply-call的区别"><a href="#apply-call的区别" class="headerlink" title="apply/call的区别"></a>apply/call的区别</h2><p>apply和call基本类似，它们的区别只是传入的参数不同</p><ul><li>call的语法为:<code>func.call(thisArg[,arg1[,arg2[,...]]])</code></li><li>call方法接受的是若干个参数列表，而apply接受的是一个包含多个参数的数组</li></ul><p>apply():</p><pre><code>var a = {    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.apply(a,[1,2]); //3</code></pre><p>call():</p><pre><code>var a = {    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.call(a,1,2); //3</code></pre><h2 id="apply-call-bind区别-1"><a href="#apply-call-bind区别-1" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h2><blockquote><p>bind方法创建一个新的函数，当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列<br>bind是创建一个新函数，我们必须手动调用</p></blockquote><pre><code>var a ={    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.bind(a,1,2)() //3</code></pre><h1 id="js的函数调用"><a href="#js的函数调用" class="headerlink" title="js的函数调用"></a>js的函数调用</h1><h2 id="1-作为一个函数调用"><a href="#1-作为一个函数调用" class="headerlink" title="1.作为一个函数调用"></a>1.作为一个函数调用</h2><pre><code>var name = 'windowsName';function a(){    var name = 'csl';        console.log(this.name); //windowsName    console.log('inner'+this);  //inner:window}a();console.log('outer'+this)   //outer:window</code></pre><p>这是一个最简单的函数，不属于任何一个对象，它在js的非严格模式属于window，严格模式就是undefined</p><h2 id="2-函数作为方法调用"><a href="#2-函数作为方法调用" class="headerlink" title="2.函数作为方法调用"></a>2.函数作为方法调用</h2><pre><code>var name = 'windowsName';var a = {    name:'csl',    fn:function(){        console.log(this.name); //csl    }}a.fn()</code></pre><p>定义一个对象a，对象a有属性name和一个方法fn，对象a调用了fn方法，所以this指向a的</p><h2 id="3-使用构造函数调用函数"><a href="#3-使用构造函数调用函数" class="headerlink" title="3.使用构造函数调用函数"></a>3.使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了new,看起来就像是创建了新的函数，但实际上是新创建的对象，所以this会指向新创建的对象</p></blockquote><pre><code>function myFunction(arg1,arg2){    this.firstName = arg1;    this.lastName = args2;}var a = new myFunction('cheng','sl');a.lastName; //'sl'</code></pre><p>扩展：<br>new的过程:</p><ul><li>创建一个空对象obj</li><li>将新建的空对象的隐式原型指向其构造函数的显示原型</li><li>使用call改变this指向</li><li>如果无返回值或返回一个非对象值，则将obj返回作为新对象；如果返回值是一个新对象的话直接返回该对象<br>伪代码表述如下：<br>```<br>var a = new myFunction(‘cheng’,’sl’);</li></ul><p>new myFunction{<br>    var obj = {};<br>    obj.<strong>proto</strong> = myFunction.prototype;<br>    var result = myFunction.call(obj,’cheng’,’sl’);<br>    return typeof result === ‘obj’?result:obj;<br>}</p><pre><code>## 4.作为函数方法调用函数(call,apply)&gt; js中，函数是对象，对象有自己的属性和方法，则函数也有它的属性和方法，call，apply是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身- js严格模式下，调用函数时第一个参数会成为this的值，即使这个参数不是一个对象- js非严格模式下，如果第一个参数的值是null或undefined，它将使用全局对象替代</code></pre><p>var name = ‘windowsName’;<br>function fn(){<br>    var name = ‘csl’;<br>    innerFunction()；<br>    function innerFunction(){<br>        console.log(this.name);<br>    }<br>}<br>fn()</p><pre><code>这里的innerFunction()的调用属于第一种作为函数调用的方式，它没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下this就是指向window的</code></pre><p>var name = ‘windowsName’;<br>var a = {<br>    name:’csl’,</p><pre><code>func1:function(){    console.log(this.name)},func2:function(){    setTimeout(function(){        this.func1()    },100)}</code></pre><p>};<br>a.func2() //this.func1 is not a function</p><p>```<br>上面的例子可以简单理解为<strong>匿名函数的this永远只需window</strong>。<br>匿名函数都是自执行的，就是在匿名函数后面加()让其自执行，虽然匿名函数不能被其他对象调用，但是可以被函数调用，比如例子中的setTimeout</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量作用域、闭包、js函数执行流程</title>
      <link href="/2021/09/24/paper-closure/"/>
      <url>/2021/09/24/paper-closure/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><blockquote><p>当一个函数是在另一个函数中创建的时，该函数就称为嵌套的</p></blockquote><pre><code>function sayHiBye(firstName,lastName){    function getFullName(){        return firstName + '' + lastName;    }    alert('Hello,' + getFullName());    alert('Bye' + getFullName())}</code></pre><p>这里创建的嵌套函数getFullName()是为了更加方便访问到外部变量，因此可以返回全名，<br>也可以作为一个新对象的属性或结果返回一个嵌套函数（如下代码），之后可以在其他地方调用，不论在哪调用，它仍然可以访问相同的外部变量</p><pre><code>function makeCounter(){    let count = 0;    return function(){        return count++;    };}let counter = makeCounter();alert(counter());//0alert(counter());//1 可以累加</code></pre><h2 id="词法环境-Lexical-Environment"><a href="#词法环境-Lexical-Environment" class="headerlink" title="词法环境(Lexical Environment)"></a>词法环境(Lexical Environment)</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><p>js中，每个运行的函数，代码块以及整个脚本都有一个被称为词法环境的内部关联对象  </p></blockquote><p>词法环境对象由两部分组成    </p><ul><li>环境记录(Environment Record) 一个存储所有局部变量作为其属性(例如this的值)的对象</li><li>对外部词法环境的引用，与外部代码相关联    </li></ul><blockquote><p>一个变量只是环境记录这个特殊对象的一个属性，获取或修改变量相当于获取或修改词法环境的一个属性</p></blockquote><p>下面的图片中，矩形表示环境记录(变量存储)箭头表示外部引用，全局词法环境没有外部引用，所以箭头指向了null<br><img src="/2021/09/24/paper-closure/1.jpg" alt="alt"></p><p>下图演示了执行过程中<strong>全局词法环境</strong>的变化</p><ul><li>最初它们处于未初始化(Uninitalized)状态，在let声明前，不能引用它</li><li>let声明，但没赋值</li><li>phrase被赋值</li><li>phrase的值被修改<br><img src="/2021/09/24/paper-closure/2.jpg" alt="alt"></li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote><p>一个函数也是一个值，与变量不同的是<strong>函数声明的初始化会被立即完成</strong></p></blockquote><p>当创建了一个词法环境时，函数立即变得可用，这就是我们为什么可以在函数声明的定义之前调用函数声明</p><p>下图是添加一个函数时全局词法状态的初始状态<br><img src="/2021/09/24/paper-closure/3.jpg" alt="alt"></p><h3 id="内部和外部的词法环境"><a href="#内部和外部的词法环境" class="headerlink" title="内部和外部的词法环境"></a>内部和外部的词法环境</h3><blockquote><p>当函数被调用时，会自动创建一个新的词法环境来存储这个调用的局部变量和参数</p></blockquote><p>如下图，我们有两个词法环境：内部(函数)和外部(全局)，当调用say函数时，它会<strong>先搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，直到全局词法环境</strong><br><img src="/2021/09/24/paper-closure/4.jpg" alt="alt"></p><p>搜索过程如下：</p><ul><li>对于name变量，当say中的alert试图访问name时，会立即在内部词法环境中找到它</li><li>当它试图访问phrase时，内部无phrase，使用它顺着<strong>对外部词法环境的引用</strong>找到了它<br><img src="/2021/09/24/paper-closure/5.jpg" alt="alt"></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>闭包是指内部函数总是可以访问其所在的外部函数中的变量和参数，除了构造函数，其他的js函数都是天生闭包的，也就是说js函数会通过隐藏的[[Evironmrnt]]属性记住它们创建的位置，所以它们可以访问外部变量<br>返回文初的<code>makeCounter</code>这个例子</p></blockquote><pre><code>function makeCounter(){    let count = 0;    return function(){        return count++    };}let counter = makeCounter()</code></pre><p>在每次调用makeCount之前都会创建一个新的词法环境对象，以存储该makeCounter运行时的变量<br>因此，我们有两层的词法环境，还有一个未被使用的嵌套函数return count++，它依旧有一个名为[[Environment]]的隐藏属性，该属性保存了对创建该函数的词法环境的引用，因此，counter.[[Environment]]有对{content:0}词法环境的引用<br>当调用counter()时，会为该引用创建一个新的词法环境<br><img src="/2021/09/24/paper-closure/6.jpg" alt="alt"><br>当counter()中的代码查找count变量时，它会先搜索自己的词法环境(空),然后是外部makeCounter()的词法环境在哪里找到就在哪里修改(下图中是在count那里修改的变量)<br>如果我们调用多次counter()，count变量将会增加到2，3<br><img src="/2021/09/24/paper-closure/7.jpg" alt="alt"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul><li><p>函数<strong>调用完之后</strong>会将词法环境中的所有变量从内存中删除</p></li><li><p>如果有一个乔涛的函数在函数结束后仍可达，则它具有引用词法环境的[[Environment]]属性，例子如下</p><pre><code>function f(){  let value = 123;  return function(){      alert(++value);  }}let g = f();//g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用g();g();g(); //多次调用并且返回的函数被保存，所以相应的词法环境也会保留在内存中</code></pre><p>当词法环境对象变得不可达时，他就会死去，它仅在至少有一个乔涛韩束引用它时才会存在</p></li></ul><h2 id="一些闭包的例子"><a href="#一些闭包的例子" class="headerlink" title="一些闭包的例子"></a>一些闭包的例子</h2><h3 id="函数会选择最新的内容吗"><a href="#函数会选择最新的内容吗" class="headerlink" title="函数会选择最新的内容吗"></a>函数会选择最新的内容吗</h3><pre><code>let name = 'John';function sayHi(){    alert('Hi' + name);}name = 'Pete';sayHi();</code></pre><ul><li>函数将从内向外依次寻找目标变量，变量在全局中</li><li>name = ‘Pete’相当于给name重新赋值，这个函数使用最新的值</li></ul><h3 id="哪些变量可用"><a href="#哪些变量可用" class="headerlink" title="哪些变量可用"></a>哪些变量可用</h3><p><code>makeWorker</code>函数是否可以从它被创建的位置或者调用位置访问外部变量</p><pre><code>function makeWorker(){    let name = 'Pete';    return function(){        alert(name);    };}let name = 'John';let work = makeWorker();work()//pete</code></pre><h3 id="反复调用counter实例的方法时"><a href="#反复调用counter实例的方法时" class="headerlink" title="反复调用counter实例的方法时"></a>反复调用counter实例的方法时</h3><pre><code>function Counter(){    let count = 0;    this.up = function(){        return ++count    }    this.down = function(){        return --count;    }}let counter = new Counter();console.log(counter.up());console.log(counter.down());console.log(counter.up());</code></pre><ul><li>这两个嵌套函数都是在同一个词法环境中创建的，使用它们可以共享对同一个count变量的访问，</li><li>使用前置自增++x，操作数x 将在自增后返回，所以第一个是1第二个是2，第三个是1</li></ul><h3 id="if内的函数"><a href="#if内的函数" class="headerlink" title="if内的函数"></a>if内的函数</h3><pre><code>let phrase = 'Hello';if(ture){    let user = 'John';    function sayHi(){        alert(`${phrase},${user}`)    }}sayHi();</code></pre><ul><li>sayHi是在if内声明的，所以它只存在于if中外部是没有sayHi的</li></ul><h3 id="不可见变量"><a href="#不可见变量" class="headerlink" title="不可见变量"></a>不可见变量</h3><pre><code>let x = 1;function func(){    console.log(x);    let x = 2;}func();</code></pre><ul><li>let只在块级作用域下起作用，获取不到全局的x</li><li>并且有暂时性死区，无法变量提升，所以在函数执行时无法获取到下面的x值</li></ul><h1 id="JS函数的执行顺序与闭包"><a href="#JS函数的执行顺序与闭包" class="headerlink" title="JS函数的执行顺序与闭包"></a>JS函数的执行顺序与闭包</h1><blockquote><p>总所周知，JS在栈内存(浏览器一加载就形成了栈内存)中执行函数，函数执行时会形成一个执行上下文（执行栈）并且把执行上下文压缩到栈内存里执行。</p></blockquote><pre><code>var test = (function(i) {    return function() {        alert( i*2 )    }})(2);test(5);</code></pre><p><strong>上述代码的执行流程为：</strong></p><ul><li>先把IIFE<strong>执行后的值</strong>赋值给test，那么它的词法环境中含有：形参i=2，return的function的堆内存地址（因为它指向了一个堆内存地址，这个堆内存在执行，所以它被引用而且不会被回收，形成了闭包）</li><li>假设它执行后return的内存地址为AAAFFF111，这个AAAFFF111指向的堆内存中又含有: 作为函数存储的代码字符串<code>'alert(i*2)'</code>以及作为对象存储的prototype，length形参个数(所以说函数也是对象)，又因为它被保留了引用，所以它不会被回收</li><li>最后执行test(5)，在它的词法环境中没有形参i的值，所以它会去它的上层 作用域中寻找i，找到了上述第一个执行的test的词法作用域并且销毁自身，因为上层作用域不会被销毁，所以输出的值为alert(4)即’4’<blockquote><p>总结：所有的引用类型都是一个堆，我们所有的操作都是对堆的内存地址的操作</p></blockquote></li></ul><p><img src="/2021/09/24/paper-closure/function-closure1.jpg" alt="alt"></p><p>下例涉及到的闭包知识并不多</p><pre><code>function Foo(){    getName = function(){        console.log(1);    }    return this}Foo.getName = function() {    console.log(2)}Foo.prototype.getName = function(){    console.log(3)}var getName = function() {    console.log(4)}function getName(){    console.log(5)}Foo.getName();getName();Foo().getName();getName()new Foo.getName();new Foo().getName();new new Foo().getName();</code></pre><p>分析得</p><ul><li>有var说明是es5的语法应该先考虑变量提升，然后才是代码执行</li><li><code>getName()</code>函数先提升被执行,之后被var getName这个在函数执行阶段执行的函数覆盖</li><li><code>Foo().getName()</code>:Foo()返回的结果再调用getName</li><li><code>new Foo.getName()</code>与<code>new Foo().getName()</code>的区别在于调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" title="default 优先级" target="">优先级</a>不同：圆括号&gt;成员访问(点)=new,当优先级相同时，执行顺序从左往右<br><img src="/2021/09/24/paper-closure/function-closure2.jpg" alt="alt"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/09/20/paper-4/"/>
      <url>/2021/09/20/paper-4/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>一种遵从先进后出（LIFO）原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底</li><li>一摞叠起来的数或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要先将上面的书移走才可以</li><li>栈也被用在编程语言的编译器和内存中保存变量，方法调用<br>```angular2html<br>//在js中使用类来实现一个栈<br>class Stack {</li></ul><p>constructor() {<br>this.items = []<br>}</p><p>// 入栈<br>push(element) {<br>this.items.push(element)<br>}</p><p>// 出栈<br>pop() {<br>return this.items.pop()<br>}</p><p>// 末位<br>get peek() {<br>return this.items[this.items.length - 1]<br>}</p><p>// 是否为空栈<br>get isEmpty() {<br>return !this.items.length<br>}</p><p>// 尺寸<br>get size() {<br>return this.items.length<br>}</p><p>// 清空栈<br>clear() {<br>this.items = []<br>}</p><p>// 打印栈数据<br>print() {<br>console.log(this.items.toString())<br>}<br>        }<br>// 实例化一个栈<br>const stack = new Stack()<br>console.log(stack.isEmpty) // true</p><p>// 添加元素<br>stack.push(5)<br>stack.push(8)</p><p>// 读取属性再添加<br>console.log(stack.peek) // 8<br>stack.push(11)<br>console.log(stack.size) // 3<br>console.log(stack.isEmpty) // false</p><pre><code>## 队列- 与栈相反，队列是一种遵循先进先出(FIFO)原则的一组有序的项，队列在尾部添加新元素，并从头移除元素。最新添加的元素必须排在队列的末尾- 在现实中，最常见的例子就是排队，前面的人优先完成自己的事务，完成之后，下一个人才能继续```angular2htmlclass Queue {constructor(items) {this.items = items || []}enqueue(element){this.items.push(element)}dequeue(){return this.items.shift()}front(){return this.items[0]}clear(){this.items = []}get size(){return this.items.length}get isEmpty(){return !this.items.length}print() {console.log(this.items.toString())}        }const queue = new Queue()console.log(queue.isEmpty) // truequeue.enqueue('John')queue.enqueue('Jack')queue.enqueue('Camila')console.log(queue.size) // 3console.log(queue.isEmpty) // falsequeue.dequeue()queue.dequeue()queue.print() // 'Camila'</code></pre><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li>优先队列是默认队列的修改版。现实生活中的例子就是机场登机的顺序，头等舱和商务舱乘客的优先级要高于经济舱乘客</li><li>优先队列元素的添加和移除是基于优先级的</li><li>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，按照优先级移除它们<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3></li><li>为充分利用向量空间，客服假溢出现象的方法是：将向量想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列。这种循环队列可以以单链表，队列的方式来实际编程应用中来实现<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="JS的数据类型和数据结构"><a href="#JS的数据类型和数据结构" class="headerlink" title="JS的数据类型和数据结构"></a>JS的数据类型和数据结构</h2><h3 id="基本类型（栈stack）"><a href="#基本类型（栈stack）" class="headerlink" title="基本类型（栈stack）"></a>基本类型（栈stack）</h3><pre><code>Number，String，Boolean，Null，Undefind，null（不可用typeof检测），Symbol（ES6中新增）：代表创建后独一无二且不可变的数据类型，它的出现我认为是为了解决可能出现的全局变量冲突的问题</code></pre><h3 id="引用数据类型（堆head）"><a href="#引用数据类型（堆head）" class="headerlink" title="引用数据类型（堆head）"></a>引用数据类型（堆head）</h3><pre><code>Object（包括Array，Function，Data）   </code></pre><h3 id="每个数据都需要一个内存空间"><a href="#每个数据都需要一个内存空间" class="headerlink" title="每个数据都需要一个内存空间"></a>每个数据都需要一个内存空间</h3><table><thead><tr><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>可直接操作保存在栈内存空间的值</td><td>不允许直接访问，不能直接操作</td></tr><tr><td>变量名，值       —&gt;引用</td><td>值</td></tr><tr><td>c，0X0012</td><td>[1,2,3]</td></tr></tbody></table><h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>基本数据类型的值是不可变的</li><li>基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回基本数据类型，不会保存结果</li><li>基本数据类型的赋值是简单赋值，基本数据类型的比较是值的比较</li><li>基本数据类型是存放在栈区的<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li><li>引用类型的值是可以改变的，例如对象就可以通过修改对象属性更改对象</li><li>引用类型可以添加属性方法</li><li>引用类型的赋值是对象引用，声明的变量标识符，存储的只是对象的指针地址</li><li>引用类型的比较是引用（指针地址）的比较</li><li>引用类型是同时保存在栈区和堆区中的，栈区保存变量标识符和指向堆内存的地址</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jump项目</title>
      <link href="/2021/09/12/post-name/"/>
      <url>/2021/09/12/post-name/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/09/12/post-name/tagData.gif" alt="alt"></p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><p><code>Object.create(proto,[descriptors])</code></p><ul><li>完全可以取代__proto__</li><li><code>Object.getPrototypeOf(obj)</code> – 返回对象obj的[[Prototype]]</li><li><code>Object.setPrototypeOf(obj,proto)</code> – 将对象的[[prototype]]设置为proto</li></ul><pre><code>let animal = {    eats:true};//常见一个以animal为原型的新对象let rabit = Object.create(animal);alert(rabibit.eats);alert(Object.getPrototypeOf(rabbit) === animal) //true//将rabbit的原型修改为{}Object.setPrototypeOf(rabbit,{})</code></pre><ul><li>Object.create有一个可选的第二参数：属性描述器，我们可以在此处为新对象提供额外的属性<pre><code>let animal = {  eats:true}let rabbot = Object.create(animal,{  jumps:{      value:true  }});alert(rabbit.jumps); //true</code></pre></li><li>使用Object.create来实现克隆一个对象的所有描述符<br><code>let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo报错总结</title>
      <link href="/2021/09/12/paper-3/"/>
      <url>/2021/09/12/paper-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从零开始搭建hexo到安装theme主题这段比较顺利，到安装主题之后开始出现错误</p></blockquote><h2 id="1-Error-no-such-file-or-directory-scandir-‘…-’"><a href="#1-Error-no-such-file-or-directory-scandir-‘…-’" class="headerlink" title="1. Error:no such file or directory,scandir ‘….’"></a>1. Error:no such file or directory,scandir ‘….’</h2><p>加入主题之后运行所有hexo命令都会报如下错误<br><img src="/2021/09/12/paper-3/image2.png" alt="alt"><br>排查之后，blog主题这一栏填成了别人主题的theme地址，直接写上theme主题名字就行了<br><img src="/2021/09/12/paper-3/img3.png" alt="alt"><br>接着除了hexo-d其他命令都能运行</p><h2 id="2-spawn-failed"><a href="#2-spawn-failed" class="headerlink" title="2.spawn failed"></a>2.spawn failed</h2><p>用hexo-d更新的时候报错 <code>spawn failed</code><br>检查了自己的github ssh地址 显示：but Github does not provide shell access<br>更改myblog目录下的config.yml的repo<br><img src="/2021/09/12/paper-3/img4.png" alt="图片无法加载sorry"></p><h2 id="3-not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#3-not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="3.not a git repository (or any of the parent directories): .git"></a>3.not a git repository (or any of the parent directories): .git</h2><blockquote><p>暂时不太清楚这个的报错原因，可能是当时服务器的问题，第二天登了之后就好了</p></blockquote><p><img src="/2021/09/12/paper-3/img7.png" alt="图片alt"></p><h2 id="4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…"><a href="#4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…" class="headerlink" title="4.can not read a block mapping entry ;a multiline key may not be an implicit key ….."></a>4.can not read a block mapping entry ;a multiline key may not be an implicit key …..</h2><p>上传paper.md的时候报错<br><img src="/2021/09/12/paper-3/img10.png" alt="图片alt"><br>因为paper.md标题中的语法不是很规范，冒号后面没有加空格，及config.yml中的语法也该如此<br>正确书写应该是tags： js<br><img src="/2021/09/12/paper-3/img11.png" alt="图片alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout与setInterval</title>
      <link href="/2021/08/29/paper-1/"/>
      <url>/2021/08/29/paper-1/</url>
      
        <content type="html"><![CDATA[<h1 id="setTimeout与setInterval"><a href="#setTimeout与setInterval" class="headerlink" title="setTimeout与setInterval"></a>setTimeout与setInterval</h1><blockquote><p>有时我们并不想立即执行一个函数而是等待特定一段时间后再执行。这就是所谓的’计划调用(scheduling a call)’<br>目前有两种方法可以实现：</p></blockquote><ul><li>setTimeout：允许我们将函数推迟到一段时间间隔之后再执行</li><li>setInterval：允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数</li></ul><h1 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h1><p>语法：<code>let timerId= setTimeout(func|code,[delay],[arg1],[arg2],...)</code></p><ul><li><code>func|code</code>:想要执行的函数或代码字符串，一般传入的都是函数</li><li><code>delay</code>:执行前的延时，毫秒为单位1ms = 1s；</li><li><code>arg1,arg2...</code>:要传入被执行函数的参数列表<br>例如下面这个示例中sayHi()方法会在1s后执行：<pre><code>function sayHi(phrase,who){  alert(phrase + ',' + who);}setTimeout(sayHi,1000,'hello','neo');//hello,neo</code></pre>如果第一个参数传入的是字符串，js会自动为其创建一函数<pre><code>setTimeout('alert('hello')',1000);//建议使用箭头函数代替它们setTimeout(()=&gt; alert('hello'),1000);</code></pre></li><li>setTimeout传入的函数参数一般不需要加上括号<code>setTimeout(sayHi(),1000)//false</code>;</li><li>setTimeout期望得到一个对函数的<strong>引用</strong>，加上括号明显是在执行函数，实际上传入setTimeout的是函数的执行结果</li></ul><h2 id="clearTimeout取消调度"><a href="#clearTimeout取消调度" class="headerlink" title="clearTimeout取消调度"></a>clearTimeout取消调度</h2><p>语法：<code>let timerId = setTimeout(...); clearTimeout(timerId)</code></p><h1 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h1><ul><li>语法和setTimeout相同:<code>let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</code></li><li>参数的意义也相同，不过与setTimeout只执行一次不同，setInterval是每间隔给定的时间周期性执行。</li><li>想要阻止后续调用，我们需要调用<code>clearInerval(timerId)</code></li></ul><pre><code>//每2s重复一次let timerId = setInterval(() =&gt; alert('t'),2000);//5s后停止setTimeout(()=&gt; {clearInterval(timerId);alert('stop');},5000);</code></pre><ul><li>在大多数浏览器中，在显示<code>alert/confirm/prompt</code>弹窗时，内部的定时器仍然会继续进行</li><li>如果在一定时间内没有关掉alert弹窗下一个alert会立即显示且两次alert的时间间隔小于2s</li></ul><h1 id="嵌套的setTimeout"><a href="#嵌套的setTimeout" class="headerlink" title="嵌套的setTimeout"></a>嵌套的setTimeout</h1><p>setInterval</p><pre><code>let timerId = setInterval(() =&gt; alert('tick'),2000);</code></pre><p>相当于setTimeout在当前这一次函数执行完时立即调度下一次调用</p><pre><code>let timerId = setTimeout(function tick(){    alert('tick');    timerId = setTimeout(tick,2000);},2000);</code></pre><ul><li>嵌套的setTimeout比setInterval灵活得多，采用这种方式可以根据当前执行结果来调度下一次调用</li><li>例如我们要实现一个每间隔5s向服务器发送一个数据请求服务器过载，要降低请求频率将间隔增加到10、20s等<pre><code>let dekay = 5000;let timerId = setTimeout(function request(){  if(request failed due to server overload){      delay *= 2;  }  timerId = setTimeout(request,delay);},delay);</code></pre></li></ul><p><strong>嵌套的setTimeout能够精准地设置两次执行之间的间隔时间而setInterval却不能</strong></p><ul><li><p>setInterval</p><blockquote><p>使用setInterval时，func函数实际调用间隔要比代码中设定的时间间隔要短(&lt;100ms)</p></blockquote><pre><code>let i = 1;setTimeout(function run(){    func()})</code></pre></li><li><p>setTimeout</p><blockquote><p>嵌套的setTimeout就能保证延时的固定(100ms)</p></blockquote><pre><code>let i = 1;setTimout(function run(){    func(i++);    setTimeout(run,100);},100)</code></pre><h2 id="垃圾回收和setInterval-setTimeout回调"><a href="#垃圾回收和setInterval-setTimeout回调" class="headerlink" title="垃圾回收和setInterval/setTimeout回调"></a>垃圾回收和setInterval/setTimeout回调</h2></li><li><p>当一个函数中传入setInterval/setTimeout时，将为其创建一个内部引用，并保存在内存中，<strong>即使这个函数没有被引用，也会保存在内存中不会被销毁</strong></p></li><li><p>对于setInterval传入的函数也是一直存在于内存中直到被clearInternal被调用<br>缺点：</p></li><li><p>如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。</p></li></ul><h1 id="setTimeout-func-0"><a href="#setTimeout-func-0" class="headerlink" title="setTimeout(func, 0)"></a>setTimeout(func, 0)</h1><ul><li>这样调用可以让func尽快执行，但是只有在当前执行的脚本执行完成后，调度程序才会调用它</li><li>该函数被当前脚本执行完之后立即执行,比如下面代码会先输出hello再输出world<pre><code>  setTimeout(()=&gt;alert('world'));  alert('hello')</code></pre><h2 id="零延时实际上不为0"><a href="#零延时实际上不为0" class="headerlink" title="零延时实际上不为0"></a>零延时实际上不为0</h2><blockquote><p>在<strong>浏览器环境</strong>下，嵌套定时器的运行频率是受限制的。根据html5标准所讲：经过5重嵌套定时器之后，事件间隔被强制设置为至少4ms</p></blockquote></li></ul><pre><code>let start = Date.now();let times = [];setTimeout(function run(){    times.push(Date.now() - start);//保存前一个调用的延时    if(start + 100 &lt; Date.now()) alert(times);//100ms后显示延时信息    else setTimeout(run);//否则重新调度    // 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100})</code></pre><ul><li>第一次定时器是立即执行的，接下来就可以看待9,15,20,24两次调用间隔为4ms</li><li>如果我们使用setInterval也会发生类似的情况</li><li>对于服务器端的js就没有这个限制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo用法</title>
      <link href="/2021/08/29/paper/"/>
      <url>/2021/08/29/paper/</url>
      
        <content type="html"><![CDATA[<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><blockquote><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用，插入图片的常用方式，你也可以理解为在 Markdown 中插入图片。</p></blockquote><h2 id="本地绝对路径"><a href="#本地绝对路径" class="headerlink" title="本地绝对路径"></a>本地绝对路径</h2><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 Markdown 语法访问它们。<br><code>![alt](/images/test.jpg)</code></p><h2 id="本地相对路径-本博使用"><a href="#本地相对路径-本博使用" class="headerlink" title="本地相对路径 (本博使用)"></a>本地相对路径 (本博使用)</h2><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中，文章的目录可以通过配置 _config.yml 来生成。配置如下：</p><p><code>post_asset_folder: true</code></p><p>将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。</p><p><code>![alt](test.jpg)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/08/29/hello-world/"/>
      <url>/2021/08/29/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
