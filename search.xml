<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运算符/正则(JS)</title>
      <link href="/2022/01/12/logical-operators/"/>
      <url>/2022/01/12/logical-operators/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><blockquote><p>JS的逻辑运算符有四个，这些运算符可以被应用于任意类型的值，它们的结果也同样可以是任意类型</p></blockquote><h2 id="或"><a href="#或" class="headerlink" title="|| (或)"></a>|| (或)</h2><blockquote><p>如果参与运算的任意一个参数为true，返回的结果就为true，如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算，比如数字1被转化为true，数字0被转化为false</p></blockquote><pre><code>if(1 || 0) {    alert('truthy')}</code></pre><ul><li><p>或运算符寻找第一个真值</p><blockquote><p>一个或运算符的链，将返回第一个真值，如果不存在真值，则返回该链的最后一个值</p></blockquote><pre><code>alert(1 || 0) //1alert(null || 0 || 1) //1alert(undefined || null || 0) // 0</code></pre></li></ul><h2 id="amp-amp-与"><a href="#amp-amp-与" class="headerlink" title="&amp;&amp; (与)"></a>&amp;&amp; (与)</h2><blockquote><p>传统编程中，两个操作数都是真值时与运算符返回true，有一个为假返回false</p></blockquote><pre><code>alert(true &amp;&amp; true) //truealert(false &amp;&amp; true) //false</code></pre><ul><li>与运算符寻找第一个假值</li></ul><blockquote><p>与运算返回第一个假值，如果没有假值就返回最后一个值</p></blockquote><pre><code>alert(1 &amp;&amp; 0); //0alert(1 &amp;&amp; 5); //5</code></pre><ul><li><strong>point</strong><blockquote><p>与运算符(&amp;&amp;)的优先级大于或运算符(||)</p></blockquote></li></ul><h2 id="非"><a href="#非" class="headerlink" title="! (非)"></a>! (非)</h2><blockquote><p>逻辑非运算符接受一个参数且将操作数转化为布尔类型，返回相反的值</p></blockquote><pre><code>alert(!true);//falsealert(!! 'non-empty')//true</code></pre><ul><li><strong>point</strong><br>非运算符!的优先级在所有逻辑运算符里最高</li></ul><h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="?? (空值合并运算符)"></a>?? (空值合并运算符)</h2><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote><p>正则表达式是搜索和替换字符串的一种强大的方式<br>在JavaScript中，正则表达式通过内建的‘RegExp’类的对象来实现</p></blockquote><ul><li><p>表示方法<br>正则表达式包含模式和可选的修饰符，创建一个正则表达式对象有两种语法</p></li><li><p>较长一点的语法</p><pre><code>regexp = new RegExp('pattern','flags')</code></pre></li><li><p>使用’/‘(/会告诉JavaScript我们正在创建一个正则表达式，它的作用类似于字符串的引号)</p><pre><code>regexp = /pattern/;//无修饰符regexp = /pattern/gmi;//有修饰符g、m、i</code></pre></li><li><p>修饰符</p><blockquote><p>正则表达式的修饰符可能会影响搜索结果<br>JavaScript中，有五个修饰符</p></blockquote></li></ul><p>i</p><blockquote><p>使用此修饰符后，搜索是不区分大小写</p></blockquote><pre><code>let str = "I love JavaScript!";alert( str.search(/LOVE/) ); // -1（没找到）alert( str.search(/LOVE/i) ); // 2 (在字符串的第二个位置上找到了love)</code></pre><p>g</p><blockquote><p>使用此修饰符后，搜索时会查找所有的匹配项，而不是第一个</p></blockquote><p>m</p><blockquote><p>多行模式</p></blockquote><p>u</p><blockquote><p>开启完整的unicode支持，该修饰符能够修正对于代理对的处理</p></blockquote><p>y</p><blockquote><p>粘滞模式</p></blockquote><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><blockquote><p>当我们需要将一个类似<code>+7(903)-123-45-67</code>转换为纯数字时，我们就需要查找并删除所有非数字的内容，而字符类可以很好地帮我们解决这个问题<br>字符类(Character classes)是一个特殊的符号，匹配特定集中的任何符号，比如数字类，写为\d，对应任何一个数字</p></blockquote><pre><code>let str = "+7(903)-123-45-67";let regexp = /\d/;alert( str.match(regexp) ); // 7(如果没有标志g，正则表达式仅查找第一个匹配项)</code></pre><pre><code>let str = "+7(903)-123-45-67";let regexp = /\d/g;alert( str.match(regexp) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7// let's make the digits-only phone number of them:alert( str.match(regexp).join('') ); // 79031234567</code></pre><p>常用字符类</p><ul><li><code>\d</code> (digit)<blockquote><p>数字：从0到9的字符</p></blockquote></li><li><code>\s</code> (space)<blockquote><p>空格：包括空格，制表符<code>\t</code>,换行符<code>\n</code>和其他不常见字符比如<code>\v</code>,<code>\f</code>,<code>\r</code></p></blockquote></li><li><code>\w </code>(word)<blockquote><p>单字字符：拉丁字母或数字下划线，非拉丁字母不属于<code>\w</code></p></blockquote></li></ul><pre><code>alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'(每个正则表达式字符类都有对应的结果字符)</code></pre><h2 id="反向类"><a href="#反向类" class="headerlink" title="反向类"></a>反向类</h2><blockquote><p>每个字符类都有一个反向类，用相同的字母表示，但要大写，反向表示与它不匹配的所以字符</p></blockquote><ul><li><p>\D</p><blockquote><p>非数字：例如字母</p></blockquote></li><li><p>\S</p><blockquote><p>非空格符号：例如字母</p></blockquote></li><li><p>\W</p><blockquote><p>非单字字符；例如非拉丁字母或空格</p></blockquote></li></ul><blockquote><p>所以上面删除非数字的电话号码的例子可以变得更加简单比如</p></blockquote><pre><code>let str = "+7(903)-123-45-67";alert( str.replace(/\D/g, "") ); // 79031234567</code></pre><h2 id="点-可以匹配任何字符"><a href="#点-可以匹配任何字符" class="headerlink" title="点(.)可以匹配任何字符"></a>点(.)可以匹配任何字符</h2><blockquote><p>.是一种特殊字符类，它与‘除了换行符之外的任何字符匹配’</p></blockquote><pre><code>let regexp = /CS.4/;alert( "CSS4".match(regexp) ); // CSS4alert( "CS-4".match(regexp) ); // CS-4alert( "CS 4".match(regexp) ); // CS 4 (space is also a character)</code></pre><p>点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：</p><pre><code>alert( "CS4".match(/CS.4/) ); // null, no match because there's no character for the dot</code></pre><p>默认情况下，点与换行符 \n 不匹配,但是当我们希望用点来表示包括换行符在内的所有字符时，需要标志s</p><pre><code>alert( "A\nB".match(/A.B/) ); // null (no match)alert( "A\nB".match(/A.B/s) ); // A\nB (match!)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS的transform属性</title>
      <link href="/2022/01/07/transform/"/>
      <url>/2022/01/07/transform/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们使用CSS进行网页交互时，会经常使用到transform这个属性值，记录一些在项目(小练习中)使用过的transform相关用法</p></blockquote><h1 id="transform-translateY-100"><a href="#transform-translateY-100" class="headerlink" title="transform: translateY(-100%)"></a>transform: translateY(-100%)</h1><blockquote><p>translateY(ty)表示在页面垂直移动元素，对应translate(0,ty)或者translate3d(0,ty,0)</p><blockquote><p><img src="/2022/01/07/transform/translateY.png" alt="alt"></p></blockquote></blockquote><ul><li><p>没有transform前<br>  <img src="/2022/01/07/transform/translateY1.png" alt="alt"></p></li><li><p>translateY<br>  <img src="/2022/01/07/transform/translateY2.png" alt="alt"></p></li><li><p>translateX</p><p>  <img src="/2022/01/07/transform/translateX.png" alt="alt"></p></li></ul><h1 id="transform-scale-1"><a href="#transform-scale-1" class="headerlink" title="transform: scale(1)"></a>transform: scale(1)</h1><blockquote><p>CSS 函数 scale() 用于修改元素的大小。可以通过向量形式定义的缩放值来放大或缩小元素，同时可以在不同的方向设置不同的缩放值</p></blockquote><ul><li>transform:scale(2)-&gt; transform:scale(0)<br>  <img src="/2022/01/07/transform/scale.gif" alt="alt"></li></ul><h1 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h1><blockquote><p>transform-origin CSS属性让你更改一个元素变形的原点。</p></blockquote><ul><li><p>与rotate结合使用<br>  <img src="/2022/01/07/transform/transform-origin.png" alt="alt"></p></li><li><p>与scale结合(相对0 0坐标进行放大)<br>  <img src="/2022/01/07/transform/transform-origin1.png" alt="alt"></p></li><li><p><strong>text-overflow:ellipsis</strong></p></li></ul><h1 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h1><blockquote><p>关键帧 @keyframes 规则通过在动画序列中定义关键帧（或waypoints）的样式来控制CSS动画序列中的中间步骤。和 转换 transition 相比，关键帧 keyframes 可以<strong>控制动画序列的中间</strong>步骤。</p></blockquote><ul><li>加<code>@keyframes</code>前后<br>  <img src="/2022/01/07/transform/key.png" alt="alt"><br>  <img src="/2022/01/07/transform/key.gif" alt="alt"></li></ul><pre><code>    @keyframes rotate {    from {        transform:rotate(0deg);    }    to {        transform:rotate(360deg)    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>January2022</title>
      <link href="/2022/01/04/eng-january/"/>
      <url>/2022/01/04/eng-january/</url>
      
        <content type="html"><![CDATA[<h1 id="word-phrase"><a href="#word-phrase" class="headerlink" title="word/phrase"></a>word/phrase</h1><h2 id="Computer-professional-vocabulary"><a href="#Computer-professional-vocabulary" class="headerlink" title="Computer professional vocabulary"></a>Computer professional vocabulary</h2><ul><li><em>duration</em></li><li><em>format</em></li><li><em>buffer</em></li><li><em>dispatcher</em></li><li><em>offset</em></li><li><em>registry</em></li><li><em>toggle</em></li><li><em>Configuration</em> : Configuration format</li><li><em>Default values</em></li><li><em>Evaluates operands</em></li><li><em>OR</em>:operator</li><li><em>deploy</em></li></ul><h2 id="Social-Human"><a href="#Social-Human" class="headerlink" title="Social/Human"></a>Social/Human</h2><ul><li><em>racial animosity/discrimination</em></li><li><em>hostile force</em></li><li><em>interpretation</em></li><li><em>subsequent</em></li><li><em>ruthlessly</em> : <em>ruthlessly crushes dissent</em></li><li><em>ratio</em></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从render函数到vue的渲染机制</title>
      <link href="/2021/12/26/render/"/>
      <url>/2021/12/26/render/</url>
      
        <content type="html"><![CDATA[<blockquote><p>昨天在github上看到vue-global的一个issue，一个伙计说他不希望看到组件里有DOM元素，所以希望开发者把源码中的render函数从<code>render：h=&gt; h()</code>变为 <code>h=&gt;null</code>，开发者回复他说 : We do rely on it being mounted/removed though as this allows us to turn the listeners on/off with a v-if，看到这个对话勾起了我的疑问关于render和DOM的渲染有什么关系呢</p></blockquote><h1 id="对render渲染函数的官方解释"><a href="#对render渲染函数的官方解释" class="headerlink" title="对render渲染函数的官方解释"></a>对<a href="https://v3.cn.vuejs.org/guide/render-function.html#%E8%99%9A%E6%8B%9F-dom-%E6%A0%91">render渲染函数</a>的官方解释</h1><ul><li>当我们需要高效地更新DOM树上所有的节点时<ul><li>可以写在模板里面比如<code>&lt;h1&gt;{{ blogTitle }}&lt;/h1&gt;</code></li><li>等同于渲染函数：<pre><code>render() { return h('h1',{},this.blogTitle)}</code></pre><blockquote><p>vue中编写可复用的组件是基于render函数</p></blockquote></li></ul></li></ul><h2 id="h"><a href="#h" class="headerlink" title="h()"></a>h()</h2><blockquote><p>我们知道，Vue通过建立一个虚拟DOM来<strong>追踪自己</strong>要如何改变真实DOM，通俗来讲render中的h()返回的就是一个虚拟DOM</p></blockquote><blockquote><p>render的<code>h()</code>函数可以说是一个createNodeDescription，但它返回的是一个虚拟节点(VNode)，也许可以更准确地将其命名为createVNode，它所包含的信息会告诉Vue页面上需要渲染什么样的节点，包括其子节点的描述信息</p></blockquote><ul><li><p>h()函数接收三个参数：</p><ul><li>如果没有prop，通常可以将children作为第二个参数传入，或者将null作为第二个参数传入，children作为第三个参数传入</li></ul><pre><code>h(    //{Str | Obj |Func} (必须)    'div',    //{ Obj } props (与attribute、prop和事件相对应的对象，可选)    {},    //{ Str | Arr | Obj } children (子VNodes，有插槽的对象，可选)     [        'Some text comes first.',        h('h1', 'A headline'),        h(MyComponent, {        someProp: 'foobar'        })     ])</code></pre><ul><li>如果你需要重复很多次的元素/组件，你可以使用工厂函数实现比如：</li></ul><pre><code>//渲染20个段落render() {    return h('div',    Array.from({length:20}).map(() =&gt; {        return h('p','hi')    })    )}</code></pre><ul><li>要为某个组件创建一个VNode传递给h的第一个参数应该是组件本身</li></ul><pre><code>render() {    return h(ButtonCounter)}</code></pre><h2 id="使用render替代template的情况"><a href="#使用render替代template的情况" class="headerlink" title="使用render替代template的情况"></a>使用render替代template的情况</h2></li><li><p>我们需要通过level的prop动态生成heading标签的组件，template的实现形式如下</p><blockquote><p>为了在不同级别的标题中插入锚点元素，我们需要重复使用<code>&lt;slot&gt;&lt;/slot&gt;</code></p></blockquote></li></ul><pre><code>&lt;!-- HTML --&gt;&lt;script type="text/x-template" id="anchored-heading-template"&gt;    &lt;h1 v-if="level === 1"&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h1&gt;    &lt;h2 v-else-if="level === 2"&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h2&gt;    &lt;h3 v-else-if="level === 3"&gt;        &lt;slot&gt;&lt;/slot&gt;    &lt;/h3&gt;&lt;/script&gt;&lt;!-- Javascript --&gt;Vue.component('anchored-heading', {    template: '#anchored-heading-template',    props: {        level: {            type: Number,            required: true        }    }})</code></pre><ul><li>当使用render函数时，将会变得简单很多</li></ul><pre><code>Vue.component('anchored-heading', {    render() {         h (createElement) {            return createElement(            'h' + this.level,   // tag name 标签名称            this.$slots.default // 子组件中的阵列        )    }    },    props: {        level: {            type: Number,            required: true        }    }})</code></pre><h1 id="Vue渲染"><a href="#Vue渲染" class="headerlink" title="Vue渲染"></a>Vue渲染</h1><p> <img src="/2021/12/26/render/vue1.jpg" alt="alt"></p><ul><li>上图从宏观上展示了vue的整体流程。<ul><li><p><code>render</code>函数可以作为一道分割线，<code>render</code>函数的左边可以称之为编译期，将Vue的模板转换为渲染函数。</p><blockquote><p>模板通过编译生成AST,再由AST生成Vue的render函数</p></blockquote></li><li><p><code>render</code>函数的右边是Vue的运行，主要基于渲染函数生成Virtual DOM数，Diff和Patch</p><blockquote><p>渲染函数结合数据生成Virtual DOM树，Diff和Patch后生成新的UI</p><blockquote><p>每个Vue组件都有一个对应的watcher，这个watcher会在组件渲染的时候手机组件所依赖的数据，并在依赖有更新的时候，触发组件重新渲染</p></blockquote></blockquote></li></ul></li></ul><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p><img src="/2021/12/26/render/VNode.png" alt="alt"></p><ul><li>简单来讲,Vue的编译器在编译模板之后，会把这些模板编译成一个渲染函数，当函数被调用的时候就会渲染并且返回一个虚拟DOM树，结合vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的 最小代价并到DOM操作上</li><li>Vue支持我们通过data参数传递一个js对象作为组件数据，然后Vue将遍历此对象属性，使用<code>Object.defineProperty</code>方法描述对象，通过存取函数可以追踪该属性的变更，Vue创建了一层Watch层，在组件渲染的过程中把属性记录为依赖，当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新，如下图：<br><img src="/2021/12/26/render/VDOM1.webp" alt="alt"></li></ul><p>模板到真实DOM过程图：</p><p><img src="/2021/12/26/render/VDOM.webp" alt="alt"></p><p>这里会涉及到Vue的另外两个概念：</p><blockquote><p>独立构建：包含模板编译器，渲染过程HTML字符串 → render函数 → VNode → 真实DOM节点<br>运行时构建：不包含模板编译器，渲染过程render函数 → VNode → 真实DOM节点</p><blockquote><p>运行时构建的包，会比独立构建少一个模板编译器。在$mount函数上也不同。而$mount方法又是整个渲染过程的起始点</p></blockquote></blockquote><p>独立构建流程图<br><img src="/2021/12/26/render/mount1.webp" alt="alt"></p><p>运行时构建<br><img src="/2021/12/26/render/mount2.webp" alt="alt"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回过头来看，Vue中的渲染核心关键的几步流程还是非常清晰的：</p><ul><li>new Vue，执行初始化</li><li>挂载$mount方法，通过自定义render方法、template、el等生成render函数</li><li>通过Watcher监听数据的变化</li><li>当数据发生变化时，render函数执行生成VNode对象</li><li>通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素<br>至此，整个new Vue的渲染过程完毕。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git出现的一些问题</title>
      <link href="/2021/12/24/git2/"/>
      <url>/2021/12/24/git2/</url>
      
        <content type="html"><![CDATA[<h1 id="commit-your-changes-or-stash-them-before-you-can-merge"><a href="#commit-your-changes-or-stash-them-before-you-can-merge" class="headerlink" title="commit your changes or stash them before you can merge"></a>commit your changes or stash them before you can merge</h1><blockquote><p>当老板修改了git之后我再次pull她代码出现了如下情况<br>error: Your local changes to the following files would be overwritten by merge src/components/Demo.vue Please commit your changes or stash them before you merge.<br>stash：藏匿</p></blockquote><p><img src="/2021/12/24/git2/1.jpg" alt="alt"></p><blockquote><p>提示已经很友好了，为了解决它，我们需要使用到一个git stash的指令</p></blockquote><pre><code>git stashgit pullgit stash pop</code></pre><ul><li><code>git stash</code>: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li><code>git stash pop</code>: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li><code>git stash list</code>: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li><code>git stash clear</code>: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。</li></ul><h1 id="There-is-no-tracking-information-for-the-current-branch"><a href="#There-is-no-tracking-information-for-the-current-branch" class="headerlink" title="There is no tracking information for the current branch."></a>There is no tracking information for the current branch.</h1><blockquote><p>对于这种情况有两种解决办法，比如说要操作master，一种是直接指定远程master：</p></blockquote><pre><code>git pull origin master</code></pre><blockquote><p>另外一种方法就是先指定本地master到远程的master，然后再去pull,这样在我们每次想push或者pull的时候，只需要 输入git push 或者git pull即可</p></blockquote><pre><code>git branch --set-upstream-to=origin/master mastergit pull</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router实现组件通信</title>
      <link href="/2021/12/21/vueRouter/"/>
      <url>/2021/12/21/vueRouter/</url>
      
        <content type="html"><![CDATA[<h1 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h1><p>当需要组件之间通信时（父子），有以下几种方式：</p><h2 id="Props-父-gt-子"><a href="#Props-父-gt-子" class="headerlink" title="Props(父->子)"></a>Props(父-&gt;子)</h2><blockquote><p>Vue的设计理念之单向数据流即父子之间的数据传递只能从父-&gt;子，不能逆流，而Prop就是父-&gt;子之间的衔接处<br>Prop是你可以在组件上注册的一些自定义attribute，比如为了给博文组件传递一个标题，我们可以用props选项将其包含在该组件可接受的prop列表中</p></blockquote><pre><code>html&lt;!--可以使用v-bind来动态传递prop--&gt;&lt;div id = "blog-post-demo"&gt;    &lt;blog-post v-for="post in posts"               :key = "post.id"               :title = "post.title"    &gt;&lt;/blog-post&gt;&lt;/div&gt;</code></pre><pre><code>const App = {    data() {        return {            posts: [                {id:1,title:'My journey with Vue'},                {id:2,title:'Blogging with Vue'}                {id:3,title:'Why Vue is so fun'}                ]        }    }}const app = Vue.createApp(App)app.component('blog-post',{    props:['title']    template:`&lt;h4&gt;{{title}}&lt;/h4&gt;`})app.mount('#blog-post-demo')</code></pre><blockquote><p>Since components are reusable instances, they accept the same options as a root instance, such as data, computed, watch, methods, and lifecycle hooks.</p></blockquote><h2 id="emit-子-gt-父"><a href="#emit-子-gt-父" class="headerlink" title="emit(子->父)"></a>emit(子-&gt;父)</h2><blockquote><p>当我们在开发<blog-post>组件时，它的一些功能可能需要与父组件进行沟通，例如我们可能会引入一个按钮来放大博文字号，其他页面保持默认字号</blog-post></p></blockquote><ul><li>父组件中：</li></ul><pre><code>const App = {  data() {    return {      posts: [        /* ... */      ],      postFontSize: 1    }  }}</code></pre><ul><li>通过 <code>@enlarge-text="postFontSize += 0.1</code>监听器，父组件能够接收事件并更新<code>postFontSize</code>的值</li></ul><pre><code>&lt;div id="blog-posts-events-demo"&gt;  &lt;div :style="{ fontSize: postFontSize + 'em' }"&gt;    &lt;blog-post      v-for="post in posts"      :key="post.id"      :title="post.title"       @enlarge-text="postFontSize += 0.1    &gt;&lt;/blog-post&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>现在我们在每篇博文之前添加一个按钮来放大字号，子组件可以通过调用内建的<code>$emit</code>方法并传入事件名称来触发一个事件</li></ul><pre><code>app.component('blog-post', {  props: ['title'],  emit:'enlargeText',//3.x更新版本，可以通过 emits 选项来定义组件可触发的事件  template: `    &lt;div class="blog-post"&gt;      &lt;h4&gt;{{ title }}&lt;/h4&gt;      &lt;button $emit('enlargeText')&gt;        Enlarge text      &lt;/button&gt;    &lt;/div&gt;  `})</code></pre><blockquote><p>但是这种方式需要在父组件里嵌套的子组件里绑定方法，如果我们使用了路由时，子组件占位符则为<code> &lt;router-view&gt;&lt;/router-view&gt;</code>，这个时候则需要使用路由传参</p></blockquote><h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><ul><li><p>我们摒弃了$router这种高耦合写法，取而代之的是props，这样方便你可以在任何地方使用该组件，使得该组件更易于复用测试</p><pre><code>const user = {    props:['id'],    template:'&lt;div&gt;User {id}&lt;/div&gt;'}const router = new VueRouter({    routes:[        {path:'/user/:id',component:User,props:true},        {            path:'user/:id',            components:{default:User,sidebar:Sidebar},            props:{defalt:true,sidebar:false}        }    ]})</code></pre><ul><li>对象模式</li></ul><blockquote><p>如果props是一个对象，它会被按原样设置为组件属性，props是静态的时候有用</p></blockquote><pre><code>const router = new VueRouter({    routes:[        {            path:'/promotion/from-newsletter',            component:Promotion,            props:{ newsletterPopup:false }        }    ]})</code></pre><ul><li>函数模式</li></ul><blockquote><p>创建一个函数返回props,这样你可以将参数转换成另一种类型<br>尽可能保持props函数为<strong>无状态的</strong>，因为它只会在路由发生变化时起作用，如果你需要状态来定义props，请使用<strong>包装组件</strong></p></blockquote><pre><code>const router = new VueRouter({    routes:[        {            //URL/search?q=vue会会将{query:'vue'}作为属性传递给SearchUser组件            path:'/search',            component:SearchUser,            props:route =&gt; ({query: route.query.q})        }    ]})</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vue中优雅地使用css</title>
      <link href="/2021/12/21/vueClass/"/>
      <url>/2021/12/21/vueClass/</url>
      
        <content type="html"><![CDATA[<h1 id="vue中动态添加类"><a href="#vue中动态添加类" class="headerlink" title="vue中动态添加类"></a>vue中动态添加类</h1><p>point:</p><blockquote><p>classList.add(‘active’) : 相当于在原有的类加上一个类,比如<code>&lt;div class = 'click active'&gt;&lt;/div&gt;</code></p></blockquote><p>当有一个需求需要实现点击的时候css可以实现相应的改变</p><ul><li>data</li></ul><pre><code>    data() {      return {        activeClass: -1,// 0为默认选择第一个，-1为不选择         list: [          {title: '全网搜索(100w+)'},          {title: '优惠推荐(包邮10w+)'},        ],      }    },</code></pre><ul><li>html</li></ul><pre><code> &lt;ul class="list"&gt;      &lt;li :span="12" v-for="(v,k) in list" :key="k" :class="activeClass ==k?'active':''"&gt;      &lt;span @click="IsActive(k)"&gt;{{v.title}}&lt;/span&gt;      &lt;/li&gt;    &lt;/ul&gt;</code></pre><ul><li>css</li></ul><pre><code>.active {    border-bottom: 1px solid #FE4520;    color: #FE4520;  }</code></pre><ul><li>methods</li></ul><pre><code>    methods: {      IsActive(k) {        this.activeClass = k;      }    }</code></pre><h2 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h2><pre><code>&lt;div :class="[activeClass, errorClass]"&gt;&lt;/div&gt;data() {  return {    activeClass: 'active',    errorClass: 'text-danger'  }}</code></pre><ul><li>渲染结果为：<pre><code>&lt;div class="active text-danger"&gt;&lt;/div&gt;</code></pre></li></ul><h2 id="在Vue中使用class过渡"><a href="#在Vue中使用class过渡" class="headerlink" title="在Vue中使用class过渡"></a><a href="https://cn.vuejs.org/v2/guide/transitions.html">在Vue中使用class过渡</a></h2><ul><li>过渡的类名<ol><li>v-enter:定义进入过渡的状态</li><li>v-enter-active：定义进入过渡生效时的状态</li><li>v-enter-to：过渡结束状态<pre><code>&lt;div id="example-1"&gt;&lt;button @click="show = !show"&gt;Toggle render&lt;/button&gt;&lt;transition name="slide-fade"&gt;&lt;p v-if="show"&gt;hello&lt;/p&gt;&lt;/transition&gt;&lt;/div&gt;</code></pre><pre><code>new Vue({el: '#example-1',data: { show: true   }})</code></pre><pre><code>/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active { transition: all .3s ease;}.slide-fade-leave-active { transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);}.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ { transform: translateX(10px); opacity: 0;}</code></pre></li></ol></li></ul><h2 id="基于vue-router中的过渡效果"><a href="#基于vue-router中的过渡效果" class="headerlink" title="基于vue-router中的过渡效果"></a><a href="https://router.vuejs.org/zh/guide/advanced/transitions.html#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1">基于vue-router中的过渡效果</a></h2><blockquote><p>同样适用于上述class过渡<br>项目中使用</p></blockquote><pre><code>&lt;transition&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;</code></pre><pre><code>const Parent = {  data () {    return {      transitionName: 'slide-left'    }  },  beforeRouteUpdate (to, from, next) {    const toDepth = to.path.split('/').length    const fromDepth = from.path.split('/').length    this.transitionName = toDepth &lt; fromDepth ? 'slide-right' : 'slide-left'    next()  },  template: `    &lt;div class="parent"&gt;      &lt;h2&gt;Parent&lt;/h2&gt;      &lt;transition :name="transitionName"&gt;        &lt;router-view class="child-view"&gt;&lt;/router-view&gt;      &lt;/transition&gt;    &lt;/div&gt;  `}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>December2021 review</title>
      <link href="/2021/12/07/eng/"/>
      <url>/2021/12/07/eng/</url>
      
        <content type="html"><![CDATA[<h1 id="word-phrase"><a href="#word-phrase" class="headerlink" title="word/phrase"></a>word/phrase</h1><h2 id="December-2021"><a href="#December-2021" class="headerlink" title="December 2021"></a>December 2021</h2><ul><li><p><strong>word</strong></p><ul><li><em>exploring</em>.[n &amp; adj]</li><li><em>variable</em>.[n &amp; adj] ： variable notion of moon</li><li><em>incentive</em>.[n &amp; adj] ：this holiday incentive is no longer necessary</li><li><em>postgraduate</em>.[n &amp; adj] ：Pursue postgraduate studies </li><li><em>colonial</em>.[n &amp; adj] ：Destroy their colonies close by</li><li><em>household</em>.[n &amp; adj]</li><li><em>deputy</em>.[n &amp; adj]</li><li><em>liquid</em>.[n &amp; adj]</li><li><em>intimate</em>.[n &amp; adj]</li><li><em>exterior</em>.[n &amp; adj]</li><li><em>treasure</em>.[n &amp; vt] ： treasure trove</li><li><em>sponsor</em>.[n &amp; vt]</li><li><em>structure</em>.[n &amp; vt]</li><li><em>witness</em>.[n &amp; vt]</li><li><em>dive</em>.[n &amp; vi]</li><li><em>rebel</em>.[n &amp; vi]</li><li><em>conducted</em>.[n &amp; v]</li><li><em>remain</em>.[n &amp; v] : Just over 1,800 pandas remain in the wild, an improvement over the 1,100 thought to live in the wild as recently as 2000.</li><li><em>gather</em>.[vt &amp; vi]</li><li><em>resist</em>.[vt &amp; vi] : people can’t resist the temptation of them</li><li><em>enquire</em>.[vt &amp; vi]</li><li><em>calculate</em>.[vt &amp; vi]</li><li><em>conceive</em>.[vt &amp; vi]</li><li><em>strengthen</em>.[vt &amp; vi] ：Strengthening people’s immunity to <strong>infection</strong></li><li><em>migrate</em>.[vt &amp; vi]</li><li><em>transmit</em>.[vt &amp; vi]</li><li><em>explore</em>.[vt &amp; vi]</li><li><em>negotiate</em>.[vt &amp; vi]</li><li><em>revolve</em>.[vt &amp; vi]</li><li><em>speculate</em>.[vt &amp; vi]</li><li><em>adjust</em>.[vt &amp; vi]</li><li><em>suspend</em>.[vt &amp; vi]</li><li><em>miserable</em>.[adj]</li><li><em>intolerable</em>.[adj] : life become intolerable</li><li><em>credible</em>.[adj]</li><li><em>flourishing</em>.[adj] ：that it developed in this incredible flourishing of this sophisticated technology</li><li><em>sophisticated</em>.[adj]</li><li><em>divers</em>.[adj]</li><li><em>outstanding</em>.[adj]</li><li><em>significant</em>.[adj]</li><li><em>authentic</em>.[adj]</li><li><em>fruitful</em>.[adj]</li><li><em>contented</em>.[adj]</li><li><em>adequate</em>.[adj]</li><li><em>urgent</em>.[adj]</li><li><em>seal</em>.[adj]</li><li><em>instant</em>.[adj]</li><li><em>refined</em>.[adj]</li><li><em>brutal</em>.[adj]</li><li><em>slim</em>.[adj]</li><li><em>converted</em>.[adj]</li><li><em>comprehensive</em>.[adj]</li><li><em>controversial</em>.[adj]</li><li><em>haunting</em>.[adj]</li><li><em>modified</em>.[adj &amp; v]</li><li><em>stripped</em>.[adj &amp; v]</li><li><em>constantly</em>.[adv]</li><li><em>extraordinarily</em>.[adv]</li><li><em>modestly</em>.[adv]</li><li><em>ethically</em>.[adv]</li><li><em>literally</em>.[adv]</li><li><em>deliberately</em>.[adv]</li><li><em>notably</em>.[adv] : an albacore are no longer classified as critically endangered</li><li><em>critically</em>.[adv]</li><li><em>backward</em>.[adj &amp; adv]</li><li><em>astonishing</em>.[adj &amp; adv]</li><li><em>restrictive</em>.[adj &amp; adv &amp; n]</li><li><em>further</em>.[adj &amp; adv &amp; vt] ： Further reducing old patients’medical expenses</li><li><em>reveal</em>.[vt]</li><li><em>eliminate</em>.[vt]</li><li><em>put off</em>.[vt]</li><li><em>represent</em>.[vt]</li><li><em>renovate</em>.[vt]</li><li><em>occupy</em>.[vt] ： occupy in</li><li><em>thrive</em>.[vi]</li><li><em>evaluate</em>.[vi]</li><li><em>comply</em>.[vi] : <strong>comply with</strong> state laws</li><li><em>underestimate</em>.[vt &amp; n]：I guess you underestimated how difficult it would be the first time，didn’t you？</li><li><em>capture</em>.[vt &amp; n]</li><li><em>mandate</em>.[vt &amp; n]</li><li><em>digest</em>.[vt &amp; vi &amp; n]</li><li><em>format</em>.[vt &amp; vi &amp; n] ： test format</li><li><em>breed</em>.[vt &amp; vi &amp; n] : It’s breeding ground are now better <strong>preserved</strong></li><li><em>load</em>.[vt &amp; vi &amp; n]</li><li><em>stack</em>.[vt &amp; vi &amp; n]</li><li><em>track</em>.[vt &amp; vi &amp; n]</li><li><em>fragment</em>.[vt &amp; vi &amp; n]</li><li><em>contrast</em>.[vt &amp; vi &amp; n]</li><li><em>knot</em>.[vt &amp; vi &amp; n]</li><li><em>trace</em>.[vt &amp; vi &amp; n]</li><li><em>gain</em>.[vt &amp; vi &amp; n]</li><li><em>ladder</em>.[vt &amp; vi &amp; n]</li><li><em>survey</em>.[vt &amp; vi &amp; n]</li><li><em>filter</em>.[vt &amp; vi &amp; n]</li><li><em>demand</em>.[vt &amp; vi &amp; n]</li><li><em>court</em>.[vt &amp; vi &amp; n]</li><li><em>tracked</em>.[adj &amp; v]</li><li><em>relieved</em>.[adj &amp; v]</li><li><em>correct</em>.[adj &amp; vt &amp; vi]</li><li><em>mature</em>.[adj &amp; vt &amp; vi]</li><li><em>humble</em>.[adj &amp; vt]</li><li><em>properly</em>.[adv]</li><li><em>petrol</em>.[n]</li><li><em>relief</em>.[n] ：It’s such a relief to pass</li><li><em>maintenance</em>.[n]</li><li><em>authority</em>.[n]</li><li><em>corner</em>.[n]</li><li><em>extinction</em>.[n]</li><li><em>breakthrough</em>.[n] ：make a breakthrough technology </li><li><em>prediction</em>.[n] weather prediction</li><li><em>precision</em>.[n] precision machining</li><li><em>registration</em>.[n] ： marriage registration office</li><li><em>procedure</em>.[n]</li><li><em>tuition</em>.[n]</li><li><em>chess</em>.[n] : national chess</li><li><em>dominance</em>.[n]</li><li><em>nostalgia</em>.[n]</li><li><em>legislation</em>.[n] ：Michigan lawmakers have introduced legislation that could make their state the best place in the country</li><li><em>interaction</em>.[n] </li><li><em>outcome</em>.[n]</li><li><em>substance</em>.[n] </li><li><em>submission</em>.[n] </li><li><em>adaptation</em>.[n]</li><li><em>habitat</em>.[n]</li><li><em>principle</em>.[n] ： In principle</li><li><em>summit</em>.[n]</li><li><em>intention</em>.[n]</li><li><em>governor</em>.[n] :  In Washington State, Governor Jay Inslee <strong>signed</strong> a law that bans polystyrene products</li><li><em>landmark</em>.[n] : California passed landmark bills that</li><li><em>volumes</em>.[vt &amp; vi &amp; n &amp; adj] : companies keep <strong>large volumes of</strong> records</li><li><em>fleet</em>.[vt &amp; vi &amp; n &amp; adj] ： even set on-demand fleets of self-driving cars</li><li><em>joint</em>.[vt &amp; vi &amp; n &amp; adj] : By the summit’s end, the U.S and China had made a surprise <em>joint declaration</em> to work together on meeting the goals of the Paris Agreement</li><li><em>quadruple</em>.[vt &amp; vi &amp; n &amp; adj] :  the fastest <strong>year-on-year-growth</strong> since the 1970s, while in the U.S., a new report found that it had nearly quadrupled over the last decade.</li></ul></li><li><p><strong>phrase</strong></p><ul><li><em>spending time doing sth</em></li><li><em>valueless work <strong>could be + adj/Ved</strong></em></li><li><em>attempt to do</em>  : They abandoned the attempt to roast coffee beans in space.</li><li><em>addiction to</em></li><li><em>ranging from</em></li><li><em>check up on</em>  :  checking up on you all the time</li><li><em>dispose of</em>  :  Dispose of their trash properly</li><li><em>to some extent</em></li><li><em>broaden one’s horizon</em></li><li><em>split into</em></li><li><em>until this point</em> ：previous experts had been able to model the back of the mechanism up until this point</li><li><em>donzens of</em></li><li><em>rushing to</em> ： So people who are rushing to register for marriage can relax</li><li><em>struggling to</em> : His students were struggling to follow his lessons</li><li><em>in a bid to</em> </li><li><em>separate into/divide into</em> </li><li><em>look back on sth</em>  : look back on their good old days</li><li><em>present with</em> ： they presented the elderly with fresh fruits before diving themselves into two groups</li><li><em>pure water</em> </li><li><em>way to do/way of doing sth/method of doing/approach to + n</em></li><li><em>be equivalent to</em></li><li><em>in certain</em> ： in certain individuals</li><li><em>on schedule</em> </li><li><em>be responsible for</em></li><li><em>powered by</em> : the two declarations are part of a plan to have the U.S powered by a clean grid by 2035</li><li><em>a raft of</em> : The last 12 months <strong>saw</strong> a raft of legislation to reduce growing plastic pollution</li><li><em>amoing other things</em></li></ul></li></ul><h1 id="Theme-n"><a href="#Theme-n" class="headerlink" title="Theme(n)"></a>Theme(n)</h1><h2 id="科技-未来-Technology"><a href="#科技-未来-Technology" class="headerlink" title="科技/未来(Technology)"></a>科技/未来(Technology)</h2><ul><li><em>solar panel</em></li><li><em>Auto-pilot</em></li><li><em>x-ray</em></li><li><em>automobile innovation</em></li></ul><h2 id="自然-环境-环保"><a href="#自然-环境-环保" class="headerlink" title="自然/环境/环保"></a>自然/环境/环保</h2><ul><li><em>Commercial hunting</em></li><li><em>Decreasing birthrates</em></li><li><em>cut fossil fuels/methane/carbon emissions</em></li><li><em>single-use utensils</em></li><li><em>recycled content</em></li><li><em>iconic species</em></li><li><em>environmental movement</em></li></ul><h2 id="文化-社会"><a href="#文化-社会" class="headerlink" title="文化/社会"></a>文化/社会</h2><ul><li><em>sharing economy</em></li><li><em>immediate effect</em></li><li><em>annual leave bonus</em></li><li><em>senior center</em></li><li><em>Hope elementary school</em> || <em>junior high school</em> || <em>senior high school</em></li></ul><h1 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h1><h2 id="sentence"><a href="#sentence" class="headerlink" title="sentence"></a>sentence</h2><ul><li><em>The benefits of … are innumerable and mainfold</em></li><li><em>As is known to all</em></li><li><em>Technology has <strong>penetrated into</strong> every corner of modem society</em></li><li><em>This is a massive step forward in the history of technology and science</em></li><li><em>something we take for granted now</em></li><li><em>It is completely astonishing that sb firstly …secondly…</em> || It is completely astonishing that the ancient Greeks Firstly had the conception of making this technology and secondly the ability to actually physically make it</li><li> <em>out of that data has come nearly all the breakthroughs in recent decades ， came the discovery that it predicted eclipses ，that it followed the variable notion of the moon</em></li><li><em>The history of technological development doesn’t go in a straight line</em></li><li><em>in the meanwhile</em></li><li><em>Pursue your true passion don’t compromise</em></li><li><em>for starters，moreover/in addition/in the next place，last but not least</em></li><li><em>never can people ignore the indispensability of the wealth of mind to themselves</em></li><li><em>without the aforementioned belief</em></li><li><em>as the year draws to a close</em></li><li><em>his insatiable need to confirm that fact will be the death of him</em> POI S4E19</li></ul><h2 id="vocabulary-replacement"><a href="#vocabulary-replacement" class="headerlink" title="vocabulary replacement"></a>vocabulary replacement</h2><ul><li>V<ul><li>explain -&gt; Shed light on</li><li>get -&gt; acquire/gain || acquire a good knowledge of | acquire a reputation/gain access to</li><li>reduce -&gt; lighten</li><li>use -&gt; take advantage of</li><li>show -&gt; reveal/mirror</li><li>believe -&gt; admit</li><li>cause -&gt; trigger/contribute to</li><li>replace -&gt; substitute </li><li>develop -&gt; cultivate</li><li>improve -&gt; enhance/boost || improve/boost academic performance</li><li>impede -&gt; hinder || hinder the development of… one’s progress iin</li><li>stop -&gt; cease || ceaseless efforts</li><li>encourage -&gt; motivate/inspire sb to do</li><li>finish -&gt; fulfill || fulfill your dream/ambition/potential</li><li>support -&gt; be in favor of</li><li>object to -&gt; oppose + sth/doing sth</li><li>give -&gt; offer/provide || offer sb sth/offersth to sb  | provide sb with sth/provide sth for sb</li><li>develop -&gt; cultivate</li><li>think -&gt; argue + that (support)</li><li>-&gt;</li></ul></li><li>adj<ul><li>good -&gt; outstanding/advantageous</li><li>bad -&gt; undesirable</li><li>difficult -&gt; demanding</li><li>important -&gt; crucial/significant</li><li>common -&gt; universal || The desire to look attractive is universal</li><li>big -&gt; considerable/tremendous</li><li>most -&gt; the vast majority of</li><li>popular -&gt; well-regarded</li><li>only -&gt; unique</li><li>poor -&gt; needy</li><li>rich -&gt; wealthy/prosperous || prosperous parents = rich and successful</li><li>interesting -&gt; engaging</li><li>boring -&gt; tedious</li><li>helpful -&gt; rewarding/beneficial</li></ul></li><li>adv<ul><li>very -&gt; extremely </li><li>so -&gt; hence </li><li>moreover -&gt; in the meanwhile </li><li>nowadays -&gt; current society</li><li>clearly -&gt; obviously/apparently</li></ul></li><li>n<ul><li>side -&gt; respect</li><li>lack -&gt; shortage</li><li>opinion -&gt; viewpoint</li><li>influence -&gt; effect + on || That will have a salutary effect on their behavior</li><li>influence -&gt; effect || They will have a salutary/devastating effect on their behavior</li><li>people -&gt; individuals</li><li>old people -&gt; the elderly/senior citizens/older folk</li><li>thing -&gt; matter/business</li><li>advantage/disadvantage -&gt; benefit/shortcoming</li><li>mistake -&gt; fault</li><li>reputation -&gt; fame</li><li>ability to do -&gt; capacity for/capability of</li><li>top -&gt; peak</li><li>customer -&gt; client/consumer</li><li>-&gt;</li><li>-&gt;</li></ul></li><li>other<ul><li>about -&gt; with respect to</li><li>because of -&gt; due to</li><li>a series of -&gt; a range of</li><li>a lot -&gt; a great deal || the wealth of the mind contributes a great deal to the society</li><li>all kind of -&gt; a wide range of</li><li>more and more -&gt; enjoy an increasing popularity</li><li>I think -&gt; as far as I concerned/form my perspective</li><li>more and more -&gt; the number of …increases exponentially</li><li>with the development of -&gt; due to the proliferation of …</li><li>try one’s best -&gt; aspire to do</li><li>want sth -&gt; have a strong desire for sth</li><li>sb be interested in sth -&gt; sth generate interest</li><li>in conclusion -&gt; in brief</li><li>there is no doubt that… -&gt; there is no denying that…</li><li>It’s kown to all that -&gt; As is known to all</li><li>consider…as… -&gt; regard…as..</li><li>take care of sb -&gt; attend to sb</li><li>-&gt;</li><li>-&gt;</li><li>-&gt;</li></ul></li></ul><p>参考文献</p><a href="https://dict.eudic.net/webting/videoplay/b6ce89f9-565f-11ec-8804-00505686c5e6" title="default The ancient ‘computer’ that simply shouldn't exist - BBC REEL" target="">The ancient mystery of the world's oldest computer</a><p><a href="https://www.nationalgeographic.com/environment/article/5-environmental-victories-from-2021-that-offer-hope">NationalGeographic</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据劫持</title>
      <link href="/2021/12/06/Data-hijacking/"/>
      <url>/2021/12/06/Data-hijacking/</url>
      
        <content type="html"><![CDATA[<ul><li>思考:实现以下条件成立可行的方法<pre><code>var a = ? //a要如何赋值，才能使下面的if语句成立if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){  console.log(1)}</code></pre></li></ul><ol><li>==进行比较，两边数据类型不同时，有不一样的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality" title="default 转换规则" target="">转换规则</a><blockquote><p>如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。</p></blockquote></li><li>当然我们会想到使用toString方法，并且把a赋值为一个对象，但a只有在它的原型链上能够寻找到toSting方法，它本身是没有toString方法的，所以我们可以手动地给它定义一个toString方法<pre><code>var a = {    toString(){    }}</code></pre></li><li>okay，现在我们可以着手来实现它了,值得注意的一点是：是<code>a.toString()</code>的返回值跟a==1进行比较<pre><code>var a = {    i : 0,    toString(){        return ++this.i; //++i运算后返回     }}if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){console.log('条件成立')}</code></pre><blockquote><p>当然除了上述办法还有其他方法比如：把上述toSting方法改成valueOf，或者<code>var a = [1,2,3]</code> <code>a.toString = a.shift</code>shift方法(删除第一项并返回首位)赋值给toString等等，就不再一一赘述<br>最值得关注的还是：使用<strong>数据劫持</strong>的方法来实现这道奇怪的问题</p></blockquote></li></ol><h1 id=""><a href="#" class="headerlink" title=""></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="default Object.defineProperty()" target="">Object.defineProperty()</a></h1><blockquote><p>当我们获取一个值的时候希望它做些什么事情，当这种情况出现我们可以使用数据劫持(defineProperty/Proxy)，<code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p></blockquote><ul><li>defineProperty：会监听一个属性值</li><li>get():获取属性值</li><li>set()：设置属性值<br>来看一下如何使用数据劫持实现第一道例题<pre><code>var i = 0;Object.defineProperty(window,'a',{  get() {      return ++i;  }});if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3){  console.log('条件成立')  }</code></pre></li><li>首先，我们先监听了window对象下的a属性，并且获取到了a的属性值i，i做的事情就是自增1</li><li>你可能会问，为什么return的是i而不是a，这是因为如果return的是a会触发GETTER拦截器从而导致形成死循环栈内存溢出</li></ul><h2 id="Object-defineProperty-实际应用"><a href="#Object-defineProperty-实际应用" class="headerlink" title="Object.defineProperty()实际应用"></a>Object.defineProperty()实际应用</h2><blockquote><p>在vue2.0中我们就使用到了<code>Object.defineProperty()</code>方法来实现双向数据绑定的原理，以便我们来实现MVVM，下面先写一个简单的实现源码</p></blockquote><pre><code>&lt;body&gt;    姓名：&lt;span id = "spanName"&gt;&lt;/span&gt;    &lt;br&gt;    &lt;input type = "text" id = "inpName"&gt;    &lt;script&gt;        let obj = {        name:''    };    let newObj = JSON.parse(JSON.stringify(obj));//深拷贝对象    Object.defineProperty(obj,'name',{            get() {                return newObj.name;            },            set(val) {                if(val === newObj.name) return;                newObj.name = val;                observer();            }    })    function observer(){            //数据更改影响视图            spanName.innerHTML = obj.name;            inpName.value = obj.name;    }    setTimeout(() =&gt; {            obj.name = "修改了数据"    },1000)    inpName.oninput = function() {            //视图更改影响数据；v-model的操作              obj.name = this.value;    }    &lt;/script&gt;&lt;/body&gt;</code></pre><ul><li>get()获取到newObj.name的属性值，设置获得的属性值到set(val)里,每次设置完执行observer()</li><li>当在setTimeout里修改了obj.name的数据时，会触发set()拿到最新值赋值给val，再执行observer，拿到最新的值更新视图</li><li>oninput是改变的事件，当视图改变的时候把当前视图的值赋给name属性，再触发set属性如上</li></ul><h1 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" title="default Proxy" target="">Proxy</a></h1><blockquote><p>从性能上来说<code>Object.defineProperty()</code>会有一些缺点：<br>1.它需要对原始数据进行克隆。2. 需要分别给对象中的每一个属性设置监听。<br>所以我们拥有了一个更优解<strong>Proxy</strong>，可以完美解决 <code>Object.defineProperty()</code>带来的缺点<br>Proxy用于vue3.0的双向数据绑定</p></blockquote><ul><li>Proxy监听的是整个对象，不需要单独监听一个属性</li><li>prop是当前对象的属性值<pre><code>  let obj = {};  obj = new Proxy(obj,{      get(target,prop) {          return target[prop]      },      set(target,prop,value) {          target[prop] = value;          observer();      }  })</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的深浅克隆及数组扁平化</title>
      <link href="/2021/12/03/deepClone/"/>
      <url>/2021/12/03/deepClone/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浅克隆：只克隆多维数组的第一层，当改变对象的某个属性时另一个对象的对应属性也会发生改变，因为没有克隆它的引用地址，所以它们本质上指向的还是同一个引用地址<br>深克隆：开辟新的堆内存存储数据，两者指向不同的引用地址，修改对象的属性对克隆后的对象没有影响。</p></blockquote><h1 id="一、JSON-stringify-方法实现深克隆"><a href="#一、JSON-stringify-方法实现深克隆" class="headerlink" title="一、JSON.stringify()方法实现深克隆"></a>一、JSON.stringify()方法实现深克隆</h1><ul><li>先把一个对象变为字符串<br>  <code>JSON.Stringify(obj)</code>但是这个方法会把正则、日期都变为空对象</li><li>再把字符串变为对象<br>  <code>JSON.Parse()</code></li></ul><h1 id="二、实现轻量lodash深克隆"><a href="#二、实现轻量lodash深克隆" class="headerlink" title="二、实现轻量lodash深克隆"></a>二、实现轻量lodash深克隆</h1><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>先看看如何实现浅克隆，在浅克隆的基础上实现深克隆，思路如下</p><ul><li>我们只遍历它的私有属性<code>obj.hasOwnProperty(key)</code>(不会上升到原型链)</li><li>私有属性<code>obj[key]</code>赋值给<code>obj2[key]</code></li></ul><pre><code>let obj = {    a:100,    b:[10,20,30],    c:{        x:10    },    d:/^\d+$/};let arr = [10,[100,200],{    x:10,    y:20}]let obj2 = {}for(let key in obj){    if(!obj.hasOwnProperty(key)) break;    obj2[key] = obj[key];}console.log(obj,obj2)</code></pre><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><ul><li>创建一个空对象(new) <code>new obj.constructor</code>(即创建了一个对象，又克隆了它的实例，目的是克隆的结果和之前保持相同的所属类)</li><li>过滤特殊情况(obj进入for in循环前)<ul><li>分情况判断:<code>obj=null</code></li><li>obj=正则</li><li>obj=Data的情况</li></ul></li></ul><pre><code>function deepClone(obj){    if(obj === null) return null;    if(typeof obj !== "object") return obj;    if(obj instanceof RegExp){        return new RegExp(obj);    }    if(obj instanceof Date){        return new Date(obj)    }    let newObj = new obj.constructor;    for(let key in obj){        if(obj.hasOwnProperty(key)){            newObj[key] = deepClon(obj[key])        }    }}</code></pre><h1 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h1><blockquote><p>数组</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/2021/11/24/Garbage-collection/"/>
      <url>/2021/11/24/Garbage-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>《JavaScript高级程序设计》提到两种垃圾回收机制</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>JavaScript 中最常用的垃圾收集方式是标记清除( mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量〉时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进人环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。<br>这种方法引起循环引用的问题：例如： obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</p><pre><code>function fun() {    let obj1 = {};    let obj2 = {};    obj1.a = obj2; // obj1 引用 obj2    obj2.a = obj1; // obj2 引用 obj1}</code></pre><p>这种情况下，就要手动释放变量占用的内存：</p><pre><code>obj1.a =  nullobj2.a =  null</code></pre><h2 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h2><ul><li>意外的全局变量： 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li>被遗忘的计时器或回调函数： 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li>脱离 DOM 的引用： 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>闭包： 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop</title>
      <link href="/2021/11/24/Event-Loop/"/>
      <url>/2021/11/24/Event-Loop/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浏览器是多线程浏览器，js是单线程，浏览器只给了js一个线程来渲染</p></blockquote><ul><li><p>先看一些例子</p><pre><code>async function async1() {  console.log('async1 start');  await async2();  console.log('async1 end')}async function async2() {  console.log('async2')}console.log('script start');setTimeout(function (){  console.log('setTimeout')},0)async1();new Promise(function (resolve){  console.log('Promise1');  resolve();}).then(function() {  console.log('promise2')});console.log('script end')</code></pre><p>以上代码知识点</p><ul><li>进栈=执行（压缩到栈里是执行，执行完之后销毁的移除栈内存，不销毁的移除到栈底）</li><li>主栈是第一个执行，之后执行Event Quque事件队列，事件队列包括宏任务和微任务，微任务先执行，宏任务后执行</li><li>主栈查找事件队列，事件队列执行主栈的过程叫Even Loop</li><li>new Promise时，会立即执行EC函数，new的时候是同步的，但是执行resolve()/reject()时时异步的，当它们执行时会执行then()/catch()中的方法</li><li>所以js栈的执行顺序为 主栈-&gt;微任务队列 -&gt;宏任务队列<blockquote><p>但是微任务队列里函数的执行顺序可就不一定了，在chrome浏览器中是按照顺序执行的</p></blockquote></li><li>微任务的函数有：Promise、async、await</li><li>宏任务的函数有：定时器、事件绑定、ajax</li></ul><p><img src="/2021/11/24/Event-Loop/1.jpg" alt="alt"></p></li></ul><h1 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h1><ul><li>在JavaScript运行时，实际上维护了一组用于执行 JavaScript 代码的代理。每个代理由一组执行上下文的集合、执行上下文栈、主线程、一组可能创建用于执行 worker 的额外的线程集合、一个任务队列以及一个微任务队列构成。除了主线程（某些浏览器在多个代理之间共享的主线程）之外，其它组成部分对该代理都是唯一的。</li><li>每个代理都是由事件循环驱动的，事件循环负责收集用事件（包括用户事件以及其他非用户事件等）、对任务进行排队以便在合适的时候执行回调。然后它执行所有处于等待中的 JavaScript 任务（宏任务），然后是微任务，然后在开始下一次循环之前执行一些必要的渲染和绘制操作。</li><li>一个任务就是指计划由标准机制来执行的任何 JavaScript，如程序的初始化、事件触发的回调等。 除了使用事件，你还可以使用 setTimeout() 或者 setInterval() 来添加任务</li><li>在 JavaScript 中，任务被分为两种，一种宏任务（MacroTask）也叫 Task，一种叫微任务（MicroTask）。</li></ul><h2 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h2><p>script 全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有 IE10 支持，具体可见 MDN）、I/O、UI Rendering。</p><h2 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h2><p>Process.nextTick（Node 独有）、Promise、Object.observe(废弃)、MutationObserver</p><h2 id="宏任务vs微任务"><a href="#宏任务vs微任务" class="headerlink" title="宏任务vs微任务"></a>宏任务vs微任务</h2><p>任务队列和微任务队列的区别</p><ul><li>当执行来自任务队列中的任务时，在每一次新的事件循环开始迭代的时候运行时都会执行队列中的每个任务。在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会被执行.</li><li>每次当一个任务退出且执行上下文为空的时候，微任务队列中的每一个微任务会依次被执行。不同的是它会等到微任务队列为空才会停止执行——即使中途有微任务加入。换句话说，微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前事件循环结束之前执行完所有的微任务。</li></ul><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。<br>事件循环中的异步队列有两种：宏任务队列可以有多个，微任务队列只有一个。</p><p>一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。<br>node 中的事件循环的顺序</p><ul><li>timers 阶段：这个阶段执行 timer（setTimeout、setInterval）的回调</li><li>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</li><li>idle, prepare 阶段：仅 node 内部使用</li><li>poll 阶段：获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里</li><li>check 阶段：执行 setImmediate() 的回调</li><li>close callbacks 阶段：执行 socket 的 close 事件回调<blockquote><p>总结：浏览器环境下，microtask 的任务队列是每个 macrotask 执行完之后执行。而在 Node.js 中，microtask 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 microtask 队列的任务。</p></blockquote></li></ul><pre><code>setTimeout(() =&gt; {  console.log('timer1')  Promise.resolve().then(function () {    console.log('promise1')  })}, 0)setTimeout(() =&gt; {  console.log('timer2')  Promise.resolve().then(function () {    console.log('promise2')  })}, 0)</code></pre><p>浏览器端运行结果：timer1=&gt;promise1=&gt;timer2=&gt;promise2<br>Node 端运行结果：timer1=&gt;timer2=&gt;promise1=&gt;promise2<br>微任务和宏任务的区别<br>宏任务：DOM 渲染后触发， 如 setTimeout; 是由浏览器规定的<br>微任务：DOM 渲染前触发，如 Promise；是 ES6 规定的</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui</title>
      <link href="/2021/11/07/element-ui/"/>
      <url>/2021/11/07/element-ui/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h1><blockquote><p>slot：调取组件时，给组件传一些额外的值<code>&lt;template slot-scope="scope"&gt; &lt;/template&gt;</code>:element-ui作用域插槽，定义在通过Scoped slot可以获取到row，column，$index和store(table内部的状态管理)的数据，scope是table内部基于onlyTableData生成出来的(一个类似于excel的表格数据)，我们可以通过scope.row获取当前行的数据</p></blockquote><ul><li>通过scope.$index可以直接取到该单元格值</li><li>scope.row直接取到该单元格对象,即:onlyTableData[scope.$index]</li></ul><pre><code> &lt;!-- 静态属性表格 --&gt;          &lt;el-table :data="onlyTableData" border stripe&gt;            &lt;!-- 展开行 --&gt;            &lt;el-table-column type="expand"&gt;              &lt;template slot-scope="scope"&gt;                &lt;!-- 循环渲染Tag标签 --&gt;                &lt;el-tag v-for="(item, i) in scope.row.attr_vals" :key="i" closable                             @close="handleClose(i, scope.row)"&gt;{{item}}&lt;/el-tag&gt;                &lt;!-- 输入的文本框 --&gt;                &lt;el-input class="input-new-tag"                          v-if="scope.row.inputVisible"                          v-model="scope.row.inputValue"&gt;                &lt;/el-input&gt;                &lt;!-- 添加按钮 --&gt;                &lt;el-button v-else class="button-new-tag" size="small" @click="showInput(scope.row)"&gt;+ New Tag&lt;/el-button&gt;              &lt;/template&gt;            &lt;/el-table-column&gt;          &lt;/el-table&gt;</code></pre><ul><li>table表格中：data = “onlyTableData”为源数据，数据结构如下</li></ul><pre><code>onlyTableData :[    {        attr_id: 3068        attr_name: "主体商品"        attr_sel: "only"        attr_vals: [                     "三室"                     "这是个电视"                     "电视机"]    },    {                attr_id: 3070        attr_name: "系统-智能电视"        attr_sel: "only"        attr_vals:        ["智能电视,透明电视"]    },    {        attr_id: 3071        attr_name: "外观-壁挂安装"        attr_sel: "only"        attr_vals: ["支持,挂壁,挂壁"]    }]</code></pre><ul><li>为数据调用函数时，| 调用</li></ul><pre><code>&lt;el-table-column label="创建时间" prop="add_time" width="140px"&gt;            &lt;template slot-scope="scope"&gt;              {{scope.row.add_time | dataFormate}}            &lt;/template&gt;          &lt;/el-table-column&gt;</code></pre><pre><code>//main.js目录下的全局过滤时间函数Vue.filter('dataFormate',function (originVal){  const dt = new Date(originVal)  const y = dt.getFullYear()  const m =( dt.getMonth()+1+'').padStart(2,'0') //padStart(2,'0'):不足两位补字符串0  const d = (dt.getDate()+'').padStart(2,'0')  const hh = (dt.getHours() + '').padStart(2,'0')  const mm = (dt.getMinutes() + '').padStart(2,'0')  const ss = (dt.getSeconds() + '').padStart(2,'0')  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`})</code></pre><h2 id="作用域插槽解耦数据"><a href="#作用域插槽解耦数据" class="headerlink" title="作用域插槽解耦数据"></a>作用域插槽解耦数据</h2><p>项目中遇到：input会共享数据，当改变一个文本框的值时，其他的文本框的值也会随之改变，可用通过作用域插槽对这两个数据进行解耦，实现数据单独控制对应值，在getParamData里控制文本框的显示与隐藏，在v-if里定义作用域插槽实现单个数据上传</p><pre><code>  &lt;el-table-column type="expand"&gt;  &lt;template slot-scope="scope"&gt;    &lt;!-- + New Tag的文本框 --&gt;    &lt;el-input class="input-new-tag"               v-if="scope.row.inputVisible"               v-model="scope.row.inputValue"            @blur="handleInputConfirm(scope.row)"&gt;    &lt;/el-input&gt;    &lt;!-- 添加按钮 --&gt;    &lt;el-button v-else class="button-new-tag" size="small" @click="showInput(scope.row)"&gt;+ New Tag&lt;/el-button&gt;  &lt;/template&gt;&lt;/el-table-column&gt;showInput(row) {  row.inputVisible = true},</code></pre><p><img src="/2021/11/07/element-ui/tagData.gif" alt="alt"></p><h1 id="级联选择器"><a href="#级联选择器" class="headerlink" title="级联选择器"></a>级联选择器</h1><p>el-cascader</p>]]></content>
      
      
      
        <tags>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2021/11/03/gitInstruct/"/>
      <url>/2021/11/03/gitInstruct/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.github.com/en">GitHub文档</a></p><ul><li>本地开发文件</li><li>本地git仓库(暂存区)<ul><li>master</li><li>newBranch</li></ul></li><li>远程git仓库<ul><li>分支 main</li><li>分支 newBranch</li></ul></li></ul><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><p><code>git branch -a</code> ：查看远程分支和本地分支</p><ul><li>推送本地分支local_branch到远程分支remote_branch并建立关系<ol><li><code>git push origin local_branch:remote_branch</code> : 远程没有remote_branch，本地切换到local_branch </li><li><code>git push</code> : 远程已有remote_branch分支且已经关联local_branch本地已经切换的到了local_branch</li><li><code>git push -u origin/remote_branch</code>: 远程已有remote_branch分支且未关联local_branch本地已经切换的到了local_branch</li></ol></li></ul><p><code>git add .</code>：本地目录全部添加到暂存区</p><p><code>git commit -m 'somefunction'</code> (对main分支执行) </p><p><code>git checkout</code>（切换分支） -b xx 创建新分支xx</p><p><code>git branch</code>：查看当前分支</p><p><code>git status</code> ：检查当前分支的文件状态</p><p><code>git remote add origin https:xxxxxxx.git</code> (增加至远程git仓库地址)</p><p><code>git remote rm origin </code> : 如果因以前已经有了仓库报错，则删除原origin后再次git remote add origin https:xxxxxxx.git</p><p><code>git push -u origin master</code> : 完成远程增加源文件至远程git仓库后，执行push源文件origin去分支master</p><p><code>git push -u origin xx</code> : 第一次推送新分支xx到远程git仓库（当github仓库没有xx分支时，要加上-u）</p><p><code>git merge xx</code> : 合并分支</p><p><code>git branch -vv </code> : 查看本地分支和远程分支的关联关系</p><h2 id="本地分支远程推送到老板仓库步骤"><a href="#本地分支远程推送到老板仓库步骤" class="headerlink" title="本地分支远程推送到老板仓库步骤"></a>本地分支远程推送到老板仓库步骤</h2><p><img src="/2021/11/03/gitInstruct/12.jpg" alt="alt"><br><img src="/2021/11/03/gitInstruct/3456.jpg" alt="alt"><br><img src="/2021/11/03/gitInstruct/78.jpg" alt="alt"><br><img src="/2021/11/03/gitInstruct/910.jpg" alt="alt"><br><img src="/2021/11/03/gitInstruct/11.jpg" alt="alt"></p><ul><li>pullRequest<br><img src="/2021/11/03/gitInstruct/pullRequest.jpg" alt="alt"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue生命周期</title>
      <link href="/2021/11/03/lifeVue/"/>
      <url>/2021/11/03/lifeVue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h1><blockquote><p>白话 : Vue生命周期的过程指在vue中实例创建到销毁的过程，即从创建，初始化数据，编译模板，挂载Dom-&gt;渲染，更新-&gt;渲染，卸载等一系列过程，我们可以把组件比喻成流水线，工人是生命周期，当任务流转到工人身边的时候，工人就开始工作</p></blockquote><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><blockquote><p>每个组件在被创建时都要经过一系列的初始化过程比如需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等。同时在这个过程中也会进行一些叫做生命周期钩子的函数，用户可以在不同阶段添加自己的代码</p></blockquote><h2 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h2><svg width="838" height="1388" xmlns="http://www.w3.org/2000/svg" fill="none" font-family="Inter,Roboto,sans-serif" font-size="14" text-anchor="middle">  <g transform="translate(283 63)">    <path d="M131 66v35h6l-7 14-7-14h6v-35h2z" fill="#9AA9B2"></path>    <rect stroke="#2F679A" fill="#3E6B94" x="0.5" y="0.5" width="259" height="66" rx="8"></rect>    <text x="130" y="24.5" fill="#FFF" dominant-baseline="middle">      app = Vue.<tspan fill="#FFB196" dominant-baseline="middle">createApp</tspan>(<tspan fill="#39DD95" dominant-baseline="middle">options</tspan>)    </text>    <text x="130" y="43" fill="#FFF" dominant-baseline="middle">      app.<tspan fill="#FFB196" dominant-baseline="middle">mount</tspan>(<tspan fill="#39DD95" dominant-baseline="middle">el</tspan>)    </text>  </g>  <g transform="translate(316 178)">    <path d="M98 58v46h6l-7 14-7-14h6v-46h2z" fill="#9AA9B2"></path>    <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="193" height="58" rx="8"></rect>    <text x="97" y="20.5" fill="#FFF" dominant-baseline="middle">Init</text>    <text x="97" y="39" fill="#FFF" dominant-baseline="middle">events &amp; lifecycle</text>  </g>  <g transform="translate(73 235)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">beforeCreate</text>  </g>  <g transform="translate(316 296)">    <path d="M98 58v46h6l-7 14-7-14h6v-46h2z" fill="#9AA9B2"></path>    <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="193" height="58" rx="8"></rect>    <text x="97" y="20.5" fill="#FFF" dominant-baseline="middle">Init</text>    <text x="97" y="39" fill="#FFF" dominant-baseline="middle">injections &amp; reactivity</text>  </g>  <g transform="translate(73 353)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">created</text>  </g>  <g transform="translate(317 414)">    <path d="M-45 53v52h6l-7 14-7-14h6v-54h286v54h6l-7 14-7-14h6v-52z" fill="#9AA9B2"></path>    <polygon points="96,0.5 192,52 96,103.5 0,52" stroke="#F2781E" fill="#FF8228"></polygon>    <text fill="#FFF" x="96" y="33.5" dominant-baseline="middle">Has</text>    <text fill="#FFF" x="96" y="52" dominant-baseline="middle">“template”</text>    <text fill="#FFF" x="96" y="70.5" dominant-baseline="middle">option?</text>    <text fill="#8E9EA9" x="-58.5" y="66.5" text-anchor="end" dominant-baseline="middle">YES</text>    <text fill="#8E9EA9" x="250" y="66.5" text-anchor="start" dominant-baseline="middle">NO</text>  </g>  <g transform="translate(167 533)">    <path d="M103 58h2v44h282v-44h2v46h-142v54h6l-7 14l-7-14h6v-54h-142z" fill="#9AA9B2"></path>    <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="207" height="58" rx="8"></rect>    <text fill="#FFF" x="104" y="20.5" dominant-baseline="middle">Compile template</text>    <text fill="#FFF" x="104" y="39" dominant-baseline="middle">into render function <tspan fill="#F6DA72" dominant-baseline="middle">*</tspan></text>    <g transform="translate(284 0)">      <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="207" height="58" rx="8"></rect>      <text fill="#FFF" x="104" y="20.5" dominant-baseline="middle">Compile el’s innerHTML</text>      <text fill="#FFF" x="104" y="39" dominant-baseline="middle">as template <tspan fill="#F6DA72" dominant-baseline="middle">*</tspan></text>    </g>  </g>  <g transform="translate(73 639)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">beforeMount</text>  </g>  <g transform="translate(316 705)">    <path d="M98 58v77h6l-7 14-7-14h6v-77h2z" fill="#9AA9B2"></path>    <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="193" height="58" rx="8"></rect>    <text x="97" y="20.5" fill="#FFF" dominant-baseline="middle">Create app.$el and</text>    <text x="97" y="39" fill="#FFF" dominant-baseline="middle">append it to el</text>  </g>  <g transform="translate(73 777)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">mounted</text>  </g>  <g>    <g transform="translate(651.5 802.363) rotate(140 0 0)">      <path d="M14 0v14l-14-7l14-7z" fill="#DB5B62"></path>      <line x1="60" y1="7" x2="15" y2="7" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    </g>    <g transform="translate(619 747)">      <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>      <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">beforeUpdate</text>    </g>    <g transform="translate(642.5 1008.363) rotate(220 0 0)">      <path d="M14 0v14l-14-7l14-7z" fill="#DB5B62"></path>      <line x1="60" y1="7" x2="15" y2="7" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    </g>    <g transform="translate(619 1003)">      <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>      <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">updated</text>    </g>    <path transform="translate(430 803)" stroke="#8999A4" stroke-width="2" stroke-dasharray="4" stroke-dashoffset="6" d="M147 16a95 95,0,1,1,-102 0"></path>    <g transform="translate(539 860)">      <rect stroke="#23AC70" fill="#3AB881" x="0.5" y="0.5" width="141" height="77" rx="8"></rect>      <text x="71" y="20.5" fill="#FFF" dominant-baseline="middle">Virtual DOM</text>      <text x="71" y="39" fill="#FFF" dominant-baseline="middle">re-rendered</text>      <text x="71" y="57.5" fill="#FFF" dominant-baseline="middle">and patch</text>    </g>    <g transform="translate(526 803)">      <text x="0" y="0" fill="#8E9EA9" dominant-baseline="middle">when data</text>      <text x="0" y="18.5" fill="#8E9EA9" dominant-baseline="middle">changes</text>    </g>  </g>  <g transform="translate(366 854)">    <circle stroke="#DC424C" fill="#DB5860" cx="47" cy="47" r="46.5"></circle>    <text x="47" y="48" fill="#FFF" dominant-baseline="middle">Mounted</text>    <path stroke="#9AA9B2" stroke-width="2" stroke-dasharray="3" d="M47 96v33"></path>  </g>  <g transform="translate(355 947)">    <text x="58" y="55" fill="#8E9EA9" dominant-baseline="middle">when</text>    <text x="58" y="73.5" fill="#8E9EA9" dominant-baseline="middle">app.<tspan fill="#DB5B62" dominant-baseline="middle">unmount</tspan>()</text>    <text x="56" y="92" fill="#8E9EA9" dominant-baseline="middle">is called</text>    <path stroke="#9AA9B2" stroke-width="2" stroke-dasharray="3" d="M58 107v51"></path>    <path d="M51 159l7 14 7-14z" fill="#9AA9B2"></path>  </g>  <g transform="translate(73 1056)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">beforeUnmount</text>  </g>  <g transform="translate(73 1150)">    <path d="M160 18v14l-14-7l14-7z" fill="#DB5B62"></path>    <line x1="338" y1="25" x2="161" y2="25" stroke="#DB5B62" stroke-width="2" stroke-dasharray="3"></line>    <rect stroke="#DB5B62" stroke-width="2" x="1" y="1" width="144" height="48" rx="8"></rect>    <text x="73" y="25.5" fill="#DB5B62" dominant-baseline="middle">unmounted</text>  </g>  <g transform="translate(359 1120)">    <circle stroke="#DC424C" fill="#DB5860" cx="54" cy="54" r="53.5"></circle>    <text x="54" y="55" fill="#FFF" dominant-baseline="middle">Unmounted</text>  </g>  <g transform="translate(413 1299.5)">    <text x="0" y="0" fill="#848484" dominant-baseline="middle">* Template compilation is performed ahead-of-time if using</text>    <text x="0" y="18.5" fill="#848484" dominant-baseline="middle">a build step, e.g., with single-file components.</text>  </g></svg><blockquote><p>vue生命周期总共可以分为8个阶段，创建前后，载入前后，更新前后，销毁前后，以及一些特殊场景上的生命周期</p></blockquote><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初</td></tr><tr><td>created</td><td>组件实例已经完全创建</td></tr><tr><td>beforeMount</td><td>组件挂载之前</td></tr><tr><td>mounted</td><td>组件挂载到实例上之后</td></tr><tr><td>beforeUpdate</td><td>组件数据发生变化，更新之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>beforeDestroy</td><td>组件实例销毁之前</td></tr><tr><td>destoryed</td><td>组件实例销毁之后</td></tr><tr><td>activated</td><td>kee-alive缓存的组件激活时</td></tr><tr><td>deactivated</td><td>keep-alive缓存的组件激活时</td></tr><tr><td>errorCaptured</td><td>捕获一个来自子孙组建的错误时被调用</td></tr></tbody></table><h2 id="beforeCreate-gt-created"><a href="#beforeCreate-gt-created" class="headerlink" title="beforeCreate -> created"></a>beforeCreate -&gt; created</h2><ul><li>初始化vue实例，进行数据观测</li></ul><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><ul><li>完成数据观测，属性与方法的运算，watch，event事件毁掉的配置</li><li>可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算</li><li>此时vm.el并没有被创建</li></ul><blockquote><p>在实例挂载之后，元素可以用 vm.$el 访问。</p></blockquote><h2 id="created-gt-beforeMount"><a href="#created-gt-beforeMount" class="headerlink" title="created -> beforeMount"></a>created -&gt; beforeMount</h2><ul><li>判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译</li><li>优先级：render &gt; template &gt; outerHTML</li><li>vm.el获取到的是挂载DOM的</li></ul><h2 id="beforeMount-gt-mounted"><a href="#beforeMount-gt-mounted" class="headerlink" title="beforeMount -> mounted"></a>beforeMount -&gt; mounted</h2><ul><li>在此阶段可以获取到vm.el</li><li>此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上</li></ul><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><ul><li>在实例挂载完成后被调用，这时候传递给<code>app.mount</code></li><li>该钩子在服务器渲染期间不被调用</li></ul><h2 id="beforeUpdata"><a href="#beforeUpdata" class="headerlink" title="beforeUpdata"></a>beforeUpdata</h2><ul><li>更新的数据必须是被渲染在模板上的(el、template、rander之一)</li><li>此时view层还未更新</li><li>若在beforeUpdate中再次修改数据，不会再次触发更新方法</li></ul><h2 id="updata"><a href="#updata" class="headerlink" title="updata"></a>updata</h2><ul><li>完成值view视图的更新</li><li>若在updated中再次修改数据，会再次触发更新方法(beforeUpdate、updated)</li></ul><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><ul><li>实例被销毁前调用，此时实例属性与方法仍可访问</li></ul><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><ul><li>完全销毁一个实例，可清理它与其他实例的链接，解绑它的全部指令及事件监听器</li><li>并不能清除DOM仅仅销毁实例</li></ul><p>数据请求在created和mounted的区别</p><ul><li>created是在组件实例一旦创建完成时立即调用，这时候页面dom节点并未生成</li><li>mounted是在页面dom节点渲染完毕之后就立即执行的触发时机上，created势必mounted更早</li><li>两者的相同点：都能拿到实例对象的属性和方法，两者最大的不同就是触发时机的不同</li><li>数据请求放在mounted可能导致页面闪动(页面dom结构已经生成)，但如果在页面加载完成则不会出现此情况</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await-Promise</title>
      <link href="/2021/10/28/async-await-Promise/"/>
      <url>/2021/10/28/async-await-Promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise概念"><a href="#Promise概念" class="headerlink" title="Promise概念"></a>Promise概念</h2><p>在开发过程中我们会遇到这样的问题</p><pre><code>let fs = require('fs')fs.readFile('./a.txt','utf8',function(err,data){  fs.readFile(data,'utf8',function(err,data){    fs.readFile(data,'utf8',function(err,data){      console.log(data)    })  })})</code></pre><p>以上代码的缺点有：</p><ul><li>后一个请求需要依赖于前一个请求成功后才将数据往下传递，会导致多个ajax请求嵌套的情况代码不够直观</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作</li></ul><p>使用Promise方法对代码改进后：后一个请求不需要依赖于前一个请求的数据，提高了代码的可维护性</p><pre><code>let fs = require('fs')function read(url){  return new Promise((resolve,reject)=&gt;{    fs.readFile(url,'utf8',function(error,data){      error &amp;&amp; reject(error)      resolve(data)    })  })}read('./a.txt').then(data=&gt;{  return read(data) }).then(data=&gt;{  return read(data)  }).then(data=&gt;{  console.log(data)})</code></pre><blockquote><p>Promise是一个对象，它代表了一个异步操作的最终完成或者失败，是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，它的出现大大改善了异步编程的困境并且避免了回调地狱。简单来说Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上来说，Promise是一个对象，可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理</p></blockquote><h2 id="Promise的实例有三个状态和两个过程"><a href="#Promise的实例有三个状态和两个过程" class="headerlink" title="Promise的实例有三个状态和两个过程"></a>Promise的实例有三个状态和两个过程</h2><p>三个状态：</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）<br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</li></ul><p>两个过程：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><h2 id="Promise的特点："><a href="#Promise的特点：" class="headerlink" title="Promise的特点："></a>Promise的特点：</h2><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“承诺”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，即在本轮事件循环运行完成之前，回调函数是不会被调用的。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><h2 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h2><pre><code>function successCallback(result) {    console.log('文件创建成功'+result)}function failureCallback(result) {    console.log('文件创建失败'+result)}createAudioFileAsync(audioSettings,successCallback,failureCallback)</code></pre><p>如果函数createAudioFileAsync()被重写为返回Promise的形式</p><pre><code>const promise = createAudioFileAsync(audioSettings)promise.then(successCallback,failureCallback)</code></pre><h3 id="then"><a href="#then" class="headerlink" title="then()"></a>then()</h3><ul><li>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中第二个参数可以省略。</li><li>then方法返回的是一个新的Promise实例（不是原来那个Promise实例）,即使异步操作已经完成，在这之后会通过then()添加的回调函数也会被调用。因此可以采用链式写法，即then方法后面再调用另一个then方法。</li><li>多次调用then()可以添加多个回调函数，它们会按照插入顺序进行执行</li></ul><pre><code>let promise = new Promise((resolve,reject)=&gt;{    ajax('first').success(function(res){        resolve(res);    })})promise.then(res=&gt;{    return new Promise((resovle,reject)=&gt;{        ajax('second').success(function(res){            resolve(res)        })    })}).then(res=&gt;{    return new Promise((resovle,reject)=&gt;{        ajax('second').success(function(res){            resolve(res)        })    })}).then(res=&gt;{})</code></pre><h3 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h3><blockquote><p>该方法相当于then方法的第二个参数，指向reject的回调函数。不过catch方法还有一个作用，就是在执行resolve回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入catch方法中。</p></blockquote><pre><code>p.then((data) =&gt; {     console.log('resolved',data);},(err) =&gt; {     console.log('rejected',err);     }); p.then((data) =&gt; {    console.log('resolved',data);}).catch((err) =&gt; {    console.log('rejected',err);});</code></pre><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><blockquote><p>返回一个新的 promise, 只有所有的 promise 都成功才成功。</p></blockquote><pre><code>javascriptlet promise1 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(1);    },2000)});let promise2 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(2);    },1000)});let promise3 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(3);    },3000)});Promise.all([promise1,promise2,promise3]).then(res=&gt;{    console.log(res);    //结果为：[1,2,3] })</code></pre><h3 id="race"><a href="#race" class="headerlink" title="race()"></a>race()</h3><blockquote><p>返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态(并非是数组中的第一个，而是第一个完成的 promise)</p></blockquote><pre><code>let promise1 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       reject(1);    },2000)});let promise2 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(2);    },1000)});let promise3 = new Promise((resolve,reject)=&gt;{    setTimeout(()=&gt;{       resolve(3);    },3000)});Promise.race([promise1,promise2,promise3]).then(res=&gt;{    console.log(res);    //结果：2},rej=&gt;{    console.log(rej)};)</code></pre><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><blockquote><p>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p></blockquote><pre><code>promise.then(result =&gt; {···}).catch(error =&gt; {···}).finally(() =&gt; {···});</code></pre><ul><li>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</li></ul><h1 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h1><blockquote><p>Async与Await实际开发中应用：</p></blockquote><p>axios获取数据，返回一个promise对象，不会返回具体的数值<br><img src="/2021/10/28/async-await-Promise/promise.jpg" alt="alt"><br>当使用Async/Await来封装的时候会返回具体的数值<br><img src="/2021/10/28/async-await-Promise/await.jpg" alt="alt"></p><blockquote><p>Async/await是promise的一种语法糖，它也是为了解决回调地狱的问题，从本质上来讲，await函数仍然是promise，其原理跟Promise相似，不过比起Promise之后用then方法来执行相关一步操作，async/await 则把异步操作变得更像传统函数操作。</p></blockquote><pre><code>async function f() {    return 1;}</code></pre><p>在函数前面async这个关键字总是可以返回一个promise，其它的值将自动被包装在一个resolved的promise中<br>下列代码相当于上述代码</p><pre><code>async function f() {    return 1;}f().then(alert);//1//或者是显式地返回一个Promise，结果相同async function f() {    return Promise.resolve(1)}f().then(alert);//1</code></pre><blockquote><p>async 确保了函数返回一个promise，也会将非promise的值包装进去</p></blockquote><h1 id="Await"><a href="#Await" class="headerlink" title="Await"></a>Await</h1><blockquote><p>await关键字的作用是等到promise完成(settle)并返回结果，下面例子就是1s后resolve的promise</p></blockquote><pre><code>async function f(){    let promise = new Promise((resolve,reject) =&gt; {        setTimeout(() =&gt; resolve('done'),1000)    });    let result = await promise //等到promise resolve(*)    alert(result);//'done'}f();</code></pre><blockquote><p>这个函数在执行的时候，暂停在了（*）那一行，并在promise settle是，拿到reslut作为结果继续往下执行，<strong>await实际上会暂停函数的执行，直到promise状态变为settled</strong>，然后以promise的结果继续执行。这个行为不会耗费任何CPU资源，js引擎可以同时处理其他任务，相对于promise.then，它只是获取promise结果的一个更优雅的语法，同时也更易于读写</p></blockquote><h1 id="async-await对比Promise的优势"><a href="#async-await对比Promise的优势" class="headerlink" title="async/await对比Promise的优势"></a>async/await对比Promise的优势</h1><p>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担<br>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅<br>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余<br>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI</title>
      <link href="/2021/10/23/OSI/"/>
      <url>/2021/10/23/OSI/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/qishui/p/5428938.html">https://www.cnblogs.com/qishui/p/5428938.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2021/10/22/leetCode1/"/>
      <url>/2021/10/22/leetCode1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/38853c044156">JavaScript数据结构与算法</a></p><h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><blockquote><p>Set()里的成员是唯一的且它类似数组，但它不是数组，所以需要Array.form()方法返回数组</p></blockquote><pre><code>function.prototype.unique = function() {    return Array.from(new Set(this))}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目优化过程</title>
      <link href="/2021/10/22/vue-shop/"/>
      <url>/2021/10/22/vue-shop/</url>
      
        <content type="html"><![CDATA[<h1 id="分离开发模式与发布模式"><a href="#分离开发模式与发布模式" class="headerlink" title="分离开发模式与发布模式"></a>分离开发模式与发布模式</h1><blockquote><p>通过vue-cli3.0工具生成的项目，默认隐藏了所有的webpack配置项，如果要修改webpack默认配置的需求，可以在跟目录中按需创建vue.config.js这个配置文件，从而对项目的打包发布过程做自定义的配置<br>默认情况下vue的开发模式与发布模式共用一个打包的入口文件，为了将项目的开发过程与发布过程分离，我们可以分为两种模式各自指定打包的入口文件<br>开发模式入口：src/main-dev.js<br>发布模式入口：src/main-prod.js</p></blockquote><p>修改webpack配置方式</p><ol><li>configureWebpack：链式编程的形式</li><li>chainWebpack(项目采用)：操作对象的形式<blockquote><p>NODE_ENV是一个用户自定义的变量，在webpack中它的用途是判断生产环境或开发环境<br>vue.config.js配置如下</p></blockquote><pre><code> module.exports = { chainWebpack:config=&gt;{         //发布模式         config.when(process.env.NODE_ENV === 'production',config=&gt;{             config.entry('app').clear().add('./src/main-prod.js')         })         //开发模式         config.when(process.env.NODE_ENV === 'development',config=&gt;{             config.entry('app').clear().add('./src/main-dev.js')         })     } }</code></pre></li></ol><h1 id="项目文件体积过大"><a href="#项目文件体积过大" class="headerlink" title="项目文件体积过大"></a>项目文件体积过大</h1><h2 id="通过externals加载外部CDN资源"><a href="#通过externals加载外部CDN资源" class="headerlink" title="通过externals加载外部CDN资源"></a>通过externals加载外部CDN资源</h2><blockquote><p>默认情况下，通过import语法导入的第三方依赖包最终会被打包并合并到同一个文件中从而导致打包成功后，单文件体积过大的问题<br>为了解决以上问题，缩小依赖项的内存，可以通过webpack的externals节点，来配置并加载外部的CDN资源。它的作用就是不会打包依赖项合并到同一个文件里，当用到的某个包的时候直接去window的全局对象上寻找并且直接使用</p></blockquote><ul><li><p>优化流程</p><ol><li><p>vue.config.js中设置config.set()  用来配置externals节点</p><pre><code>//只在发布模式需要配置externalconfig.when(process.env.NODE_ENV === 'production', config =&gt; {     config         .entry('app')         .clear()         .add('./src/main-prod.js')     config.set('externals', {         vue: 'Vue',         'vue-router': 'VueRouter',         axios: 'axios',         lodash: '_',         echarts: 'echarts',         nprogress: 'NProgress',         'vue-quill-editor': 'VueQuillEditor'     })</code></pre></li><li><p>删除main-prod.js中import的包，在public/index.html中引入CDN资源文件替代</p><pre><code>&lt;!-- nprogress 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" /&gt;&lt;!-- 富文本编辑器 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.core.min.css" /&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.snow.min.css" /&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/quill/1.3.4/quill.bubble.min.css" /&gt;&lt;!-- element-ui 的样式表文件 --&gt;&lt;link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.15.6/theme-chalk/index.css" /&gt;</code></pre></li></ol></li></ul><h2 id="首页内容的自定制（辨别项目是处于开发模式-发布模式）"><a href="#首页内容的自定制（辨别项目是处于开发模式-发布模式）" class="headerlink" title="首页内容的自定制（辨别项目是处于开发模式/发布模式）"></a>首页内容的自定制（辨别项目是处于开发模式/发布模式）</h2><p>当属于开发模式时，电商管理系统前自动会渲染上dev-，当属于发布模式时，渲染的title就只有电商管理系统这几个字</p><ul><li>优化步骤</li></ul><ol><li><p>vue.config.js编写业务逻辑，发布模式isProd为true，开发模式isProd为false</p><pre><code>module.exports = { chainWebpack: config =&gt; {     // 发布模式     config.when(process.env.NODE_ENV === 'production', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = true             return args         })     })     // 开发模式     config.when(process.env.NODE_ENV === 'development', config =&gt; {         config.plugin('html').tap(args =&gt; {             args[0].isProd = false             return args         })     }) }}</code></pre></li><li><p>public/index.html中根据isProd的值来决定如何渲染页面结构</p></li></ol><blockquote><p>发布模式下需要加载CDN资源(import来引入)，不需要加上-dev；开发模式下需要加上-dev，并且需要加载CDN资源</p></blockquote><pre><code>    &lt;!--按需渲染页面的标题 htmlWebpackPlugin:插件名称 --&gt;      &lt;title&gt;&lt;%= htmlWebpackPlugin.options.isProd ? '' : 'dev - ' %&gt;电商后台管理系统&lt;/title&gt;        &lt;!--按需加载外部的CDN资源--&gt;        &lt;% if(htmlWebpackPlugin.options.isProd){ %&gt;        CDN资源        &lt;% } %&gt;</code></pre><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><blockquote><p>当打包构建项目时，JavaScript包会变得非常大，如果我们能把不同路由对应的组件分割成不同的代码块，当路由被访问的时候才会加载对应组件会变得非常高效</p></blockquote><ul><li>优化步骤</li></ul><ol><li>安装@babel/plugin-syntax-dynamic-import包</li><li>在babel.config.js配置文件中声明该插件</li><li>将路由改为按需加载的形式<br>webpackChunkName:规定了分配多个组件打包到同一个js文件的Group</li></ol><pre><code>import Vue from 'vue'import VueRouter from 'vue-router'//import Login from '@/components/Login.vue'const Login = () =&gt;    import(/* webpackChunkName: "login_home_welcome" */ '@/components/Login.vue')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/10/21/designModel/"/>
      <url>/2021/10/21/designModel/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript观察者模式"><a href="#JavaScript观察者模式" class="headerlink" title="JavaScript观察者模式"></a>JavaScript观察者模式</h1><blockquote><p>观察者模式是一种软件设计模式，一个被观察者的对象维护一组观察者的对象，这些对象依赖于被观察者，被观察者自动将自身的状态的任何变化通知给它们，具体的职责如下</p></blockquote><ul><li>被观察者：维护一组观察者，提供用于增加和移除观察者的方法</li><li>观察者：提供一个更新接口，用于当被观察者发生变化时得到通知</li><li>具体的被观察者：状态发生变化时广播通知给观察者，保持具体的观察者的信息</li><li>具体的观察者：保持一个指向具体被观察者的引用，实现一个更新接口用于观察以便保证自身状态总是和被观察者状态一致的</li></ul><h2 id="ES5下的实现"><a href="#ES5下的实现" class="headerlink" title="ES5下的实现"></a>ES5下的实现</h2><p><code>Objecet.defineProperty</code></p><pre><code>var targetObj={  age:1}function observer(oldval,newval){  console.log('name属性的值从 '+oldval+'改变为 '+newval);}Object.defineProperty(targetObj,'name',{  enumerable:true,  configurable:true,  get:function(){    return name;  },  set:function(val){    //调用处理函数    observer(name,val);    name=val;  }});targetObj.name="www";targetObj.name="mmm";console.info('targetObj:',targetObj);</code></pre><script>    var targetObj = {        age:1    }    function observer(oldval,newval) {        console.log('oldname:'oldval'newname:'newval)    }    Object.defineProperty(targetObj,'name',{        enumerable:true        configurable:true        get:function() {            return name;        }        set:function(val) {            observer(name,val);            name = val        }    })     targetObj.name = 'csl'     targetObj.name = 'csd'    </script><h2 id="set方法-ES6"><a href="#set方法-ES6" class="headerlink" title="set方法(ES6)"></a>set方法(ES6)</h2><pre><code>class  TargetObj{  constructor(age,name){    this.name=name;    this.age=age;  }  set name(val){    Observer(name,val);    name=val;  }}function Observer(oldval,newval){  console.info('name属性的值从 '+ oldval +' 改变为 ' + newval);}let targetObj2 = new TargetObj(1,'www');targetObj2.name="mmm";console.info(targetObj2);</code></pre><h2 id="Reflect和Proxy实现"><a href="#Reflect和Proxy实现" class="headerlink" title="Reflect和Proxy实现"></a>Reflect和Proxy实现</h2><p><a href="https://es6.ruanyifeng.com/#docs/reflect">Reflect</a></p><pre><code>class TargetObj {  constructor(age, name) {    this.name = name;    this.age = age;  }}let targetObj = new TargetObj(1, "www");let observerProxy = new Proxy(targetObj, {  set(target, property, value, reciever) {    if (property === "name") {      observer(target[property], value);    }    Reflect.set(target, property, value, reciever);  }});function observer(oldval, newval) {  console.info(`name属性的值从${oldval} 改变为${newval}`);}observerProxy.name="mmm";console.info(targetObj);</code></pre><h1 id="JS发布订阅者模式"><a href="#JS发布订阅者模式" class="headerlink" title="JS发布订阅者模式"></a>JS发布订阅者模式</h1><blockquote><p>发布-订阅者是一种对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到状态改变的通知</p></blockquote><ul><li>订阅者(Subscriber) ：订阅者把自己想订阅的事件注册(Subscribe)到调度中心</li><li>发布者(Publisher) ： 发布该事件到调度中心</li><li>调度中心(Event Channel) ：当事件触发时，由调度中心统一调度订阅者注册到调度中心的处理代码</li></ul><h2 id="ES5实现"><a href="#ES5实现" class="headerlink" title="ES5实现"></a>ES5实现</h2><ul><li>创建一个对象，在该对象上创建一个调度中心</li><li>on方法用来把函数fn都加到缓存列表中(订阅者注册事件到调度中心)</li><li>emit方法取到arguments里第一个当做event，根据event值去执行对应缓存列表中的函数(发布者发布事件到调度中心)</li><li>off方法根据event值取消订阅</li><li>once方法只监听一次，调用完毕后删除缓存函数(订阅一次)</li></ul><pre><code>//对象存储所有功能let eventEmitter = {};//缓存列表，存放event及fneventEmitter.list = {};//订阅eventEmitter.on = function(event,fn){    let _this = this;    //如果没有event值，就说明没有订阅过，给event创建一个缓存列表，有event值，fn加到对应的event的缓存列表中    (_this.list[event] || (_this.list[event] = [])).push(fn);    return _this}//发布eventEmitter.emit = function() {    let _this = this;    //第一个参数是对应的event值，直接用数组的shift方法取出    let event = [].shift.call(arguments);        fns = [..._this.list[event]];    if (!fns || fns.length === 0) {        return false;    }    //遍历event值对应的缓存列表，依次执行fn    fns.forEach(fn =&gt; {        fn.apply(_this,arguments)    });    return _this;    }function user1 (content) {    console.log('用户1订阅了:',content);}function user2 (content) {    console.log('用户2订阅了:',content)}//订阅eventEmitter.on('article',user1)eventEmitter.on('article',user2)//发布eventEmitter.emit('article','javascript 发布-订阅者模式')</code></pre><h2 id="Vue实现-on-emit"><a href="#Vue实现-on-emit" class="headerlink" title="Vue实现$on,$emit"></a>Vue实现$on,$emit</h2><pre><code>function eventsMixin (Vue) {    var hookRE = /^hook:/;    Vue.prototype.$on = function (event, fn) {        var this$1 = this;        var vm = this;        // event 为数组时，循环执行 $on        if (Array.isArray(event)) {            for (var i = 0, l = event.length; i &lt; l; i++) {                this$1.$on(event[i], fn);            }        } else {            (vm._events[event] || (vm._events[event] = [])).push(fn);            // optimize hook:event cost by using a boolean flag marked at registration             // instead of a hash lookup            if (hookRE.test(event)) {                vm._hasHookEvent = true;            }        }        return vm    };    Vue.prototype.$once = function (event, fn) {        var vm = this;        // 先绑定，后删除        function on () {            vm.$off(event, on);            fn.apply(vm, arguments);        }        on.fn = fn;        vm.$on(event, on);        return vm    };    Vue.prototype.$off = function (event, fn) {        var this$1 = this;        var vm = this;        // all，若没有传参数，清空所有订阅        if (!arguments.length) {            vm._events = Object.create(null);            return vm        }        // array of events，events 为数组时，循环执行 $off        if (Array.isArray(event)) {            for (var i = 0, l = event.length; i &lt; l; i++) {                this$1.$off(event[i], fn);            }            return vm        }        // specific event        var cbs = vm._events[event];        if (!cbs) {            // 没有 cbs 直接 return this            return vm        }        if (!fn) {            // 若没有 handler，清空 event 对应的缓存列表            vm._events[event] = null;            return vm        }        if (fn) {            // specific handler，删除相应的 handler            var cb;            var i$1 = cbs.length;            while (i$1--) {                cb = cbs[i$1];                if (cb === fn || cb.fn === fn) {                    cbs.splice(i$1, 1);                    break                }            }        }        return vm    };    Vue.prototype.$emit = function (event) {        var vm = this;        {            // 传入的 event 区分大小写，若不一致，有提示            var lowerCaseEvent = event.toLowerCase();            if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) {                tip(                    "Event \"" + lowerCaseEvent + "\" is emitted in component " +                    (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +                    "Note that HTML attributes are case-insensitive and you cannot use " +                    "v-on to listen to camelCase events when using in-DOM templates. " +                    "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."                );            }        }        var cbs = vm._events[event];        if (cbs) {            cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs;            // 只取回调函数，不取 event            var args = toArray(arguments, 1);            for (var i = 0, l = cbs.length; i &lt; l; i++) {                try {                    cbs[i].apply(vm, args);                } catch (e) {                    handleError(e, vm, ("event handler for \"" + event + "\""));                }            }        }        return vm    };}/***   * Convert an Array-like object to a real Array.   */function toArray (list, start) {    start = start || 0;    var i = list.length - start;    var ret = new Array(i);    while (i--) {          ret[i] = list[i + start];    }    return ret}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他遍历方法</title>
      <link href="/2021/10/21/ergodic3/"/>
      <url>/2021/10/21/ergodic3/</url>
      
        <content type="html"><![CDATA[<h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><blockquote><p>在执行的时候，会先判断执行条件再执行，for循环可以用来遍历数组，字符串，类数组，DOM节点等，可以改变原数组</p></blockquote><h1 id="while"><a href="#while" class="headerlink" title="while"></a>while</h1><blockquote><p>while循环中的结束条件可以是各种类型，但是最终都会转化为布尔值</p></blockquote><ul><li>Boolean：true，false</li><li>String：空字符串为false，所有非空字符串为true</li><li>Number：0为false，非0数字为true</li><li>null/Undefinded/NaN:全为假</li><li>Object：全为真</li></ul><p>while和for一样，都是先判断再执行，只要指定条件为true，循环就可以一直执行代码</p><h1 id="do-while"><a href="#do-while" class="headerlink" title="do/while"></a>do/while</h1><blockquote><p>该方法会先执行再判断，即使初始条件不成立,do/while循环也会至少执行一次，不建议使用do/while来遍历数组</p></blockquote><pre><code>let num = 10;do {    console.log(num);    num--;}while(num &gt;= 0);console.log(num); //-1</code></pre><h1 id="for-await-of"><a href="#for-await-of" class="headerlink" title="for await of"></a>for await of</h1><blockquote><p><code>for await of</code>方法被称为异步迭代器，该方法是主要用来遍历异步对象<br><code>for await of</code>语句会在异步或者同步可迭代对象上创建一个迭代循环，包括String，Array，类数组，Map，Set和自定义的异步或者同步可迭代对象。<strong>这个语句只能在async function内使用</strong></p></blockquote><pre><code>function Gen(time) {    return new Promise((resolve,reject) =&gt; {        setTimeout(function(){            resolve(time)        },time)    })}async function test (){    let arr = [Gen(2000),Gen(100),Gen(3000)]    for await(let item of arr){        console.log(Promise,Date.now(),item)    }}test()</code></pre><p>输出结果：<br><img src="/2021/10/21/ergodic3/async.jpg" alt="alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS对象遍历方法</title>
      <link href="/2021/10/21/ergodic2/"/>
      <url>/2021/10/21/ergodic2/</url>
      
        <content type="html"><![CDATA[<h1 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h1><blockquote><p>for in主要用于循环对象属性，循环中的代码每执行一次，就会对对象的属性进行一次操作<br>语法：</p></blockquote><pre><code>for(var i in obj) {    /*dosomthing*/}</code></pre><ul><li>i：必须，指定的变量可以是数组元素，也可以是对象的属性</li><li>obj：必须，指定迭代的对象</li></ul><pre><code>var obj = {a:1,b:2,c:3}for(var i in obj){    console.log('键名',i);    console.log('键值',obj[i])}</code></pre><p>输出结果：</p><pre><code>键名：a键值：1键名：b键值：2键名：c键值：3</code></pre><h2 id="point"><a href="#point" class="headerlink" title="point"></a>point</h2><ul><li>for in方法不仅会遍历当前对象的所有可枚举属性，还会遍历其原型链上的属性</li></ul><h1 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys()/Object.values()/Object.entries()"></a>Object.keys()/Object.values()/Object.entries()</h1><blockquote><p>遍历对象，它会返回一个有给定对象的自身可枚举属性(不含继承和Symbol属性)组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，返回值如下</p></blockquote><ul><li><code>Object.keys()</code> 返回包含对象<strong>键名</strong>的数组</li><li><code>Object.values()</code>返回包含对象<strong>键值</strong>的数组</li><li><code>Object.entries()</code>返回包含对象<strong>键名和键值</strong>的数组</li></ul><pre><code>let obj = {    id : 1,    name : 'hello',    age : 18};console.log(Object.keys(obj)); //['id','name','age']console.log(Object.values(obj)); //[1,'hello',18]console.log(Object.entries(obj)); //[['id',1],['name','hello'],['age',18]]</code></pre><h2 id="point-1"><a href="#point-1" class="headerlink" title="point"></a>point</h2><ul><li>Object.keys()方法但会数组中的值都是字符串，即不是字符串的key值会转化为字符串</li><li>结果数组中的属性值都是对象本身<strong>可枚举的属性</strong>，不包括继承来的属性</li></ul><h1 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h1><blockquote><p><code>Object.getOwnPropertyNames()</code>方法与<code>Object.keys()</code>类似，也是接受一个对象作为参数，返回一个数组，包含了改对象自身的所以属性名，但是它能返回<strong>不可枚举属性</strong></p></blockquote><pre><code>let a = ['hello','world'];Object.keys(a); //['0','1']Object.getOwnPropertyNames(a); //['0','1','length']</code></pre><p>这两个方法都可以用来计算对象中属性的个数：</p><pre><code>var obj = {0:'a',1:'b',2:'c'};Object.getOwnPropertyName(obj); //['0','1','2']Object.keys(obj).length;//3Object.getOwnPropertyNames(obj).length;//3</code></pre><h1 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h1><blockquote><p>Object.getOwnPropertySymbols()方法返回对象自身的Symbol属性组成的数组，不包括字符串属性</p></blockquote><pre><code>let obj = {a:1}//给对象添加一个不可枚举的Symbol属性Object.defineProperties(obj,{    [Symbol('baz')]:{        value:'Symbol baz',        enumerable:false    }})//不可枚举的Symbol属性obj[Symbol('foo')] = 'Symbol foo'Object.getOwnPropertySymbols(obj).forEach((key) =&gt;{    console.log(obj[key])})//输出结果：Symbol baz Symbol foo</code></pre><h1 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h1><blockquote><p>Reflect.ownKeys()返回一个数组，包含对象自身的所有属性，它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：</p></blockquote><pre><code>var obj = {    a:1,    b:2}Object.defineProperty(obj,'method',{    value:function() {        alert('No enumerable property')    },    enumerable:false})console.log(Object.keys(obj)); // ['a','b']console.log(Reflect.ownKeys(obj)); //['a','b','method']</code></pre><h2 id="point-2"><a href="#point-2" class="headerlink" title="point"></a>point</h2><ul><li>Object.keys():相当于返回对象属性数组</li><li>Reflect.ownKeys()：相当于 <code>Object.getOwnPropertyNames(obj.concat(Object.getOwnPropertySymbols(obj)))</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS数组遍历方法</title>
      <link href="/2021/10/17/jump/"/>
      <url>/2021/10/17/jump/</url>
      
        <content type="html"><![CDATA[<h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h1><blockquote><p>forEach方法用于调用数组中的每个元素，将元素传递给回调函数，数组中的每个值都会调用回调函数<br>语法：<code>arr.forEach(callback(currentValue,index,arr),isValue)</code></p></blockquote><p>callback<br>    - currentValue：（必须）当前元素<br>    - index：可选，当前元素的索引值<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>let arr = [1,2,3,4,5]arr.forEach((item,index,arr) =&gt;{    console.log(index + ':' + item)})</code></pre><blockquote><p>第二个参数用来绑定回调函数内的this变量(回调不能是箭头函数，因为箭头函数无this)</p></blockquote><pre><code>let arr = [1,2,3,4]let arr1 = [7,8,7,9]arr.forEach(function(item,index,arr){    console.log(this[index]);//[7,8,7.9]},arr1)</code></pre><ul><li>forEach方法不会改变原数组，也没有返回值</li><li>forEach无法使用break，continue跳出循环</li><li>forEach无法遍历对象，仅适用于数组的遍历</li></ul><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><blockquote><p>map()方法会返回一个新数组，该方法按照原始数组元素顺序依次处理元素<br>语法：<code>arr.map(callback(currentValue,index,arr),thisValue)</code></p></blockquote><p>callback<br>    - currentValue：（必须）当前元素<br>    - index：可选，当前元素的索引值<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>let arr = [1,2,3];arr.map(item =&gt; {    return item +1 ; //[2,3,4]})</code></pre><blockquote><p>第二个参数用来绑定参数函数内部的this变量</p></blockquote><pre><code>let arr = ['a','b','c'];[1,2].map(function(e){    return this[e]; //['b','c']},arr)</code></pre><p>该方法还可以进行链式调用</p><pre><code>let arr = [1,2,3];arr.map(item =&gt; item + 1).map(item =&gt; item +1)//输出结果:[3,4,5]</code></pre><ul><li>map方法不会对空数组进行检测</li><li>map方法遍历数组时会返回一个新数组，不改变原始数组</li><li>map方法有返回值，可以return出来，map的回调函数函数中支持return返回值</li></ul><h1 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h1><blockquote><p>for…of语句创建一个循环来迭代可迭代的对象，在es6中引入的for…of替代for…in和forEach<br>语法：<code>for(variable of iterable){ statement }</code></p></blockquote><ul><li>variable:每个迭代的属性值被分配给该变量</li><li>iterable：一个具有可枚举属性并且可以迭代的对象</li></ul><pre><code>let arr =[    {id:1,value:'hello'},    {id:2,value:'world'},    {id:3,value:'Javascript'}]for(let item of arr){    console.log(item);    //{id:1,value:'hello'},    //{id:2,value:'world'},    //{id:3,value:'Javascript'}}</code></pre><ul><li>for of方法只会遍历当前对象的属性，不会遍历其原型链上的属性</li><li>for of方法适用遍历<strong>数组/类数组/字符串/map/set</strong>等拥有迭代对象的集合</li><li>for of方法不支持遍历普通对象，因为其没有迭代器对象，如果想要遍历一个对象的属性可以使用for in方法</li><li>可以使用break，continue，return来中断循环遍历</li></ul><h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><blockquote><p>filter()方法用于过滤数组，满足条件的元素会被返回，它的参数是一个回调函数，所有数组元素一次执行该函数，结果为true的元素被返回，如果没有符合条件的元素，则会返回空数组<br>语法：<code>arr.filter(callback(currentValue,index,arr),thisValue)</code></p></blockquote><p>callback<br>    - currentValue:必须，数组中正在处理的元素<br>    - index：可选，当前元素索引<br>    - arr：可选，当前元素所属的数组对象</p><pre><code>const arr = [1,2,3,4,5]arr.filter(item =&gt; item &gt; 2)//[3,4,5]</code></pre><blockquote><p>第二个参数用来绑定函数内部的this变量<br> 可以使用filter方法来移除数组中的undefined，null，NAN等值</p></blockquote><pre><code>let arr = [1,undefined,2,null,3,false,'',4,0]arr.filter(Boolean);//[1,2,3,4]</code></pre><ul><li>filter方法会返回新数组，不会改变原数组</li><li>filter方法不会对空数组进行检测</li><li>filter方法仅仅用于检测数组</li></ul><h1 id="some-every"><a href="#some-every" class="headerlink" title="some()/every()"></a>some()/every()</h1><blockquote><p>some方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就会返回true，且剩余的元素不会再进行检测，否则就返回false<br>语法<code>arr.some(callback(currentValue,index,arr),thisValue)</code></p></blockquote><blockquote><p>every()方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才会返回true，如果数组中检测到有个元素不满足，则整个表达式返回false，且剩余的元素不会再进行检测<br>语法：<code>arr.every(callback(currentValue,index,arr),thisValue)</code></p></blockquote><pre><code>let arr = [1,2,3,4,5]arr.some(item =&gt; item &gt; 4) // truelet arr = [1,2,3,4]arr.every(item =&gt; item &gt;0) //true</code></pre><ul><li>两个方法都不会改变原数组，会返回一个布尔值</li><li>两个方法都不会对空数组进行检测</li><li>两个方法都适用于检测数组</li></ul><h1 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce()/reduceRight()"></a>reduce()/reduceRight()</h1><blockquote><p>reduce()方法接受一个函数作为累加器，数组中的每个值(从左到右)开始缩减，最终计算为一个值，reduce方法会为数组中的<strong>每一个元素依次执行回调函数</strong>，不包括数组中被删除或从未被赋值的元素<br>语法：<code>arr.reduce(callback(total,currentValue,currentIndex,arr)initialValue)</code></p></blockquote><p>callback<br>    - total：上一次调用回调返回的值，或者是提供的初始值(initialValue)<br>    - currentValue:当前被处理的元素；<br>    - currentIndex：当前元素的索引<br>    - arr：当前元素所属的数组对象<br>该方法的第二个参数是initialValue，表示传递给函数的初始值，作为第一次调用callback的第一个参数</p><pre><code>let arr = [1,2,3,4]let sum = arr.reduce((prev,cur,index,arr) =&gt; {    console.log(prev,cur,index);    return prev + cur;})console.log(arr,sum);//输出结果//1 2 1//3 3 2//6 4 3//[1,2,3,4]10</code></pre><p>加一个初始值之后</p><pre><code>let arr = [1,2,3,4]let sum = arr.reduce((prev,cur,index,arr) =&gt; {    console.log(prev,cur,index);    return prev + cur;},5)console.log(arr,sum);//输出结果//5 1 0//6 2 1//8 3 2//11 4 3//[1,2,3,4] 15</code></pre><blockquote><p>由此可以得出结论，如果没有提供初始值initialValue，reduce会从索引1的地方开始执行callback方法，跳过第一个索引，如果提供了initialValue，从索引0开始执行</p></blockquote><p>reduceRight方法和reduce的用法几乎一致，只是该方法是对数组进行倒序遍历的，而reduce方法是正序遍历</p><ul><li>两个方法在添加初始值的情况下才会改变原数组，否则不会改变原数组，会将这两个初始值放在数组的最后一位</li><li>两个方法对于空数组是不会执行回调函数的</li></ul><h1 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find()/findIndex()"></a>find()/findIndex()</h1><blockquote><p>find方法返回通过函数内判断符合条件的值,当数组中的元素在测试条件返回true时，find返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素则返回undefined<br>语法：<code>arr.find(callback(currentValue,index,arr),thisValue)</code></p></blockquote><blockquote><p>findIndex方法返回通过函数内判断符合条件的值的索引，之后的值不会再调用执行函数，如果没有符合条件的元素返回-1<br>语法：<code>arr.findIndex(callback(currentValue,index,arr),thisValue)</code></p></blockquote><pre><code>let arr = [1,2,3,4,5]arr.find(item =&gt; item &gt; 2); //3let arr = [1,2,3,4,5]arr.findIndex(item =&gt; item &gt; 2); //2</code></pre><ul><li>两个方法对于空数组，函数是不会执行的</li><li>两个方法不会改变原数组</li></ul><h1 id="keys-values-entries"><a href="#keys-values-entries" class="headerlink" title="keys()/values()/entries()"></a>keys()/values()/entries()</h1><blockquote><p>三个方法都返回一个数组的迭代对象，对象的内容不太相同</p></blockquote><ul><li>keys() 返回数组的<strong>索引</strong>值：<code>arr.keys()</code></li><li>values() 返回数组的<strong>元素</strong>:<code>arr.values()</code></li><li>entries() 返回数组的<strong>键值对</strong>:<code>arr.entries()</code></li></ul><pre><code>let arr = ['Banana','Orange','Apple','Mango'];//这三个方法都没有参数const iterator1 = arr.keys();const iterator2 = arr.values();const iterator3 = arr.entries();for(let item of iterator1){    console.log(item); //0 1 2 3}for(let item of iterator2){    console.log(item); //Banana Orage Apple Mango}for(let item of iterator3){    console.log(item);//[0, 'Banana'] [1, 'Orange'] [2, 'Apple'] [3, 'Mango']}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue文档阅读笔记</title>
      <link href="/2021/10/14/baseVue/"/>
      <url>/2021/10/14/baseVue/</url>
      
        <content type="html"><![CDATA[<h1 id="指令相关"><a href="#指令相关" class="headerlink" title="指令相关"></a>指令相关</h1><blockquote><p>指令（Directives）的职责是当表达式的值发生改变时将其产生的连带影响**<a href="https://v3.cn.vuejs.org/guide/reactivity.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E6%80%A7">响应式</a>地作用于DOM**，除了v-for，v-on，指令attribute的预期值是单个JavaScript表达式</p></blockquote><ul><li>动态绑定<ul><li>对于动态参数的规定<br>  动态参数预期会求出一个字符串（除了null），这个null值可以用于显式地移除绑定</li></ul></li></ul><blockquote><p><code>&lt;a :[attributeName]="url"&gt;...&lt;/a&gt;</code>:这里的attributeName会被作为一个JavaScript表达式进行动态求值。比如你的组件实例有一个data property为attributeName的值为”href”，那么这个绑定将等价于<code>v-bind:href</code></p></blockquote><ul><li>指令修饰符</li></ul><blockquote><p>修饰符（modifier）表现形式为<code>.</code>，规定了这个指令应该以特殊方式绑定比如<code>.prevent</code>修饰符告诉v-on指令对于触发的事件调用event.preventDefault()的代码如下</p></blockquote><pre><code>&lt;form @submit.prevent="onSubmit"&gt;...&lt;/form&gt;</code></pre><h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><blockquote><p>Vue中没有内置支持防抖和节流，但可以使用lodash等库来实现，如果直接定义在method中的某个点击事件中的话会对可复用组件产生一些潜在的问题因为它们都共享相同的防抖函数<br>为了使组件实例彼此独立，可以在生命周期钩子的created里添加该防抖函数(created时期还没有将模板编译为渲染函数)</p></blockquote><pre><code>app.component('save-button', {  created() {    // 使用 Lodash 实现防抖    this.debouncedClick = _.debounce(this.click, 500)  },  unmounted() {    // 移除组件时，取消定时器    this.debouncedClick.cancel()  },  methods: {    click() {      // ... 响应点击 ...    }  },  template: `    &lt;button @click="debouncedClick"&gt;      Save    &lt;/button&gt;  `})</code></pre><h1 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性(computed)"></a>计算属性(computed)</h1><h2 id="computed与methods的异同"><a href="#computed与methods的异同" class="headerlink" title="computed与methods的异同"></a>computed与methods的异同</h2><blockquote><p>在模板中放入太多逻辑会让模板过重且难以维护</p></blockquote><pre><code>&lt;div id="computed-basics"&gt;  &lt;p&gt;Has published books:&lt;/p&gt;  &lt;span&gt;{{ author.books.length &gt; 0 ? 'Yes' : 'No' }}&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code>Vue.createApp({  data() {    return {      author: {        name: 'John Doe',        books: [          'Vue 2 - Advanced Guide',          'Vue 3 - Basic Guide',          'Vue 4 - The Mystery'        ]      }    }  }})</code></pre><ul><li>使用计算属性后<pre><code>//在**组件**中computed: {  // 计算属性的 getter  publishedBooksMessage() {    // `this` 指向 vm 实例    return this.author.books.length &gt; 0 ? 'Yes' : 'No'  }}</code></pre></li><li>也可以使用<strong>方法</strong>达到相同的效果<pre><code>&lt;p&gt;{{ calculateBooksMessage() }}&lt;/p&gt;// 在组件中methods: {calculateBooksMessage() {  return this.author.books.length &gt; 0 ? 'Yes' : 'No'}}</code></pre></li></ul><ul><li>methods和computed最大的区别在于computed有缓存，而methods没有</li></ul><blockquote><p>这两种实现方式确实是完全相同的，然而<strong>计算属性基于它们的响应依赖关系缓存</strong>，计算属性只会在相关相关响应式依赖发生改变时重新求值，意味着只要author.books还没有发生改变，多次访问publishdBookMessage时候<strong>计算属性会立即返回之前的计算结果</strong>（观察者）<br>比如在computed里定义一个now函数接收<code>Date.now()</code>的返回结果，那么这个计算属性将永远不会更新，因为<code>Date.now()</code>不是响应式依赖<br>而相对methods，每当触发重新渲染时，调用方法始终会再次执行函数</p></blockquote><h1 id="侦听器（watch）"><a href="#侦听器（watch）" class="headerlink" title="侦听器（watch）"></a>侦听器（watch）</h1><h2 id="watch和computed的异同"><a href="#watch和computed的异同" class="headerlink" title="watch和computed的异同"></a>watch和computed的异同</h2><blockquote><p>当你有一些数据需要随着其他数据变动而变动时，computed比watch更加好用</p></blockquote><ul><li><p>使用watch</p><pre><code>&lt;div id="demo"&gt;{{ fullName }}&lt;/div&gt;const vm = Vue.createApp({data() {  return {    firstName: 'Foo',    lastName: 'Bar',    fullName: 'Foo Bar'  }},watch: {  firstName(val) {    this.fullName = val + ' ' + this.lastName  },  lastName(val) {    this.fullName = this.firstName + ' ' + val  }}}).mount('#demo')</code></pre></li><li><p>computed</p><pre><code>computed: {  fullName() {    return this.firstName + ' ' + this.lastName  }}</code></pre><ul><li>虽然计算属性在大多数情况下更合适，但watch同样也有适用场景比如需要在数据变化时执行异步或者开销较大的操作时，watch最有效</li></ul><pre><code>&lt;div id="watch-example" class="demo"&gt;&lt;p&gt;  Ask a yes/no question:  &lt;input v-model="question" /&gt;&lt;/p&gt;&lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/div&gt;</code></pre><pre><code>const watchExampleVM = Vue.createApp({  data() {      return {      question: '',      answer: 'Questions usually contain a question mark. ;-)'      }  },  watch: {      // whenever question changes, this function will run      question(newQuestion, oldQuestion) {      if (newQuestion.indexOf('?') &gt; -1) {          this.getAnswer()      }      }  },  methods: {      getAnswer() {      this.answer = 'Thinking...'      axios          .get('https://yesno.wtf/api')          .then(response =&gt; {          this.answer = response.data.answer      })          .catch(error =&gt; {          this.answer = 'Error! Could not reach the API. ' + error      })      }   }  }).mount('#watch-example')</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2021/10/09/paper-vuex/"/>
      <url>/2021/10/09/paper-vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p><img src="/2021/10/09/paper-vuex/1.png" alt="alt"></p><ul><li>当多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态无能为力</li><li>来自不同组件的行为需要变更同一状态，以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码</li><li>综上，<strong>当项目遇到多个组件依赖于同一状态时；或者来自不同组件的行为需要变更同一状态时</strong>可以使用Vuex</li></ul><blockquote><p>Vuex实现了一个单向数据流，在全局中拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新，而当所以异步操作（常见于调用后端接口异步获取更新数据）或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过MutationlI修改State的数据。最后，根据State的变化，渲染到视图上</p></blockquote><h2 id="引入Vuex"><a href="#引入Vuex" class="headerlink" title="引入Vuex"></a>引入Vuex</h2><ul><li>安装依赖npm install vuex –save</li><li>项目目录src中建立store文件夹</li><li>在store文件夹下新建index.js文件，写入<pre><code>import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);//不是在生产环境debug为trueconst debug = process.env.NODE_ENV !== 'production';//创建Vuex实例对象const store = new Vuex.Store({  strict:debug,//在不是生产环境下都开启严格模式  state:{  },  getters:{  },  mutations:{  },  actions:{  }})export default store;</code></pre></li><li>main.js中引入Vuex<br>```<br>import Vue from ‘vue’;<br>import App from ‘./App.vue’;<br>import store from ‘./store’;<br>const vm = new Vue({<br>  store:store,<br>  render: h =&gt; h(App)<br>}).$mount(‘#app’)</li></ul><pre><code>## Vuex核心属性### stateVuex的state相当于一个全局的state，你可以在component的任何地方获取和修改它。如果有些状态严格属于单个组件，最好还是作为组件的局部状态</code></pre><p>//获取state<br>this.$store.state.count</p><pre><code>### gettersVuex里的getters类似于computed，可以认为是store的计算属性，getter的返回值会根据它的依赖被缓存起来，且只有当它的以来至发生了改变才会被重新计算</code></pre><p>//直接使用<br>this.$store.getters.doneTodoCount</p><p>//或者<br>import {mapGetters} from ‘vuex’<br>computed:mapGetters({<br>    doneCount:’doneTodoCount’<br>})</p><pre><code>### mutations更改Vuex的store状态的唯一方法时提交mutaion，mutation必须是同步函数</code></pre><p>//直接触发mutations<br>this.$store.commit(‘xxx’)</p><p>//或者<br>import { mapMutations } from ‘vuex’<br>methods：mapMutations([‘increment’ ])</p><pre><code>### actionsAction类似mutation，不同在于- Action提交的是mutation，而不是直接变更状态- Action可以包含任何异步操作</code></pre><p>//触发action<br>store.dispatch(‘increment’)</p><p>//或者<br>import {mapActions} from ‘vuex’<br>methods:mapActions([‘increment’])</p><pre><code>### Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用变得非常复杂时，store对象就有可能变得臃肿，为了解决以上问题，Vuex允许我们将store分割成模块(moudule)。每个模块拥有自己的state，mutation，action，getter，甚至是嵌套子模块--从上至下进行相同方式的分割</code></pre><p>const moduleA = {<br>  state: { … },<br>  mutations: { … },<br>  actions: { … },<br>  getters: { … }<br>}</p><p>const moduleB = {<br>  state: { … },<br>  mutations: { … },<br>  actions: { … }<br>}</p><p>const store = new Vuex.Store({<br>  modules: {<br>    a: moduleA,<br>    b: moduleB<br>  }<br>})</p><p>store.state.a // -&gt; moduleA 的状态<br>store.state.b // -&gt; moduleB 的状态</p><p>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目，仿写去哪儿app</title>
      <link href="/2021/10/05/paper-project-VueWhere/"/>
      <url>/2021/10/05/paper-project-VueWhere/</url>
      
        <content type="html"><![CDATA[<iframe scrolling="no" width="100%" height="300" src="https://jsfiddle.net/o2gxgz9r/embedded/js,resources,html,css,result/light" frameborder="0" loading="lazy" allowfullscreen=""></iframe><h1 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h1><h2 id="解决文字溢出的方法："><a href="#解决文字溢出的方法：" class="headerlink" title="解决文字溢出的方法："></a>解决文字溢出的方法：</h2><p>textOverflow()<br>  white-space:nowrap;<br>  text-overflow:ellipsis;<br>  overflow:hidden;</p><h2 id="表格边框写法"><a href="#表格边框写法" class="headerlink" title="表格边框写法"></a>表格边框写法</h2><h1 id="首页数据前台接口部分"><a href="#首页数据前台接口部分" class="headerlink" title="首页数据前台接口部分"></a>首页数据前台接口部分</h1><h2 id="优化冗余路径"><a href="#优化冗余路径" class="headerlink" title="优化冗余路径"></a>优化冗余路径</h2><blockquote><p>把<a href="http://localhost:8080/static/mock">http://localhost:8080/static/mock</a>   冗余的路径替换成api</p></blockquote><p><img src="/2021/10/05/paper-project-VueWhere/api1.jpg" alt="alt"><br><img src="/2021/10/05/paper-project-VueWhere/api3.jpg" alt="alt"></p><blockquote><p>修改系统文件，在webpack下设置代理项，重置路径</p></blockquote><p><img src="/2021/10/05/paper-project-VueWhere/api2.jpg" alt="alt"></p><h1 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h1><h2 id="项目中使用到的路由跳转的方法"><a href="#项目中使用到的路由跳转的方法" class="headerlink" title="项目中使用到的路由跳转的方法"></a>项目中使用到的路由跳转的方法</h2><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>实现hot页面上点击的城市渲染到header上<br><img src="/2021/10/05/paper-project-VueWhere/router1.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>&lt;router-link :to = "{name:'home'}"&gt;</code> 建议使用name<br><code>&lt;router-link :to = "{path:'/home'}"&gt;</code></p><blockquote><p>router-link中链接如果是’/‘开始就是从根路由开始,如果开始不带’/‘,则从当前路由开始</p></blockquote></li><li><p>带参数</p></li></ul><p><code>&lt;router-link :to="{name:'home',params:{id:1}}"&gt;</code></p><blockquote><p>params传参(类似post) 配置path:”/home:id”或path:”/home/:id”,刷新页面id会保留，不配置path；第一次可请求，刷新页面id会消失</p></blockquote><p><code>&lt;router-link :to = "{name:'home',query:{id:1}}"&gt;</code></p><blockquote><p>query传参(类似get，url后面会显示参数)路由不可配置</p></blockquote><h3 id="this-router-push-函数里调用"><a href="#this-router-push-函数里调用" class="headerlink" title="this.$router.push()(函数里调用)"></a>this.$router.push()(函数里调用)</h3><p><img src="/2021/10/05/paper-project-VueWhere/router2.jpg" alt="alt"></p><ul><li><p>不带参数<br><code>this.$router.push('/home')</code><br><code>this.$router.push({name:'home'})</code><br><code>this.$router.push({path:'/home'})</code></p></li><li><p>query传参<br><code>this.$router.push({name:'home',query:{id:'1'})</code><br><code>this.$router.push({path:'/home',query:{id:'1'}})</code></p></li><li><p>params传参<br><code>this.$router.push(name:'home',params:{id:'1'})</code> 只能用name</p></li></ul><h2 id="keep-alive减少相同请求优化"><a href="#keep-alive减少相同请求优化" class="headerlink" title="keep-alive减少相同请求优化"></a>keep-alive减少相同请求优化</h2><blockquote><p>keep-alive本身是vue2.0的功能，为了让组件数据缓存，避免每次资源加载重复请求</p></blockquote><ul><li>不切换城市的时候不需要重新发送dataHome请求<br><img src="/2021/10/05/paper-project-VueWhere/route.jpg" alt="alt"></li><li>设置keep-alive<br><img src="/2021/10/05/paper-project-VueWhere/route1.jpg" alt="alt"></li><li>需要重新设置Home里的请求数据的方法getHttp（）<br><img src="/2021/10/05/paper-project-VueWhere/route2.jpg" alt="alt"></li></ul><h1 id="vuex实现子组件到子组件的通信"><a href="#vuex实现子组件到子组件的通信" class="headerlink" title="vuex实现子组件到子组件的通信"></a>vuex实现子组件到子组件的通信</h1><blockquote><p>项目中除了从City页面中的子页面到Home中的子页面用的是子组件的通信，其他的都是父组件到子组件通信</p></blockquote><ul><li>点击hot页面的城市跳转到首页并且header右边的城市变为相对应的城市<br>项目相关配置<br><img src="/2021/10/05/paper-project-VueWhere/vuex.jpg" alt="alt"><br>List文件下配置<br><img src="/2021/10/05/paper-project-VueWhere/vuex1.jpg" alt="alt"></li></ul><h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><h2 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h2><p>在实战中发现多次通过路由切换组件页面滚动和点击事件都会失效</p><blockquote><p>解决方法：<br>初始化<br>首先要引入组件，需要dom结构加载完成时才执行初始化（$nextTick）。因此，需要用上钩子函数created()或者mounted()。</p></blockquote><pre><code>&lt;div class="wrapper" ref="wrapper"&gt;  &lt;div class="content"&gt;    &lt;ul&gt;      &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/div&gt;import BScroll from 'better-scroll'mounted() {      this.$nextTick(() =&gt; {        //$refs绑定元素        if(!this.scroll){            this.scroll = new BScroll(this.$refs.wrapper, {            //开启点击事件 默认为false            click:true        })        // console.log(this.scroll)        }else if(!this.$refs.wrapper){            return        }        else{            this.scroll.refresh()        }      })  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型概念及继承实现</title>
      <link href="/2021/09/25/paper-prototype/"/>
      <url>/2021/09/25/paper-prototype/</url>
      
        <content type="html"><![CDATA[<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><h2 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h2><blockquote><p>在js中，创建对象有好几种方式，比如对象字面量，或者是直接通过构造函数new一个对象出来，虽然都是对象，却存在着差异性，js中，我们将对象分为函数对象和普通对象。函数对象就是用函数来模拟类的实现</p></blockquote><pre><code>function func1(){}const func2 = function(){};const func3 = new Function('name','console.log(name)');const obj1 = {};const obj2 = new Object();const obj3 = new func1();const obj4 = new new Function();console.log(typeof Object);//functionconsole.log(typeof Function);//function</code></pre><ul><li>上述代码中，obj1,obj2,obj3,obj4都是普通对象</li><li>func1，func2，func3都是Function的实例，也就是函数对象</li><li>可以看出<strong>所有Function的实例都是函数对象其他都为普通对象包括Function实例的实例</strong></li><li>Function和new Function的关系为<code>Function.__proto__=== Function.prototype</code><blockquote><p>__proto__和constructor是对象独有的，prototype属性是函数独有的，但是在js中函数也是对象，所以函数也拥有__proto__和constructor属性</p></blockquote></li></ul><p><img src="/2021/09/25/paper-prototype/1.jpg" alt="alt"></p><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><blockquote><p>es规范里描述prototype是一个隐式引用，但是之前的一些浏览器已经私自实现了__proto__这个属性，使得可以通过obj.__proto__这个显示的属性访问访问到被定义为隐式属性的prototype</p></blockquote><ul><li>__proto__属性既不能被for…in遍历出来，也不能被Object.keys(obj)查找出来</li><li>访问对象的obj.<strong>proto</strong>,默认走的是object.prototype对象上__proto__属性的get/set方法</li><li>__proto__是函数指向对象</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>__proto__是对象所独有的，并且__proto__是一个对象指向父类对象，它的作用是当你在访问一个对象属性的时候，如果对象内部没有这个属性，那他就在他的__proto__属性所指的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那他就在他父类的__proto__所指的对象上查找，以此类推，直到找到null，这个查找的过程也构成了原型链</p></blockquote><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><blockquote><p>在规范里，prototype被定义为<strong>给其他对象提供共享属性的对象</strong></p></blockquote><ul><li>prototype自己也是对象，只是被用以承担某个职能</li><li>所有对象都可以作为另一个对象的prototype使用</li><li>prototype是<strong>函数</strong>独有的，它的作用是可以给特定类型的所有实例提供共享的属性和方法，<strong>任何函数在创建的时候，都会给该函数添加prototype属性</strong></li></ul><p><img src="/2021/09/25/paper-prototype/2.jpg" alt="alt"></p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><blockquote><p>constructor属性也是对象所独有的，它是<strong>一个对象指向一个函数</strong>，这个函数就是该对象的构造函数</p></blockquote><ul><li>每个对象都有对应本身或者继承而来的构造函数</li><li>只有prototype对象有constructor这个属性</li><li>在每个函数创建的时候js会同时创建一个prototype对象，且<code>该对象创建的函数.__proto__ === 该函数.prototype</code>，<code>该函数.prototype.constructor === 该函数</code></li><li>所以通过函数创建的对象即使已经没有constructor属性，也能通过__proto__找到对应的constructor</li></ul><p><img src="/2021/09/25/paper-prototype/3.jpg" alt="alt"></p><blockquote><p>上图虚线表示继承来的constructor</p></blockquote><h1 id="typeof-amp-amp-instanceof"><a href="#typeof-amp-amp-instanceof" class="headerlink" title="typeof &amp;&amp; instanceof"></a>typeof &amp;&amp; instanceof</h1><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><blockquote><p>typeof一般被用来判断一个变量的类型</p></blockquote><ul><li>我们可以使用typeof来判断number、undefined、symbol、string、function、boolean、object 这七种数据类型，</li><li>但是判断Object的时候并不能明确的告诉你object属于哪一种object</li></ul><pre><code>let s = new String('abc');typeof s === 'object'//truetypeof null;//'object'</code></pre><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>js在底层存储变量的时候会在变量的机器码的低位1-3位存储其类型信息</p><ul><li>1：整数</li><li>110：布尔</li><li>100：字符串</li><li>010：浮点数</li><li>000：对象<br>对于undefined和null、，这两个值的信息存储是特殊的</li><li>null：所有机器码均为0</li><li>undefined：用 −2^30 整数来表示<blockquote><p>在使用typeof来判断变量类型的时候，最好用typeof来判断基本数据类型，避免对null的判断</p></blockquote></li></ul><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>instanceof运算符用来检测constructor.prototype是否存在于object的原型链上，与typeof方法不同的是，instanceof方法要求开发者明确地确认对象为某特定类型</p></blockquote><ul><li>如下，是instanceof的基本用法，它可以判断一个实例是否是其父类型或者祖先类型的实例</li></ul><pre><code>// 定义构造函数function C(){} function D(){} var o = new C();o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototypeo instanceof D; // false，因为 D.prototype 不在 o 的原型链上o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 trueC.prototype instanceof Object // true，同上C.prototype = {};var o2 = new C();o2 instanceof C; // trueo instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.D.prototype = new C(); // 继承var o3 = new D();o3 instanceof D; // trueo3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上</code></pre><h1 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h1><blockquote><p>大多数浏览器中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时拥有prototype属性和__proto__属性，因此同时存在两条继承链</p></blockquote><ul><li>子类的__proto__属性，表示<strong>构造函数</strong>的继承，总是指向父类</li><li>子类prototype属性的__proto__属性，表示<strong>方法</strong>的继承，总是指向父类的prototype属性</li></ul><pre><code>Class Father{ }Class Child extends Father{}Child.__proto__ === Father;//trueChild.prototype.__proto__ === Father.prototype;//true</code></pre><p>上面代码中，子类的__proto__属性指向父类，子类的prototype属性的__proto__属性指向父类的prototype属性<br>这样是因为类的继承是按照下面的模式实现的</p><pre><code>Class Father{}Class Child{}//Child的实例继承Father的实例Object.setPrototypeOf(Child.prototype,Father.prototype);//Child继承Father的静态属性Object.setPrototype(Child,Father)const c = new Child();</code></pre><p><code>Object.setPrototypeOf</code>方法的实现如下：</p><pre><code>Object.setPrototypeOf = function(obj,proto){    obj.__proto__ = proto;    return obj;}</code></pre><p>因此就得到了上面的结果</p><pre><code>Object.setPrototypeOf(Child.prototype,Father.prototype);//等同于Child.prototype.__proto__ = Father.prototype;Object.setPrototypeOf(Child,Father);//等同于Child.__proto__ = Father;</code></pre><p>这两条继承链可以这样理解：作为一个对象，子类(Child)的原型(__proto__属性)是父类(Father)；作为一个构造函数，子类(Child)的原型对象(prototype属性)是父类原型对象(prototype属性)的实例</p><pre><code>Child.prototype = Object.create(Father.prototype);Child.prototype.__proto__ = Father.prototype;</code></pre><p>extends关键字后面可以跟很多种类型的值</p><pre><code>class Child extends Father{}</code></pre><p>上面代码中的Father只要有一个有prototype属性的函数就能被Child继承，由于函数都有prototype属性(处理Function.prototype函数)，因此Father可以是任何函数<br>下面讨论两种情况，第一种，子类继承Object类</p><pre><code>class Child extends Object{}Child.__proto__ === Object//tureChild.prototype.__proto__ = Object.prototype //true</code></pre><p>这种情况下，Child其实就是构造函数Object的复制，Child的实例就是Object的实例<br>第二种情况，不存在任何继承</p><pre><code>class C{}C.__proto__ === Function.prototype; //trueC.prototype.__proto__ === Object.prototype; //true</code></pre><p>这种情况下，C作为一个基类(即不存在任何继承)就是一个普通函数，所以直接继承Function.prototype，但是C调用后返回一个空对象(即Object实例)，所以C.prototype.__proto__指向构造函数(Object)的prototype属性</p><h1 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的__proto__属性"></a>实例的__proto__属性</h1><p>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性，也就是说，子类原型的原型，是父类的原型</p><pre><code>var p1 = new Father(2,3);var p2 = nw Child(2,3,'neo');p2.__proto__ === p1.__proto__ //falsep2.__proto__.__proto__ === p1.__proto__ //true</code></pre><ul><li><p>上面代码中Child继承了Father，导致前者原型的原型是后者的原型</p></li><li><p>通过子类实例的__proto__.__proto__属性可以修改父类实例的行为</p><pre><code>p2.__proto__.__proto__.personName = function(){  console.log('one')}p1.personName()//'one'</code></pre></li><li><p>上面代码在Child的实例p2上向Father类添加方法，结果影响到了Father类的实例p1</p></li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="ES5继承实现方式"><a href="#ES5继承实现方式" class="headerlink" title="ES5继承实现方式"></a>ES5继承实现方式</h2><p><code>Object.create()</code></p><p>es5规范中新增了Object.create()方法，该方法会传入一个对象，返回一个对象，返回的对象的原型指向传入的对象。比如执行代码<code>var output = Object.create(input)</code>，相当于执行代码<code>output.__proto__ = input</code>,output的原型是input<br><code>Object.keys()</code>方法用以获取对象自身的属性数组，我们可以用该方法简化继承父类静态属性和方法的过程</p><pre><code>function extendsClass(child,Father){    Child.prototype = Object.create(Father.prototype);    Child.prototype.constructor = child;    Object.keys(Father).forEach(function(key){        Child[key] = Father[key]    })}</code></pre><h2 id="ES6继承-class继承"><a href="#ES6继承-class继承" class="headerlink" title="ES6继承(class继承)"></a>ES6继承(class继承)</h2><blockquote><p>Class可以通过extends关键字实现继承，这比ES5通过原型链实现继承要清晰和方便的多</p></blockquote><pre><code>class Father{}class Child extends Father{}</code></pre><p>上面代码定义了一个Father类，该类通过extends关键字继承了Child类的所有属性和方法，由于内部没有添加代码，所有这两个类完全一样，等于复制了一个Child类</p><pre><code>class Child extends Father{    constructor(x,y,color){        super(x,y);//调用父类的constructor(x,y)        this.color = color    }    toString(){        return this.color + ''+super.toString();//调用父类的toString     }}</code></pre><p>上面代码中，constructor方法和toString方法之中都出现了super’关键字，它在这里表示父级的构造函数，用来新建父级的this对象</p><blockquote><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例和方法后在对其进行加工，加上子类自己的实例属性和方法，如果不调研super方法，子类就得不到this对象</p></blockquote><pre><code>class Father{}class Child extends Father{    constructor(){    }}let Ch = new Child()//ReferenceError//构造函数中没有调用super方法</code></pre><ul><li>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面(Parent.apply(this))。</li><li>ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法加到this上面，然后再用子类的构造函数修改this</li><li>如果子类没有定义constructor方法，这个方法会被默认添加</li><li>在子类的构造函数中，只有调用super之后才可用this关键字。这是因为子类实例的构建基于父类实例，只有super方法才能调用父类实例，下列代码中子类的constructor方法没有调用super直线使用this关键字会报错，放在super方法后就是对的</li></ul><pre><code>class Father{    constructor(x,y){        this.x = x;        this.y = y;    }    class Child extends Father{        constructor(x,y,age){            this.age = age;//ReferenceError            super(x,y);            this.age = age; //true        }    }}let ch = new Child(25,8,18);ch instanceof Child;//truech instanceof Father;//true//实例对象ch同时是Child和Father两个类的实例，与es5的行为完全一致</code></pre><blockquote><p>父类的静态方法也会被子类继承</p></blockquote><pre><code>class Father{    static hello(){        console.log('hello world')    }}class Child extends Father{}Child.hello()//hello world</code></pre><h1 id="ES5继承的一些补充"><a href="#ES5继承的一些补充" class="headerlink" title="ES5继承的一些补充"></a>ES5继承的一些补充</h1><ol><li>原型链继承</li></ol><blockquote><p>简单理解就是将父类的实例作为子类的原型</p></blockquote><pre><code>function Parent() {   this.isShow = true   this.info = {       name: "yhd",       age: 18,   };} Parent.prototype.getInfo = function() {   console.log(this.info);   console.log(this.isShow); // true} function Child() {};Child.prototype = new Parent(); let Child1 = new Child();Child1.info.gender = "男";Child1.getInfo();  // {name: "yhd", age: 18, gender: "男"} let child2 = new Child();child2.getInfo();  // {name: "yhd", age: 18, gender: "男"}child2.isShow = false console.log(child2.isShow); // false</code></pre><ul><li>优点：父类方法可以复用。</li><li>缺点：父类的所有引用属性会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响；子类型实例不能给父类型构造函数传参。</li></ul><ol><li>借用构造函数<blockquote><p>在子类构造函数中调用父类构造函数，可以在子类构造函数中使用call()和apply()方法</p></blockquote></li></ol><pre><code>function Parent() {  this.info = {    name: "yhd",    age: 19,  }} function Child() {    Parent.call(this)} let child1 = new Child();child1.info.gender = "男";console.log(child1.info); // {name: "yhd", age: 19, gender: "男"}; let child2 = new Child();console.log(child2.info); // {name: "yhd", age: 19}</code></pre><p>​- 通过使用call()或apply()方法，Parent构造函数在为Child的实例创建的新对象的上下文执行了，就相当于新的Child实例对象上运行了Parent()函数中的所有初始化代码，结果就是每个实例都有自己的info属性。</p><p>2.1 传递参数</p><blockquote><p>相比于原型链继承，盗用构造函数的一个优点在于可以在子类构造函数中像父类构造函数传递参数。</p></blockquote><pre><code>function Parent(name) {    this.info = { name: name };}function Child(name) {    //继承自Parent，并传参    Parent.call(this, name);      //实例属性    this.age = 18} let child1 = new Child("yhd");console.log(child1.info.name); // "yhd"console.log(child1.age); // 18 let child2 = new Child("wxb");console.log(child2.info.name); // "wxb"console.log(child2.age); // 18</code></pre><blockquote><p>优点:可以在子类构造函数中向父类传参数；父类的引用属性不会被共享。<br>缺点：子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化</p></blockquote><ol start="3"><li>组合继承</li></ol><blockquote><p>组合继承综合了原型链继承和盗用构造函数继承(构造函数继承)，将两者的优点结合了起来，基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p></blockquote><pre><code>function Parent(name) {   this.name = name   this.colors = ["red", "blue", "yellow"]}Parent.prototype.sayName = function () {   console.log(this.name);} function Child(name, age) {   // 继承父类属性   Parent.call(this, name)   this.age = age;}// 继承父类方法Child.prototype = new Parent(); Child.prototype.sayAge = function () {   console.log(this.age);} let child1 = new Child("yhd", 19);child1.colors.push("pink");console.log(child1.colors); // ["red", "blue", "yellow", "pink"]child1.sayAge(); // 19child1.sayName(); // "yhd" let child2 = new Child("wxb", 30);console.log(child2.colors);  // ["red", "blue", "yellow"]child2.sayAge(); // 30child2.sayName(); // "wxb"</code></pre><p>上面例子中，Parent构造函数定义了name，colors两个属性，接着又在他的原型上添加了个sayName()方法。Child构造函数内部调用了Parent构造函数，同时传入了name参数，同时Child.prototype也被赋值为Parent实例，然后又在他的原型上添加了个sayAge()方法。这样就可以创建 child1，child2两个实例，让这两个实例都有自己的属性，包括colors，同时还共享了父类的sayName方法。</p><ul><li>优点：父类的方法可以复用；可以在Child构造函数中向Parent构造函数中传参；父类构造函数中的引用属性不会被共享。</li></ul><ol start="4"><li>原型式继承<blockquote><p>对参数对象的一种浅复制,使用原型式继承对一个目标对象进行浅复制，增强这个浅复制的能力。</p></blockquote></li></ol><pre><code>function objectCopy(obj) {  function Fun() { };  Fun.prototype = obj;  return new Fun()} let person = {  name: "yhd",  age: 18,  friends: ["jack", "tom", "rose"],  sayName:function() {    console.log(this.name);  }} let person1 = objectCopy(person);person1.name = "wxb";person1.friends.push("lily");person1.sayName(); // wxb let person2 = objectCopy(person);person2.name = "gsr";person2.friends.push("kobe");person2.sayName(); // "gsr" console.log(person.friends); // ["jack", "tom", "rose", "lily", "kobe"]</code></pre><ul><li>优点：父类方法可复用。</li><li>缺点：父类的引用会被所有子类所共享；子类实例不能向父类传参。</li></ul><ol start="5"><li>寄生式继承</li></ol><pre><code>function objectCopy(obj) {  function Fun() { };  Fun.prototype = obj;  return new Fun();} function createAnother(original) {  let clone = objectCopy(original);  clone.getName = function () {    console.log(this.name);  };  return clone;} let person = {     name: "yhd",     friends: ["rose", "tom", "jack"]} let person1 = createAnother(person);person1.friends.push("lily");console.log(person1.friends);person1.getName(); // yhd let person2 = createAnother(person);console.log(person2.friends); // ["rose", "tom", "jack", "lily"]</code></pre><h2 id="6-寄生式组合继承"><a href="#6-寄生式组合继承" class="headerlink" title="6. 寄生式组合继承"></a>6. 寄生式组合继承</h2><pre><code>function objectCopy(obj) {  function Fun() { };  Fun.prototype = obj;  return new Fun();} function inheritPrototype(child, parent) {  let prototype = objectCopy(parent.prototype); // 创建对象  prototype.constructor = child; // 增强对象  Child.prototype = prototype; // 赋值对象} function Parent(name) {  this.name = name;  this.friends = ["rose", "lily", "tom"]} Parent.prototype.sayName = function () {  console.log(this.name);} function Child(name, age) {  Parent.call(this, name);  this.age = age;} inheritPrototype(Child, Parent);Child.prototype.sayAge = function () {  console.log(this.age);} let child1 = new Child("yhd", 23);child1.sayAge(); // 23child1.sayName(); // yhdchild1.friends.push("jack");console.log(child1.friends); // ["rose", "lily", "tom", "jack"] let child2 = new Child("yl", 22)child2.sayAge(); // 22child2.sayName(); // ylconsole.log(child2.friends); // ["rose", "lily", "tom"]</code></pre><ul><li>优点：只调用一次父类构造函数;Child可以向Parent传参;父类方法可以复用;父类的引用属性不会被共享。</li><li>寄生式组合继承可以算是引用类型继承的最佳模式</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this/apply/call/bind</title>
      <link href="/2021/09/25/paper-this/"/>
      <url>/2021/09/25/paper-this/</url>
      
        <content type="html"><![CDATA[<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><blockquote><p>es5中，<strong>this永远指向最后调用它的对象</strong></p></blockquote><pre><code>var name = 'windowsName';var a = {    name:null,    fn:function(){        console.log(this.name); //windowsName    }}var f = a.fn;f();</code></pre><p>虽然将a对象的fn方法赋值给变量f了，但是没有调用所以fn()，最后仍然是被window调用的</p><h1 id="怎么改变this指向"><a href="#怎么改变this指向" class="headerlink" title="怎么改变this指向"></a>怎么改变this指向</h1><h2 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1.箭头函数"></a>1.箭头函数</h2><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        //匿名函数没有自己的this        setTimeout(function(){            this.func1()        },100);    }};a.func2() //this.func1 is not a function</code></pre><p>不使用箭头函数的情况下是会报错的，因为最后调用setTimeout的对象是window，window中没有func<br>函数</p><p>使用箭头函数后</p><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(()=&gt;{            this.func1()        },100);    }};a.func2() //csl</code></pre><p>箭头函数的this始终指向<strong>函数定义时</strong>的this，而非执行时。    </p><blockquote><p>箭头函数中没有this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this，否则this为undefined</p></blockquote><h2 id="2-在函数内部使用-this-this"><a href="#2-在函数内部使用-this-this" class="headerlink" title="2.在函数内部使用_this = this"></a>2.在函数内部使用_this = this</h2><pre><code>var name = windowsName;var a ={    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        var _this = this;        //匿名函数没有自己的this        setTimeout(function(){            _this.func1()        },100);    }};a.func2() //csl</code></pre><p>设置var _this = this，这里的this是调用func2的对象a，防止在func2中的setTimeout被window调用，这样在func2中我们使用_this就是指向对象a了</p><h2 id="3-new实例化一个对象"><a href="#3-new实例化一个对象" class="headerlink" title="3.new实例化一个对象"></a>3.new实例化一个对象</h2><h2 id="4-使用apply，call，bind"><a href="#4-使用apply，call，bind" class="headerlink" title="4.使用apply，call，bind"></a>4.使用apply，call，bind</h2><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.apply(a),100);    }};a.func2() //csl</code></pre><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.call(a),100);    }};a.func2() //csl</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code>var a = {    name:'csl',    func1:function(){        console.log(this.name)    },    func2:function(){        setTimeout(function(){            this.func1()        }.bind(a)(),100);    }};a.func2() //csl</code></pre><h1 id="apply-call-bind区别"><a href="#apply-call-bind区别" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h1><h2 id="apply定义"><a href="#apply定义" class="headerlink" title="apply定义"></a>apply定义</h2><blockquote><p>apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组或类数组提供的参数<br>语法：<code>func.apply(thisArg,[argsArray])</code></p></blockquote><ul><li>this.Arg:在func函数运行时指定的this值。<blockquote><p>需要注意的是指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动之乡全局对象，同时值为原始值的this会指向该原始值的自动包装对象</p></blockquote></li><li>argsArray:一个数组或者类数组对象，其中数组元素将作为单的的参数传给func函数<blockquote><p>如果该参数的值为null或undefined，则表示不需要传入任何参数，从es5中开始可以使用类数组对象</p></blockquote></li></ul><h2 id="apply-call的区别"><a href="#apply-call的区别" class="headerlink" title="apply/call的区别"></a>apply/call的区别</h2><p>apply和call基本类似，它们的区别只是传入的参数不同</p><ul><li>call的语法为:<code>func.call(thisArg[,arg1[,arg2[,...]]])</code></li><li>call方法接受的是若干个参数列表，而apply接受的是一个包含多个参数的数组</li></ul><p>apply():</p><pre><code>var a = {    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.apply(a,[1,2]); //3</code></pre><p>call():</p><pre><code>var a = {    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.call(a,1,2); //3</code></pre><h2 id="apply-call-bind区别-1"><a href="#apply-call-bind区别-1" class="headerlink" title="apply/call/bind区别"></a>apply/call/bind区别</h2><blockquote><p>bind方法创建一个新的函数，当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列<br>bind是创建一个新函数，我们必须手动调用</p></blockquote><pre><code>var a ={    name:'csl',    fn:function(a,b){        console.log(a+b)    }}var b = a.fn;b.bind(a,1,2)() //3</code></pre><h1 id="js的函数调用"><a href="#js的函数调用" class="headerlink" title="js的函数调用"></a>js的函数调用</h1><h2 id="1-作为一个函数调用"><a href="#1-作为一个函数调用" class="headerlink" title="1.作为一个函数调用"></a>1.作为一个函数调用</h2><pre><code>var name = 'windowsName';function a(){    var name = 'csl';        console.log(this.name); //windowsName    console.log('inner'+this);  //inner:window}a();console.log('outer'+this)   //outer:window</code></pre><p>这是一个最简单的函数，不属于任何一个对象，它在js的非严格模式属于window，严格模式就是undefined</p><h2 id="2-函数作为方法调用"><a href="#2-函数作为方法调用" class="headerlink" title="2.函数作为方法调用"></a>2.函数作为方法调用</h2><pre><code>var name = 'windowsName';var a = {    name:'csl',    fn:function(){        console.log(this.name); //csl    }}a.fn()</code></pre><p>定义一个对象a，对象a有属性name和一个方法fn，对象a调用了fn方法，所以this指向a的</p><h2 id="3-使用构造函数调用函数"><a href="#3-使用构造函数调用函数" class="headerlink" title="3.使用构造函数调用函数"></a>3.使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了new,看起来就像是创建了新的函数，但实际上是新创建的对象，所以this会指向新创建的对象</p></blockquote><pre><code>function myFunction(arg1,arg2){    this.firstName = arg1;    this.lastName = args2;}var a = new myFunction('cheng','sl');a.lastName; //'sl'</code></pre><p>扩展：<br>new的过程:</p><ul><li>创建一个空对象obj</li><li>将新建的空对象的隐式原型指向其构造函数的显示原型</li><li>使用call改变this指向</li><li>如果无返回值或返回一个非对象值，则将obj返回作为新对象；如果返回值是一个新对象的话直接返回该对象<br>伪代码表述如下：<br>```<br>var a = new myFunction(‘cheng’,’sl’);</li></ul><p>new myFunction{<br>    var obj = {};<br>    obj.<strong>proto</strong> = myFunction.prototype;<br>    var result = myFunction.call(obj,’cheng’,’sl’);<br>    return typeof result === ‘obj’?result:obj;<br>}</p><pre><code>## 4.作为函数方法调用函数(call,apply)&gt; js中，函数是对象，对象有自己的属性和方法，则函数也有它的属性和方法，call，apply是预定义的函数方法，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身- js严格模式下，调用函数时第一个参数会成为this的值，即使这个参数不是一个对象- js非严格模式下，如果第一个参数的值是null或undefined，它将使用全局对象替代</code></pre><p>var name = ‘windowsName’;<br>function fn(){<br>    var name = ‘csl’;<br>    innerFunction()；<br>    function innerFunction(){<br>        console.log(this.name);<br>    }<br>}<br>fn()</p><pre><code>这里的innerFunction()的调用属于第一种作为函数调用的方式，它没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下this就是指向window的</code></pre><p>var name = ‘windowsName’;<br>var a = {<br>    name:’csl’,</p><pre><code>func1:function(){    console.log(this.name)},func2:function(){    setTimeout(function(){        this.func1()    },100)}</code></pre><p>};<br>a.func2() //this.func1 is not a function</p><p>```<br>上面的例子可以简单理解为<strong>匿名函数的this永远只需window</strong>。<br>匿名函数都是自执行的，就是在匿名函数后面加()让其自执行，虽然匿名函数不能被其他对象调用，但是可以被函数调用，比如例子中的setTimeout</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量作用域、闭包、js函数执行流程</title>
      <link href="/2021/09/24/paper-closure/"/>
      <url>/2021/09/24/paper-closure/</url>
      
        <content type="html"><![CDATA[<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><blockquote><p>当一个函数是在另一个函数中创建的时，该函数就称为嵌套的</p></blockquote><pre><code>function sayHiBye(firstName,lastName){    function getFullName(){        return firstName + '' + lastName;    }    alert('Hello,' + getFullName());    alert('Bye' + getFullName())}</code></pre><p>这里创建的嵌套函数getFullName()是为了更加方便访问到外部变量，因此可以返回全名，<br>也可以作为一个新对象的属性或结果返回一个嵌套函数（如下代码），之后可以在其他地方调用，不论在哪调用，它仍然可以访问相同的外部变量</p><pre><code>function makeCounter(){    let count = 0;    return function(){        return count++;    };}let counter = makeCounter();alert(counter());//0alert(counter());//1 可以累加</code></pre><h2 id="词法环境-Lexical-Environment"><a href="#词法环境-Lexical-Environment" class="headerlink" title="词法环境(Lexical Environment)"></a>词法环境(Lexical Environment)</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><blockquote><p>js中，每个运行的函数，代码块以及整个脚本都有一个被称为词法环境的内部关联对象  </p></blockquote><p>词法环境对象由两部分组成    </p><ul><li>环境记录(Environment Record) 一个存储所有局部变量作为其属性(例如this的值)的对象</li><li>对外部词法环境的引用，与外部代码相关联    </li></ul><blockquote><p>一个变量只是环境记录这个特殊对象的一个属性，获取或修改变量相当于获取或修改词法环境的一个属性</p></blockquote><p>下面的图片中，矩形表示环境记录(变量存储)箭头表示外部引用，全局词法环境没有外部引用，所以箭头指向了null<br><img src="/2021/09/24/paper-closure/1.jpg" alt="alt"></p><p>下图演示了执行过程中<strong>全局词法环境</strong>的变化</p><ul><li>最初它们处于未初始化(Uninitalized)状态，在let声明前，不能引用它</li><li>let声明，但没赋值</li><li>phrase被赋值</li><li>phrase的值被修改<br><img src="/2021/09/24/paper-closure/2.jpg" alt="alt"></li></ul><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><blockquote><p>一个函数也是一个值，与变量不同的是<strong>函数声明的初始化会被立即完成</strong></p></blockquote><p>当创建了一个词法环境时，函数立即变得可用，这就是我们为什么可以在函数声明的定义之前调用函数声明</p><p>下图是添加一个函数时全局词法状态的初始状态<br><img src="/2021/09/24/paper-closure/3.jpg" alt="alt"></p><h3 id="内部和外部的词法环境"><a href="#内部和外部的词法环境" class="headerlink" title="内部和外部的词法环境"></a>内部和外部的词法环境</h3><blockquote><p>当函数被调用时，会自动创建一个新的词法环境来存储这个调用的局部变量和参数</p></blockquote><p>如下图，我们有两个词法环境：内部(函数)和外部(全局)，当调用say函数时，它会<strong>先搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，直到全局词法环境</strong><br><img src="/2021/09/24/paper-closure/4.jpg" alt="alt"></p><p>搜索过程如下：</p><ul><li>对于name变量，当say中的alert试图访问name时，会立即在内部词法环境中找到它</li><li>当它试图访问phrase时，内部无phrase，使用它顺着<strong>对外部词法环境的引用</strong>找到了它<br><img src="/2021/09/24/paper-closure/5.jpg" alt="alt"></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote><p>闭包是指内部函数总是可以访问其所在的外部函数中的变量和参数，除了构造函数，其他的js函数都是天生闭包的，也就是说js函数会通过隐藏的[[Evironmrnt]]属性记住它们创建的位置，所以它们可以访问外部变量<br>返回文初的<code>makeCounter</code>这个例子</p></blockquote><pre><code>function makeCounter(){    let count = 0;    return function(){        return count++    };}let counter = makeCounter()</code></pre><p>在每次调用makeCount之前都会创建一个新的词法环境对象，以存储该makeCounter运行时的变量<br>因此，我们有两层的词法环境，还有一个未被使用的嵌套函数return count++，它依旧有一个名为[[Environment]]的隐藏属性，该属性保存了对创建该函数的词法环境的引用，因此，counter.[[Environment]]有对{content:0}词法环境的引用<br>当调用counter()时，会为该引用创建一个新的词法环境<br><img src="/2021/09/24/paper-closure/6.jpg" alt="alt"><br>当counter()中的代码查找count变量时，它会先搜索自己的词法环境(空),然后是外部makeCounter()的词法环境在哪里找到就在哪里修改(下图中是在count那里修改的变量)<br>如果我们调用多次counter()，count变量将会增加到2，3<br><img src="/2021/09/24/paper-closure/7.jpg" alt="alt"></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul><li><p>函数<strong>调用完之后</strong>会将词法环境中的所有变量从内存中删除</p></li><li><p>如果有一个乔涛的函数在函数结束后仍可达，则它具有引用词法环境的[[Environment]]属性，例子如下</p><pre><code>function f(){  let value = 123;  return function(){      alert(++value);  }}let g = f();//g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用g();g();g(); //多次调用并且返回的函数被保存，所以相应的词法环境也会保留在内存中</code></pre><p>当词法环境对象变得不可达时，他就会死去，它仅在至少有一个乔涛韩束引用它时才会存在</p></li></ul><h2 id="一些闭包的例子"><a href="#一些闭包的例子" class="headerlink" title="一些闭包的例子"></a>一些闭包的例子</h2><h3 id="函数会选择最新的内容吗"><a href="#函数会选择最新的内容吗" class="headerlink" title="函数会选择最新的内容吗"></a>函数会选择最新的内容吗</h3><pre><code>let name = 'John';function sayHi(){    alert('Hi' + name);}name = 'Pete';sayHi();</code></pre><ul><li>函数将从内向外依次寻找目标变量，变量在全局中</li><li>name = ‘Pete’相当于给name重新赋值，这个函数使用最新的值</li></ul><h3 id="哪些变量可用"><a href="#哪些变量可用" class="headerlink" title="哪些变量可用"></a>哪些变量可用</h3><p><code>makeWorker</code>函数是否可以从它被创建的位置或者调用位置访问外部变量</p><pre><code>function makeWorker(){    let name = 'Pete';    return function(){        alert(name);    };}let name = 'John';let work = makeWorker();work()//pete</code></pre><h3 id="反复调用counter实例的方法时"><a href="#反复调用counter实例的方法时" class="headerlink" title="反复调用counter实例的方法时"></a>反复调用counter实例的方法时</h3><pre><code>function Counter(){    let count = 0;    this.up = function(){        return ++count    }    this.down = function(){        return --count;    }}let counter = new Counter();console.log(counter.up());console.log(counter.down());console.log(counter.up());</code></pre><ul><li>这两个嵌套函数都是在同一个词法环境中创建的，使用它们可以共享对同一个count变量的访问，</li><li>使用前置自增++x，操作数x 将在自增后返回，所以第一个是1第二个是2，第三个是1</li></ul><h3 id="if内的函数"><a href="#if内的函数" class="headerlink" title="if内的函数"></a>if内的函数</h3><pre><code>let phrase = 'Hello';if(ture){    let user = 'John';    function sayHi(){        alert(`${phrase},${user}`)    }}sayHi();</code></pre><ul><li>sayHi是在if内声明的，所以它只存在于if中外部是没有sayHi的</li></ul><h3 id="不可见变量"><a href="#不可见变量" class="headerlink" title="不可见变量"></a>不可见变量</h3><pre><code>let x = 1;function func(){    console.log(x);    let x = 2;}func();</code></pre><ul><li>let只在块级作用域下起作用，获取不到全局的x</li><li>并且有暂时性死区，无法变量提升，所以在函数执行时无法获取到下面的x值</li></ul><h1 id="JS函数的执行顺序与闭包"><a href="#JS函数的执行顺序与闭包" class="headerlink" title="JS函数的执行顺序与闭包"></a>JS函数的执行顺序与闭包</h1><blockquote><p>总所周知，JS在栈内存(浏览器一加载就形成了栈内存)中执行函数，函数执行时会形成一个执行上下文（执行栈）并且把执行上下文压缩到栈内存里执行。</p></blockquote><pre><code>var test = (function(i) {    return function() {        alert( i*2 )    }})(2);test(5);</code></pre><p><strong>上述代码的执行流程为：</strong></p><ul><li>先把IIFE<strong>执行后的值</strong>赋值给test，那么它的词法环境中含有：形参i=2，return的function的堆内存地址（因为它指向了一个堆内存地址，这个堆内存在执行，所以它被引用而且不会被回收，形成了闭包）</li><li>假设它执行后return的内存地址为AAAFFF111，这个AAAFFF111指向的堆内存中又含有: 作为函数存储的代码字符串<code>'alert(i*2)'</code>以及作为对象存储的prototype，length形参个数(所以说函数也是对象)，又因为它被保留了引用，所以它不会被回收</li><li>最后执行test(5)，在它的词法环境中没有形参i的值，所以它会去它的上层 作用域中寻找i，找到了上述第一个执行的test的词法作用域并且销毁自身，因为上层作用域不会被销毁，所以输出的值为alert(4)即’4’<blockquote><p>总结：所有的引用类型都是一个堆，我们所有的操作都是对堆的内存地址的操作</p></blockquote></li></ul><p><img src="/2021/09/24/paper-closure/function-closure1.jpg" alt="alt"></p><p>下例涉及到的闭包知识并不多</p><pre><code>function Foo(){    getName = function(){        console.log(1);    }    return this}Foo.getName = function() {    console.log(2)}Foo.prototype.getName = function(){    console.log(3)}var getName = function() {    console.log(4)}function getName(){    console.log(5)}Foo.getName();getName();Foo().getName();getName()new Foo.getName();new Foo().getName();new new Foo().getName();</code></pre><p>分析得</p><ul><li>有var说明是es5的语法应该先考虑变量提升，然后才是代码执行</li><li><code>getName()</code>函数先提升被执行,之后被var getName这个在函数执行阶段执行的函数覆盖</li><li><code>Foo().getName()</code>:Foo()返回的结果再调用getName</li><li><code>new Foo.getName()</code>与<code>new Foo().getName()</code>的区别在于调用的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" title="default 优先级" target="">优先级</a>不同：圆括号&gt;成员访问(点)=new,当优先级相同时，执行顺序从左往右<br><img src="/2021/09/24/paper-closure/function-closure2.jpg" alt="alt"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2021/09/20/paper-4/"/>
      <url>/2021/09/20/paper-4/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>一种遵从先进后出（LIFO）原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都靠近栈底</li><li>一摞叠起来的数或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要先将上面的书移走才可以</li><li>栈也被用在编程语言的编译器和内存中保存变量，方法调用<br>```angular2html<br>//在js中使用类来实现一个栈<br>class Stack {</li></ul><p>constructor() {<br>this.items = []<br>}</p><p>// 入栈<br>push(element) {<br>this.items.push(element)<br>}</p><p>// 出栈<br>pop() {<br>return this.items.pop()<br>}</p><p>// 末位<br>get peek() {<br>return this.items[this.items.length - 1]<br>}</p><p>// 是否为空栈<br>get isEmpty() {<br>return !this.items.length<br>}</p><p>// 尺寸<br>get size() {<br>return this.items.length<br>}</p><p>// 清空栈<br>clear() {<br>this.items = []<br>}</p><p>// 打印栈数据<br>print() {<br>console.log(this.items.toString())<br>}<br>        }<br>// 实例化一个栈<br>const stack = new Stack()<br>console.log(stack.isEmpty) // true</p><p>// 添加元素<br>stack.push(5)<br>stack.push(8)</p><p>// 读取属性再添加<br>console.log(stack.peek) // 8<br>stack.push(11)<br>console.log(stack.size) // 3<br>console.log(stack.isEmpty) // false</p><pre><code>## 队列- 与栈相反，队列是一种遵循先进先出(FIFO)原则的一组有序的项，队列在尾部添加新元素，并从头移除元素。最新添加的元素必须排在队列的末尾- 在现实中，最常见的例子就是排队，前面的人优先完成自己的事务，完成之后，下一个人才能继续```angular2htmlclass Queue {constructor(items) {this.items = items || []}enqueue(element){this.items.push(element)}dequeue(){return this.items.shift()}front(){return this.items[0]}clear(){this.items = []}get size(){return this.items.length}get isEmpty(){return !this.items.length}print() {console.log(this.items.toString())}        }const queue = new Queue()console.log(queue.isEmpty) // truequeue.enqueue('John')queue.enqueue('Jack')queue.enqueue('Camila')console.log(queue.size) // 3console.log(queue.isEmpty) // falsequeue.dequeue()queue.dequeue()queue.print() // 'Camila'</code></pre><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li>优先队列是默认队列的修改版。现实生活中的例子就是机场登机的顺序，头等舱和商务舱乘客的优先级要高于经济舱乘客</li><li>优先队列元素的添加和移除是基于优先级的</li><li>实现一个优先队列，有两种选项：设置优先级，然后在正确的位置添加元素；或者用入列操作添加元素，按照优先级移除它们<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3></li><li>为充分利用向量空间，客服假溢出现象的方法是：将向量想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列。这种循环队列可以以单链表，队列的方式来实际编程应用中来实现<h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ul><h2 id="JS的数据类型和数据结构"><a href="#JS的数据类型和数据结构" class="headerlink" title="JS的数据类型和数据结构"></a>JS的数据类型和数据结构</h2><h3 id="基本类型（栈stack）"><a href="#基本类型（栈stack）" class="headerlink" title="基本类型（栈stack）"></a>基本类型（栈stack）</h3><pre><code>Number，String，Boolean，Null，Undefind，null（不可用typeof检测），Symbol（ES6中新增）：代表创建后独一无二且不可变的数据类型，它的出现我认为是为了解决可能出现的全局变量冲突的问题</code></pre><h3 id="引用数据类型（堆head）"><a href="#引用数据类型（堆head）" class="headerlink" title="引用数据类型（堆head）"></a>引用数据类型（堆head）</h3><pre><code>Object（包括Array，Function，Data）   </code></pre><h3 id="每个数据都需要一个内存空间"><a href="#每个数据都需要一个内存空间" class="headerlink" title="每个数据都需要一个内存空间"></a>每个数据都需要一个内存空间</h3><table><thead><tr><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>可直接操作保存在栈内存空间的值</td><td>不允许直接访问，不能直接操作</td></tr><tr><td>变量名，值       —&gt;引用</td><td>值</td></tr><tr><td>c，0X0012</td><td>[1,2,3]</td></tr></tbody></table><h2 id="基本数据类型和引用数据类型的区别"><a href="#基本数据类型和引用数据类型的区别" class="headerlink" title="基本数据类型和引用数据类型的区别"></a>基本数据类型和引用数据类型的区别</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>基本数据类型的值是不可变的</li><li>基本数据类型不可以添加属性和方法，虽然不会报错，但也只是一瞬间转为了相应包装对象，操作完又转化回基本数据类型，不会保存结果</li><li>基本数据类型的赋值是简单赋值，基本数据类型的比较是值的比较</li><li>基本数据类型是存放在栈区的<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3></li><li>引用类型的值是可以改变的，例如对象就可以通过修改对象属性更改对象</li><li>引用类型可以添加属性方法</li><li>引用类型的赋值是对象引用，声明的变量标识符，存储的只是对象的指针地址</li><li>引用类型的比较是引用（指针地址）的比较</li><li>引用类型是同时保存在栈区和堆区中的，栈区保存变量标识符和指向堆内存的地址</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jump项目</title>
      <link href="/2021/09/12/post-name/"/>
      <url>/2021/09/12/post-name/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/09/12/post-name/tagData.gif" alt="alt"></p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><p><code>Object.create(proto,[descriptors])</code></p><ul><li>完全可以取代__proto__</li><li><code>Object.getPrototypeOf(obj)</code> – 返回对象obj的[[Prototype]]</li><li><code>Object.setPrototypeOf(obj,proto)</code> – 将对象的[[prototype]]设置为proto</li></ul><pre><code>let animal = {    eats:true};//常见一个以animal为原型的新对象let rabit = Object.create(animal);alert(rabibit.eats);alert(Object.getPrototypeOf(rabbit) === animal) //true//将rabbit的原型修改为{}Object.setPrototypeOf(rabbit,{})</code></pre><ul><li>Object.create有一个可选的第二参数：属性描述器，我们可以在此处为新对象提供额外的属性<pre><code>let animal = {  eats:true}let rabbot = Object.create(animal,{  jumps:{      value:true  }});alert(rabbit.jumps); //true</code></pre></li><li>使用Object.create来实现克隆一个对象的所有描述符<br><code>let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo报错总结</title>
      <link href="/2021/09/12/paper-3/"/>
      <url>/2021/09/12/paper-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从零开始搭建hexo到安装theme主题这段比较顺利，到安装主题之后开始出现错误</p></blockquote><h2 id="1-Error-no-such-file-or-directory-scandir-‘…-’"><a href="#1-Error-no-such-file-or-directory-scandir-‘…-’" class="headerlink" title="1. Error:no such file or directory,scandir ‘….’"></a>1. Error:no such file or directory,scandir ‘….’</h2><p>加入主题之后运行所有hexo命令都会报如下错误<br><img src="/2021/09/12/paper-3/image2.png" alt="alt"><br>排查之后，blog主题这一栏填成了别人主题的theme地址，直接写上theme主题名字就行了<br><img src="/2021/09/12/paper-3/img3.png" alt="alt"><br>接着除了hexo-d其他命令都能运行</p><h2 id="2-spawn-failed"><a href="#2-spawn-failed" class="headerlink" title="2.spawn failed"></a>2.spawn failed</h2><p>用hexo-d更新的时候报错 <code>spawn failed</code><br>检查了自己的github ssh地址 显示：but Github does not provide shell access<br>更改myblog目录下的config.yml的repo<br><img src="/2021/09/12/paper-3/img4.png" alt="图片无法加载sorry"></p><h2 id="3-not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#3-not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="3.not a git repository (or any of the parent directories): .git"></a>3.not a git repository (or any of the parent directories): .git</h2><blockquote><p>暂时不太清楚这个的报错原因，可能是当时服务器的问题，第二天登了之后就好了</p></blockquote><p><img src="/2021/09/12/paper-3/img7.png" alt="图片alt"></p><h2 id="4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…"><a href="#4-can-not-read-a-block-mapping-entry-a-multiline-key-may-not-be-an-implicit-key-…" class="headerlink" title="4.can not read a block mapping entry ;a multiline key may not be an implicit key ….."></a>4.can not read a block mapping entry ;a multiline key may not be an implicit key …..</h2><p>上传paper.md的时候报错<br><img src="/2021/09/12/paper-3/img10.png" alt="图片alt"><br>因为paper.md标题中的语法不是很规范，冒号后面没有加空格，及config.yml中的语法也该如此<br>正确书写应该是tags： js<br><img src="/2021/09/12/paper-3/img11.png" alt="图片alt"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout与setInterval</title>
      <link href="/2021/08/29/paper-1/"/>
      <url>/2021/08/29/paper-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有时我们并不想立即执行一个函数而是等待特定一段时间后再执行。这就是所谓的’计划调用(scheduling a call)’<br>目前有两种方法可以实现：</p></blockquote><ul><li>setTimeout：允许我们将函数推迟到一段时间间隔之后再执行</li><li>setInterval：允许我们重复运行一个函数，从一段时间间隔之后开始运行，之后以该时间间隔连续重复运行该函数</li></ul><h1 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h1><p>语法：<code>let timerId= setTimeout(func|code,[delay],[arg1],[arg2],...)</code></p><ul><li><code>func|code</code>:想要执行的函数或代码字符串，一般传入的都是函数</li><li><code>delay</code>:执行前的延时，毫秒为单位1ms = 1s；</li><li><code>arg1,arg2...</code>:要传入被执行函数的参数列表<br>例如下面这个示例中sayHi()方法会在1s后执行：<pre><code>function sayHi(phrase,who){  alert(phrase + ',' + who);}setTimeout(sayHi,1000,'hello','neo');//hello,neo</code></pre>如果第一个参数传入的是字符串，js会自动为其创建一函数<pre><code>setTimeout('alert('hello')',1000);//建议使用箭头函数代替它们setTimeout(()=&gt; alert('hello'),1000);</code></pre></li><li>setTimeout传入的函数参数一般不需要加上括号<code>setTimeout(sayHi(),1000)//false</code>;</li><li>setTimeout期望得到一个对函数的<strong>引用</strong>，加上括号明显是在执行函数，实际上传入setTimeout的是函数的执行结果</li></ul><h2 id="clearTimeout取消调度"><a href="#clearTimeout取消调度" class="headerlink" title="clearTimeout取消调度"></a>clearTimeout取消调度</h2><p>语法：<code>let timerId = setTimeout(...); clearTimeout(timerId)</code></p><h1 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h1><ul><li>语法和setTimeout相同:<code>let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)</code></li><li>参数的意义也相同，不过与setTimeout只执行一次不同，setInterval是每间隔给定的时间周期性执行。</li><li>想要阻止后续调用，我们需要调用<code>clearInerval(timerId)</code></li></ul><pre><code>//每2s重复一次let timerId = setInterval(() =&gt; alert('t'),2000);//5s后停止setTimeout(()=&gt; {clearInterval(timerId);alert('stop');},5000);</code></pre><ul><li>在大多数浏览器中，在显示<code>alert/confirm/prompt</code>弹窗时，内部的定时器仍然会继续进行</li><li>如果在一定时间内没有关掉alert弹窗下一个alert会立即显示且两次alert的时间间隔小于2s</li></ul><h1 id="嵌套的setTimeout"><a href="#嵌套的setTimeout" class="headerlink" title="嵌套的setTimeout"></a>嵌套的setTimeout</h1><p>setInterval</p><pre><code>let timerId = setInterval(() =&gt; alert('tick'),2000);</code></pre><p>相当于setTimeout在当前这一次函数执行完时立即调度下一次调用</p><pre><code>let timerId = setTimeout(function tick(){    alert('tick');    timerId = setTimeout(tick,2000);},2000);</code></pre><ul><li>嵌套的setTimeout比setInterval灵活得多，采用这种方式可以根据当前执行结果来调度下一次调用</li><li>例如我们要实现一个每间隔5s向服务器发送一个数据请求服务器过载，要降低请求频率将间隔增加到10、20s等<pre><code>let dekay = 5000;let timerId = setTimeout(function request(){  if(request failed due to server overload){      delay *= 2;  }  timerId = setTimeout(request,delay);},delay);</code></pre></li></ul><p><strong>嵌套的setTimeout能够精准地设置两次执行之间的间隔时间而setInterval却不能</strong></p><ul><li><p>setInterval</p><blockquote><p>使用setInterval时，func函数实际调用间隔要比代码中设定的时间间隔要短(&lt;100ms)</p></blockquote><pre><code>let i = 1;setTimeout(function run(){    func()})</code></pre></li><li><p>setTimeout</p><blockquote><p>嵌套的setTimeout就能保证延时的固定(100ms)</p></blockquote><pre><code>let i = 1;setTimout(function run(){    func(i++);    setTimeout(run,100);},100)</code></pre><h2 id="垃圾回收和setInterval-setTimeout回调"><a href="#垃圾回收和setInterval-setTimeout回调" class="headerlink" title="垃圾回收和setInterval/setTimeout回调"></a>垃圾回收和setInterval/setTimeout回调</h2></li><li><p>当一个函数中传入setInterval/setTimeout时，将为其创建一个内部引用，并保存在内存中，<strong>即使这个函数没有被引用，也会保存在内存中不会被销毁</strong></p></li><li><p>对于setInterval传入的函数也是一直存在于内存中直到被clearInternal被调用<br>缺点：</p></li><li><p>如果函数引用了外部变量（译注：闭包），那么只要这个函数还存在，外部变量也会随之存在。它们可能比函数本身占用更多的内存。因此，当我们不再需要调度函数时，最好取消它，即使这是个（占用内存）很小的函数。</p></li></ul><h1 id="setTimeout-func-0"><a href="#setTimeout-func-0" class="headerlink" title="setTimeout(func, 0)"></a>setTimeout(func, 0)</h1><ul><li>这样调用可以让func尽快执行，但是只有在当前执行的脚本执行完成后，调度程序才会调用它</li><li>该函数被当前脚本执行完之后立即执行,比如下面代码会先输出hello再输出world<pre><code>  setTimeout(()=&gt;alert('world'));  alert('hello')</code></pre><h2 id="零延时实际上不为0"><a href="#零延时实际上不为0" class="headerlink" title="零延时实际上不为0"></a>零延时实际上不为0</h2><blockquote><p>在<strong>浏览器环境</strong>下，嵌套定时器的运行频率是受限制的。根据html5标准所讲：经过5重嵌套定时器之后，事件间隔被强制设置为至少4ms</p></blockquote></li></ul><pre><code>let start = Date.now();let times = [];setTimeout(function run(){    times.push(Date.now() - start);//保存前一个调用的延时    if(start + 100 &lt; Date.now()) alert(times);//100ms后显示延时信息    else setTimeout(run);//否则重新调度    // 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100})</code></pre><ul><li>第一次定时器是立即执行的，接下来就可以看待9,15,20,24两次调用间隔为4ms</li><li>如果我们使用setInterval也会发生类似的情况</li><li>对于服务器端的js就没有这个限制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo用法</title>
      <link href="/2021/08/29/paper/"/>
      <url>/2021/08/29/paper/</url>
      
        <content type="html"><![CDATA[<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><blockquote><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用，插入图片的常用方式，你也可以理解为在 Markdown 中插入图片。</p></blockquote><h2 id="本地绝对路径"><a href="#本地绝对路径" class="headerlink" title="本地绝对路径"></a>本地绝对路径</h2><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 Markdown 语法访问它们。<br><code>![alt](/images/test.jpg)</code></p><h2 id="本地相对路径-本博使用"><a href="#本地相对路径-本博使用" class="headerlink" title="本地相对路径 (本博使用)"></a>本地相对路径 (本博使用)</h2><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中，文章的目录可以通过配置 _config.yml 来生成。配置如下：</p><p><code>post_asset_folder: true</code></p><p>将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令 $ hexo new post_name，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。</p><p><code>![alt](test.jpg)</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/08/29/hello-world/"/>
      <url>/2021/08/29/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
